<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[量化CSS选择器优先级]]></title>
      <url>%2F2017%2F03%2F09%2F%E9%87%8F%E5%8C%96CSS%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
      <content type="text"><![CDATA[CSS优先级是一件很让人头痛的事儿，本文介绍了一种方式来帮助解决这个疑难杂症。如何使用数学方法来量化 CSS 优先级，并设计一种合理的比较方法。 不同类型选择器的优先级有三种不同的方法来选择要设置的样式。其优先级由高到低依次为： 通过单独的 ID 或属性选择器进行引用 通过类名在组合中进行引用 通过元素标记进行引用 根据受规则影响的元素数量和类型来处理选择器，这与之前处理冲突的两种方法有些不同。这是由于规则不必每次都只应用到一种选择器上，而可以应用到多个不同的选择器上。 因此需要有一个方法来确定可以拥有任意选择器组合规则的优先级，通过将作用范围从宽到窄进行整理来完成规则特性的计算。 量化CSS规则的优先级一个规则的特性由基于上述编号列表中选择器类型所创建的三部分编号来评价。我们可以创建一个数字组合来计算优先级，这个数字组合以类似 [0, 0, 0] 的形式开始。当处理一个规则时，每个指向 ID 的选择器都会将第一个数字增加 1，所以数字组合会变为 [1, 0, 0]。 下面是个示例，这个规则的选择器中共有 3个 ID 选择器，所以数字组合变为 [3, 0, 0]： 1234#heading, #main, #menu, .text, .quote, .boxout, .news, .comments, p, blockquote, &#123; font-family: Consolas; font-size: 16px;&#125; 接着，选择器中的类选择器的数量决定了数字组合中的第二位数字。在上例中，共有 5个类选择器，所以规则优先级现在是 [3, 5, 0]. 最后，计算出所有指向元素标记的选择器数量，这个数字被放在数字组合的最后。在上例中有两部分（p 和 blockquote），所以最终的数字组合是 [3, 5, 2]，这就是与其他选择器比较优先级时所需要的全部。 在每种类型选择器的数量不超过 9个的情况下，可以将数字组合直接写为一个十进制的数字，比如上例中经过量化之后的优先级为 352。其他经过同样规则量化之后的 CSS 规则，若数值比这个数字小，优先级就比它低；数值比它大的，优先级就高于它。当两条规则拥有相同的数值时，采取”就近原则“，即最近被应用的优先。 使用不同的计数基数当数字组合类型中的数字数量超过 9时，就要使用更高的基数。例如，量化后的优先级为 [11, 7, 9] 不能直接通过拼接三部分的数字来转换成十进制数字，而是把其转变为更高基数，比如讲 20作为基数（如果有的类型超过 19，就要更大）。 具体做法是分别乘以三个部分并把结果相加，从最右边的数字开始向左进行： 123420 x 19 = 380;20 x 20 x 7 = 2800;20 x 20 x 20 x 11 = 88000;总和 911800 如果要使用更高的基数，可用当前基数替换左侧的 20。之后，一旦所有规则集合的组合数字都由这种基数转换为十进制形式时，那么确定每个样式的特性和优先级就很简单了。 幸运的是 CSS 预处理器完成了所有这一切，不过了解它的运作过程会对合理构建规则和理解它们的优先级是有益的。 注意： 如果所有优先级的量化计算让人感觉复杂的话，请使用简单的经验规则；通常，修改的元素越少，规则的特性越强，优先级越高。 有些规则比其他规则更合适当两个或更多规则在优先级上完全相同时，通常是应用最近运行的规则。然而，可以使用 !important 声明来强制一个规则拥有更高的优先级，如： 1p &#123; color: #ff0000 !important; &#125; 当这样做时，所有之前等价的设定都会被覆盖（也包括使用了 !important 的），所有之后处理的等价规则将会被忽略。例如，下面两条规则中的第二条通常会有优先级，但由于先前的语句使用了 !important，第二条语句会被忽略。 12p &#123; color: #f00 !important; &#125;p &#123; color: #ff0; &#125; 注意：可以通过创建用户样式表来指定浏览器的默认样式，还可以使用 !important 声明，以便使用户的样式设置优先于当前网页指定的相同属性。不过，那些使用 CSS1 的旧浏览器并不支持这一特性。 参考 《Learing PHP, MySQL, JavaScript, and CSS》(Robin Nixon著，侯荣涛译，中国电力出版社)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[响应式Web之文字排版]]></title>
      <url>%2F2017%2F03%2F09%2F%E5%93%8D%E5%BA%94%E5%BC%8FWeb%E4%B9%8B%E6%96%87%E5%AD%97%2F</url>
      <content type="text"><![CDATA[文字在页面上永远占据大量空间，所以在响应式设计中我们的目标是开发出具有高可读性、高适应性的文字排版效果。 良好的字体栈为 HTML 元素设置字体时，我们应使用 font-family 属性。在这个 CSS 声明中应包含多种字体，因为我们需要候补字体，以防前面的字体由于某些原因不能正确加载。 通常，候选字体应尽量与正选字体类似，这样在万一使用了候补字体的情况下页面的显示效果不会看起来完全不同。 自适应的字体大小通常在进行设计时，字体大小是以像素为单位进行确定的。但在 Web 页面中使用固定像素大小的字体有严重的问题，一是字体大小不能进行自适应，二是在书写媒体查询代码时会带来额外的工作量。 绝对与相对像素是一个绝对度量单位，绝对度量单位拥有一套定义使得其度量值所表示的大小在不同的场景下被认为总是相同的的。 另一方面，相对度量单位，在定义了一个起始点之后，与其他值之间是相对关系。 em和rem与像素（px）恰好相反，em 和 rem 均是典型的相对度量单位。 一个 em 大小等于一个元素当前的字体大小。如果父元素字体大小改变，那么采用 em 作为字体单位的子元素字体大小也会跟着改变。而这正是我们想要的结果。 下面这个公式可以将子元素字体大小像素单位转化为 em 单位： 子元素字体大小 px 值 / 父元素字体大小 px 值 = 子元素字体大小 em 值 rem 与 em 类似，只不过 em 是相对于最近父元素，rem 则是相对于根元素（&lt;html&gt;）而言。 一般来说，浏览器根元素的默认字体大小都是 16px。 推荐的字体大小配置方案为了使文字排版效果中字体大小具有响应性，建议采用模块化方案。 将整个页面根据文字特征划分为几个模块，如导航、标题和正文 每一个模块最外层元素，采用 rem 作为单位，相对于根元素（16px）设置字体大小 每个模块最外层元素的字体大小，则作为该模块内部各元素字体大小的基准，也就是说模块内部元素的字体大小均采用 em 作为单位 合理的行高/行长合理的行高、行长很重要，因为这也是直接影响用户阅读体验的因素。 下面是一个大神使用黄金分割比例处理字体大小、行高和行长之间关系，并据此制作的一个计算器。只要设定字体大小，行长，就能计算出最合适的文字排版方式。 Golden Ratio Typography Calculator]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[响应式Web之移动优先]]></title>
      <url>%2F2017%2F03%2F09%2F%E5%93%8D%E5%BA%94%E5%BC%8FWeb%E4%B9%8B%E7%A7%BB%E5%8A%A8%E4%BC%98%E5%85%88%2F</url>
      <content type="text"><![CDATA[移动优先越来越流行，但这是否意味着在响应式 Web 中，我们一定要遵循移动优先的原则呢？ 移动优先的优点内容优先移动优先允许你优先考虑内容并更早的关注你的网站最重要的部分。一个移动屏幕仅有给你最重要内容展示的空间，所以在早期设计阶段你需要决定哪些内容在你的网站中是最重要的。 渐渐增强使用移动优先的设计理念，可以使开发者进行渐进增强的编程。毕竟，在开发过程中，做加法比做减法容易。 移动优先的弊端显而易见地，使用移动优先进行设计，需要一定的时间和经验。 清理屏幕移动设备是一个专注的媒介，我们应该尽可能避免桌面网站中冗余复杂的信息。 由于大小、功率和带宽的限制，移动 Web 设计中 90% 是内容性设计，10% 是装饰性设计。 限制输入移动优先的另一个主要挑战是输入的限制。移动设备，屏幕小，显示的元素要更大，触摸屏操作使得手指缺乏精准度。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[响应式Web之断点]]></title>
      <url>%2F2017%2F03%2F09%2F%E5%93%8D%E5%BA%94%E5%BC%8FWeb%E4%B9%8B%E6%96%AD%E7%82%B9%2F</url>
      <content type="text"><![CDATA[断点（breakpoint）是响应式 Web 中的重要概念，我们可以使用媒体查询在断点处改变布局设计，使设计产生两个或更多的变体。 断点是媒体查询中反应视口宽度的数值点，网页设计在断点上将一分为二变成两种变体。端点之间的空间称为设计范围，在此范围内视口宽度对应一种设计变体。 在响应式 Web 中，断点的选择至关重要，因为它决定了我们什么时候适用媒体查询来改变样式。 在选择断点时，不应选择将断点设置为与某些常见设备宽度相同，而是应该确保常见设备宽度能够很简单地落入某一设计范围之内。可以在各类设备上进行测试并以此调整断点。 在进行响应式 Web 时，一个好习惯是，在布局被打乱的时候设置断点，当布局开始出现混乱，我们就应该添加一个断点将其修复。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用notepad++编写Git commit信息]]></title>
      <url>%2F2017%2F03%2F08%2F%E4%BD%BF%E7%94%A8notepad-%E7%BC%96%E5%86%99Git-commit%E4%BF%A1%E6%81%AF%2F</url>
      <content type="text"><![CDATA[Windows平台下 Git Bash commit 时默认使用的是 Vi 编辑器，这让很多没有用惯 Vi 的小伙伴很不习惯啊。但好在这个编辑器是可以定制的，所以我们可以将其改为 Notepad++。 前言其实一般来说，Git Bash 修改默认编辑器还是挺容易的，只需要运行以下命令即可： 1git config --global core.editor xxxxxxxx 上面命令中省略的部分即是编辑器的位置。 但是 Notepad++ 有点特殊（不要问我，我也不知道为什么），所以要将其作为 Git Bash 的默认编辑器还是要费一些功夫的，这也是为什么 Stack Overflow 上会有那么多相关提问，也是为什么我要单开一篇博文记录的原因。 如果不是改为 Notepad++，而是改为 Sublime 就没这么多问题了(●ˇ∀ˇ●)。 配置Google 了很多，也看了不少资料，尽管网上说的很复杂，但是经过思考，我将其浓缩为了一条命令，经过实践检验，完美可行。 打开 Git Bash，键入以下命令即可： 1git config --global core.editor "'c:\Program Files\Notepad++\notepad++.exe' -multiInst -notabbar -nosession -noPlugin '$*'" 上述命令中的 c:\Program Files\Notepad++\notepad++.exe 是 Notepad++ 路径。 参考 Using Notepad++ to Write Git Commit Messages]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Windows下配置Git中ssh-agent自动启动]]></title>
      <url>%2F2017%2F03%2F08%2FWindows%E4%B8%8B%E9%85%8D%E7%BD%AEGit%E4%B8%ADssh-agent%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8%2F</url>
      <content type="text"><![CDATA[默认情况下，如果我们要经常在 Git Bash 中运行命令以推送更新到远程仓库，则在每次推送时 SSH 客户端每次都会让我们输入密钥的密码，这很是让人不爽啊。解决方法就是让 ssh-agent 自动启动，常驻内存，直至我们注销当前用户或者关闭计算机。 创建.profile文件打开 Git Bash，键入 1pwd 确认当前是在 /c/Users/username 路径下 然后，输入 1touch ~/.profile 在路径下 /c/Users/username 路径下创建一个 .profile 文件 如果此路径下已经有这个文件，则无需新建。 设置.profile使用文本编辑器打开 .profile，将以下内容粘贴到其中保存。 123456789101112131415161718192021env=~/.ssh/agent.envagent_load_env () &#123; test -f "$env" &amp;&amp; . "$env" &gt;| /dev/null ; &#125;agent_start () &#123; (umask 077; ssh-agent &gt;| "$env") . "$env" &gt;| /dev/null ; &#125;agent_load_env# agent_run_state: 0=agent running w/ key; 1=agent w/o key; 2= agent not runningagent_run_state=$(ssh-add -l &gt;| /dev/null 2&gt;&amp;1; echo $?)if [ ! "$SSH_AUTH_SOCK" ] || [ $agent_run_state = 2 ]; then agent_start ssh-addelif [ "$SSH_AUTH_SOCK" ] &amp;&amp; [ $agent_run_state = 1 ]; then ssh-addfiunset env 完事儿之后重启 Git Bash 即可。 如此以来，以后即使 Git Bash 被关闭，ssh-agent 也将一直常驻内存，除非我们结束其进程、注销当前用户或者关闭计算机。 小问题默认情况下，SSH 的私钥是被保存在 ~/.ssh/ 路径下。如果你的私钥不是在这个路径，那么你需要告诉 SSH 客户端在哪儿找到它。 在 Git Bash 中运行以下命令即可 1ssh-add ~/path/to/my_key 参考 Auto-launching ssh-agent on Git for Windows]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[响应式Web之图像]]></title>
      <url>%2F2017%2F03%2F02%2F%E5%93%8D%E5%BA%94%E5%BC%8FWeb%E4%B9%8B%E5%9B%BE%E5%83%8F%2F</url>
      <content type="text"><![CDATA[响应式设计中，图像一直是个难点。一方面，我们想尽可能地使用美丽的图像来展示内容；另一方面，考虑到移动设备的网络速率与处理能力，我们需要单独准备图片，并让其与已有的图片针对不同大小的视口（屏幕分辨率、设备像素比等）做出恰当地响应。有的时候，基于美术设计，我们还会手动裁剪出各种不成比例的图片。 像素/分辨率/设备像素密度/设备像素比像素是什么？ 在计算机屏幕上，像素是一个彩色（或灰度）的物理点（屏幕可以显示的最小的点）。 注意： 严格来说，我们应该称其为 设备像素（Device Pixel）或物理像素（Physical Pixel），因为还有设备无关像素。 通常而言，屏幕像素的数量决定了其分辨率的大小。例如，1920x1080 分辨率的显示器是 1920像素宽乘以 1080像素高。 分辨率，屏幕水平方向上的像素数乘以屏幕竖直方向上的像素数。 所谓设备像素密度，跟我们常见的手机参数 PPI(Pixel Per Inch) 是一回事儿，其直译过来是“像素每英寸”，但考虑到它的含义，我们可以称呼它为像素密度（Pixel Density）。像素密度的计算方式，就是用屏幕对角线上的像素值除以屏幕对角线的长度（单位：英寸）。例如，iPhone5 的屏幕对角线的像素值为 1303，其对角线长度为 4 英寸，所以其像素密度为 1303/4=326PPI。 设备像素密度(PPI)，即设备每英寸所含有的像素数量。 截至到目前为止，我们所说的“像素”均指的是设备像素，也就物理设备自身实际所拥有的像素。 而通常我们在 CSS 中书写的单位 px，跟设备像素并没有多大关系。这种像素通常被称为“设备无关像素”，Web 开发中常用的 CSS 像素就是设备无关像素的一种。设备无关像素与设备像素之间的存在一种“设备像素比”的关系。 设备像素比（DPR）就是设备像素与设备无关像素（在Web中，通常就是 CSS 像素）的比值。 如果想知道当前设备的 DPR 大小，我们可以在浏览器控制台打印 window.devicePixelRatio。一般来说，window.devicePixelRatio 值默认都是 1，除非网页被强行进行缩放。 最简单的响应式图像对于已有工程中图像的处理，我们所能想到的最简单的响应式开发方案就是对其宽度作自适应，而考虑到图像自身宽度可能大于容器的情况下，我们应该使用 max-width 属性： 1234.img &#123; max-width: 100%; height: auto;&#125; 以上，可以称得上是最简单的响应图片处理方案了。 srcset属性详解&lt;img&gt; 标签具有名为 srcset 的属性，支持针对不同设备像素比/视口宽度设置不同的图片源。 响应设备像素比1&lt;img src="small.jpg" alt="image" srcset="large.jpg 2x, small.jpg 1x"&gt; 上面代码中 2x 和 1x 中的后缀 x 表示设备像素比，所以 2x 的含义即是设备像素比大小为 2，1x 同理。 如果浏览器支持 srcset 属性，那么它就会遵循 srcset 的设定从而以设备像素比为准则来选择如何加载图片。例如，对于上述代码，在设备像素比为 2 的情况下，浏览器会加载图像 large.jpg。 注意，即使设置了 srcset 属性，我们还应该设置 src 属性，以保证代码在不支持 srcset 属性的浏览器上能够做到优雅降级。 响应视口宽度视口宽度与设备像素比有很大不同，设备像素比描述的是精确值，而视口宽度描述的则是边界值，即视口宽度在某个宽度范围内适用某一张图片。 所以这里有个问题，针对视口宽度的响应，srcset 中设定的值表示的是最小宽度还是最大宽度？？？ 考虑如下代码： 12345&lt;img src="small.jpg" alt="image" srcset="medium.jpg 600w, large.jpg 800w"&gt;&lt;!-- 或者 --&gt;&lt;img src="large.jpg" lat="image" srcset="medium.jpg 800w, small.jpg 600w"&gt; 同响应设备像素比类似，上述代码中 800w 和 600w 的后缀 w 表示视口宽度。 上述代码，前者秉承移动优先的理念，默认加载 small.jpg，视口宽度大于 600px 时加载 medium.jpg，大于 800px 时则加载 large.jpg。相反地，后者遵循的是桌面优先理念，默认加载 large.jpg，视口宽度小于 800px 时加载 medium.jpg，小于 600px 时则加载 small.jpg。 就实际情况来看，大部分浏览器遵循的是移动优先，也就是说，只有视口宽度超过某一设定值时，才加载更大的图片。 坑实际运行时，浏览器永远对页面的渲染布局拥有最高指挥控制权，所以有时 srcset 对视口宽度的响应实际表现跟理论有出入： 如果浏览器支持 srcset 属性，那么 src 属性中的图片永远不会加载 当浏览器已经加载了某一张图片之后，再对浏览器窗口进行缩放，即使此时视口宽度匹配了 srcset 语法规则中的某条设定，浏览器也不会再加载图片了 Chrome 会充分利用缓存，如果缓存中有上次访问留下的高清图片，那么即使此时是从窄屏进行访问，也回加载高清图片 神奇的sizes语法除了 srcset 属性，&lt;img&gt; 标签还有一个更神奇的 sizes 属性，它的语法如下： 1size=&quot;[meida query] [length], [media query] [length] ... [media query] [lenghth]&quot; sizes 属性值由一系列由逗号隔开的描述图片宽度的特征表达式组成，每一组包含两部分： [media query] 表示匹配的查询条件 [length] 表示该查询条件下图片所占用的宽度 其中，最后一个特征表达式可以只描述图片大小，表示在默认查询条件下的图片占用宽度。 下面是示例： 1&lt;img src="" alt="" sizes="(max-width: 640px) 100vw, (max-width: 960px) 50vw, calc(100vw / 3)" 上述代码意味着： 视口宽度小于 640px 时，图片宽度为视口宽度的 100% 视口宽度大于 640px 且小于 960px 时，图片宽度为视口宽度的 50% 视口宽度大于 960px 时，图片宽度为视口宽度的 1/3 sizes属性结合srcset属性我们可以将 &lt;img&gt; 标签的 srcset 属性和 sizes 属性结合起来使用。 1&lt;img src="" alt="" sizes="(max-width: 640px) 100vw, (max-width: 960px) 50vw, calc(100vw / 3)" srcset="large.jpg 1024w, medium.jpg 640w, small.jpg 320w"&gt; 这里有一点需要注意，当 sizes 属性存在时，srcset 中每一张图片名称后面跟随的不再是设备条件，而是图片的宽度，且仍以 w 为后缀表示像素宽度。 对于上述代码，浏览器首先会根据 sizes 语法规则设定的媒体查询条件判断出图片应该有的宽度，然后从 srcset 设定的图片源中加载最符合的。 元素让我们忘了尽管传统的 &lt;img&gt; 得益于 srcset、sizes 属性支持可以作为解决响应式图像的方案，但仍显得力不从心，有时候浏览器奇怪的表现也让我们无所奈何。 HTML5 新引入的 &lt;picture&gt; 元素及 &lt;source&gt; 元素让我们看到了响应式图像解决方案的曙光。 &lt;source&gt; 元素支持媒体查询，也支持 srcset 属性，srcset 属性的使用方法与 &lt;img&gt; 标签中一致。 123456&lt;picture&gt; &lt;source media="(max-width: 640px)" srcset="small.jpg 320w" /&gt; &lt;source media="(max-width: 960px)" srcset="medium.jpg 640w" /&gt; &lt;source srcset="large.jpg 1024w" /&gt; &lt;img src="small.jpg" alt=""&gt;&lt;/picture&gt; 注意： 只有 &lt;img&gt; 存在，&lt;picture&gt; 元素才能显现图片。毕竟，&lt;source&gt; 元素只是为 &lt;picture&gt; 提供图片数据源，并没有可视化的能力。 依据 &lt;source&gt; 的媒体查询信息选择来源是非常精确的，与样式表中的媒体查询一致，不会像 &lt;img&gt; 的 srcset 和 sizes 属性那样由浏览器自信裁决。 下面展示一个颇为复杂的示例： 123456&lt;picture&gt; &lt;source media="(max-width: 640px)" srcset="small2.jpg 2x, small.jpg 1x" sizes="calc(100vw / 3)" /&gt; &lt;source media="(max-width: 960px)" srcset="medium2.jpg 2x, medium.jpg 1x" /&gt; &lt;source srcset="large2.jpg 2x, large.jpg 1x" /&gt; &lt;img src="small.jpg" alt="" &gt;&lt;/picture&gt; 对于上述代码，浏览器的解析方案如下： 执行 &lt;source&gt; 中设定的媒体查询，选择一个图片源 一旦浏览器选择了某个 &lt;source&gt; 作为图片源之后，该 &lt;source&gt; 的 sizes 属性立即生效，作为它所在 &lt;picture&gt; 的宽度 &lt;picture&gt; 宽度确定之后，浏览器会根据当前设备情况、图片尺寸情况，从 srcset 中选择适合的图片 元素的弊端拥有 srcset 和 sizes 属性的 &lt;img&gt; 元素实际上是将图片的选择权全权交给了浏览器，而 &lt;picture&gt; 元素选择 &lt;source&gt; 则是要依赖人工设计的媒体查询的执行结果，根据设备被动选择。 ## 拯救世界的Client HintsHTTP Client Hints 是一种比较新的技术，利用这项技术，HTTP 客户端（通常可以认为是浏览器）能够主动将一些特性告诉服务端，以便服务端更有针对性地输出内容。 其实之前浏览器已经将很多自身特性放在 HTTP 请求中，例如下面这些头部字段： User-Agent：提供浏览器类型及版本、操作系统及版本、浏览器内核等信息； Accept：表明浏览器支持哪些 MIME type（例如 Chrome 通过 Accept 表明自己支持 image/webp 图片格式）； Accept-Encoding：表明本浏览器支持哪些内容编码方式（例如：gzip、deflate、sdch）； Accept-Language：表明本浏览器支持那些语言； 通过以上这些头部字段，我们已经可以针对不同客户端输出不同内容。但是有一些浏览器特性，我们无法直接获取，如屏幕分辨率、设备像素比（devicePixelRatio）、用户带宽等。而在移动 Web 中，为了尽可能节省用户流量，需要输出尺寸最合适的图片资源。 为了解决这种问题，HTPP Client Hints 技术为 HTTP 请求头规定了几个新的字段： DPR：设备像素比 Viewport-Width：视口宽度 Width：图片的实际宽度 Downlink：客户端最大下载速率 Save-data：布尔值，表示是否应采取额外措施来减少有效负载 为了使用这项最新的功能，以获得更好的响应式图像体验，我们可以通过配置 HTTP 请求头和 meta 标签两种方式开启： Accept-CH: DPR, Width, Viewport-Width &lt;meta http-equiv=&quot;Accept-CH&quot; content=&quot;DPR, Width, Viewport-Width&quot;&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[强制开启firefox多进程]]></title>
      <url>%2F2017%2F03%2F01%2F%E5%BC%BA%E5%88%B6%E5%BC%80%E5%90%AFfirefox%E5%A4%9A%E8%BF%9B%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[Firefox 现在已经支持多进程特性，但这项新特性截至目前为止都并不是很成熟，以至于有的 Firefox 版本中并没有默认开启。如果想体验 Firefox 多进程新特性，我们完全可以自行强制开启。 有些 Firefox 虽然出厂默认启用了多进程特性，但会因为 Accessibility Tools 而在重启后自动关闭多进程特性，这时我们也需要手动强制开启多进程特性。 强制开启 Firefox 多进程特性的步骤如下: 浏览器地址栏键入 about:config，进入高级设置 找到 browser.tabs.remote.autostart preference，将其值修改为 true。如果其值已经为 true，则无需改变。 在列表空白区域，右键新建一个 Boolean preference，命名为 browser.tabs.remote.force-enable，并将其值设定为 true 如果是因为 Accessibility Tools 导致 Firefox 自动关闭了出厂的多进程特性，我们还需将 accessibility.force_disabled 的值修改为 1（默认值应该是0） 成功完成上述操作，重启 Firefox 即可享受多进程。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[响应式Web之视口(viewport)]]></title>
      <url>%2F2017%2F02%2F28%2F%E5%93%8D%E5%BA%94%E5%BC%8FWeb%E4%B9%8B%E8%A7%86%E5%8F%A3-viewport%2F</url>
      <content type="text"><![CDATA[视口(viewport) 这一特性在非响应式 Web 设计编码中通常是用不到的，然而它却是我们设计响应式 Web 的关键。 众所周知的媒体查询就是基于视口宽度的。 视口是什么不同领域，视口 的含义自然有所不同。在前端领域中，由于主要是针对浏览器编程，视口自然是指计算机或设备屏幕上用户浏览网页的那块区域。 对于桌面平台的设备而言，视口指的是整个当前浏览器窗口，去掉菜单栏、工具栏、滚动条及浏览器自身的其他部件，真正用来显示网页的那块区域。 对于移动平台的手持设备而言，视口指的就是设备的屏幕显示区域。 那viewport呢对于没有真正接触过响应式 Web 的开发者而言，viewprot 一次可能稍显陌生。因为，在传统 Web 编程中，即非响应式 Web 中，我们通常不会用到 viewprot。 事实上，viewport 同 charset 一样，仅仅是 &lt;meta&gt; 元素的一个元数据属性。 charset 主要用于设置页面字符集，而 viewport 则是用于配置浏览器如何在视口内渲染整个页面。 12&lt;meta charset="utf-8"&gt;&lt;meta name="viewport" content=""&gt; 值得注意的是，一般一个 &lt;meta&gt; 元素只接受一个元数据属性值，所以我们不能简单地将 charset 和 viewport 这种元数据属性一起放至在一个 &lt;meta&gt; 元素里。 默认情况下，手机浏览器在渲染一个没有 viewport 属性的网页时，会先像桌面浏览器那样渲染页面，然后按照比例缩小它来以适配手机视口。如果页面有媒体查询是基于视口宽度的，那么它们不会生效，因为浏览器是按照桌面平台显示器尺寸来计算视口宽度的。 响应式Web开发宽度当为&lt;meta&gt; 元素提供的是 viewport 元数据属性时，我们可以在 content 属性中设置 width 参数。 width 参数用于告诉浏览器如何以多大的宽度来渲染页面。 响应式 Web 中，大部分情况下我们都希望以系统分辨率的宽度来渲染页面，以尽可能地避免缩放，以及正确地响应设备。问题是不同设备的系统分辨率是不一致的，即使在同一设备上，横竖两种手持设备方向也会让渲染方式不同。 解决这个问题的方法是，将 width 的值设置为 device-width， 1&lt;meata name="viewport" content="width=device-width"&gt; 这样一来，浏览器就会自动以设备自身的实际宽度来渲染页面。 如果没有做上述指定，设备将使用它自己默认的视口设置来渲染页面。 初始缩放比当为&lt;meta&gt; 元素提供的是 viewport 元数据属性时，我们可以在 content 属性中设置 initial-scale 参数。 参数 initial-scale 会告诉浏览器在屏幕上首次加载网页时如何缩放它。 响应式 Web 编程中，通常我们会设置 1&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; 这意味着页面将按照 width 参数设定的宽度值来渲染页面，不放大也不缩小实际页面。 如果用的是大于或小于 1 的数值，则页面将缩放至对应的比例。直接后果就是，我们在视口内只能看见页面的一部分或者页面还没有占满整个屏幕。 viewport支持的其他content特性除了最常用的 width 和 initial-scale 参数，viewport 还支持其它许多可配置的参数。但这些参数，一般来说，在响应式 Web 开发中，开发人员应该避免显式地使用。 高度height 可以用于配置浏览器渲染页面的高度，但响应式 Web 中，我们应该极力避免手动配置这个值。 用户可缩放有时，在移动端浏览网页时，我们会发现某些网页是可以进行手动缩放的。这得益于 viewport 的另一个可配置参数 user-scalable，它提供了用户放大或缩小内容的能力。 user-scalable 参数默认值为 yes，即允许用户对页面进行缩放。 对于大多数网站，我们应该避免修改这个参数的默认值，以让用户在需要时可以自行缩放页面。 最大缩放比maxium-scale 用于设置页面最大缩放比，响应式 Web 中，我们应避免配置这个参数。 最小缩放比minium-scale 用于设置页面最小缩放比，响应式 Web 中，我们应该避免配置这个参数。 小结响应式 Web 开发，我们应该为页面配置一个 name 值为 viewport 的 &lt;meta&gt; 标签，一般来说，它应该被配置成如下这个样子： 1&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; 参考 Configure the viewport Responsive Meat Tag]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript性能优化：（七）Ajax]]></title>
      <url>%2F2016%2F12%2F23%2FJavaScript%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%EF%BC%88%E4%B8%83%EF%BC%89Ajax%2F</url>
      <content type="text"><![CDATA[AJAX stands for Asynchronous JavaScript and XML. In a nutshell, it is the use of the XMLHttpRequest object to communicate with server-side scripts. It can send as well as receive information in a variety of formats, including JSON, XML, HTML, and even text files. AJAX’s most appealing characteristic, however, is its “asynchronous” nature, which means it can do all of this without having to refresh the page. This lets you update portions of a page based upon user events. 请求数据XMLHttpRequest常见的使用 XMLHttpRequest 技术请求数据的方式如下： 1234567891011let req = new XMLHttpRequest();req.onload = function() &#123;&#125;;req.onerror = function() &#123;&#125;;req.open('GET', url, true);req.send(); 尽管 XHR 提供了高级的控制，但还是有一些缺点：无法使用 XHR 技术从不同源获取数据。 动态脚本注入这种技术克服了 XHR 的最大限制：能跨域请求数据。本质上，这种技术是个 Hack。 123let scriptElement = document.createElement('script');scriptElement = 'http://';document.head.appendChild(scriptElement); 但是与 XHR 相比，动态脚本注入提供的控制是有限的： 不能设置请求的头部信息 参数传递只能使用 GET 方式，而不是 POST 方式 不能设置请求的超时处理或重试 失败了也不一定知道 必须等待所有数据都已返回，才可以访问它们 不能访问请求的头信息，也不能把整个响应消息作为字符串来处理 特别重要的一点是，响应消息作为脚本标签的源代码，它必须是可执行的 JavaScript 代码。我们不能使用纯 XML、纯 JSON 或其他任何格式的数据，无论哪种格式，都必须封装在一个回调函数中。 尽管限制很多，但是这项技术的速度却非常快。 使用这种技术时，必须注意我们所请求的 JavaScript 代码内容是否完全在自己控制之中。JavaScript 没有任何权限和访问控制的概念，使用动态脚本注入技术添加到页面中的任何代码都可以完全控制整个页面，既是是引自外部的代码也不例外。 Multipart XHRMXHR 允许客户端只用一个 HTTP 请求就可以从服务器端向客户端传送多个资源。它通过在服务器端将资源（CSS 文件、HTML 片段、JavaScript 代码或 base64 编码的图片）打包成一个由双方约定的字符串分割的长字符串送到客户端。然后使用 JavaScript 处理这个长字符串，并根据它的 mime-type 类型和传入的其他“头信息”解析出每个资源。 例如，客户端请求图片资源，服务器使用 base64 将图片编码为字符串然后传递给客户端，当客户端收到后可以使用如下 JavaScript 代码进行处理： 123456789101112function splitImages(imageString) &#123; // 假设服务器端编码的图片之间只用一个简单的 Unicode 编码的字符 1 连接 let imageData = imageString.split('\u0001'); let imageElement = document.createElement('img'); let imageNode = null; for (let i = 0, len = imageData.length; i &lt; len; i++) &#123; imageNode = imageElement.cloneNode(true); imageNode.src = `data:image/jpeg;base64,$&#123;imageData[i]&#125;`; document.body.appendChild(imageNode); &#125;&#125; 以上代码中函数将连接后的字符串按一定格式分解为几段。每一段用来创建一个图片元素，然后将图片元素插入到页面中。图片不是由 base64 字符串转换为二进制，而是使用 data:URL 的方式创建，并指定 mime-types 为 images/jpeg。 这种方式也可以扩展到其他资源类型。JavaScript 文件、CSS 文件、HTML 片段以及多种类型的图片都能合并成一次响应。任何数据类型都可以被 JavaScript 作为字符串发送。 123456789101112131415161718function handleImageData(data, mimeType) &#123; const img = document.createElement('img'); img.src = `data:$&#123;mimeType&#125;;base64$&#123;data&#125;`; return img;&#125;function handleCSS(data) &#123; const style = document.createElement('style'); const node = document.createTextNode(data); style.appendChild(node); document.head.appendChild(style);&#125;function handleJavaScript(data) &#123; // 不建议 eval(data);&#125; 由于 MXHR 响应消息的体积越来越大，因此我们有必要在每个资源收到时就立刻处理，而不是等到整个响应消息全部接收完成再进行处理。这可以通过监听 readyState === 3 的状态，使用定时器按一定时间间隔检查响应来实现。 MXHR 技术有个最大的缺点，以这种方式获得的资源不能被浏览器缓存。 发送数据XMLHttpRequestXHR 技术同样可用于把数据传回服务器· Beacons(信标)这项技术非常类似动态脚本注入。使用 JavaScript 创建一个新的 Image 对象，并把 src 属性设置为服务器上脚本的 URL。该 URL 包含了我们要通过 GET 传回的键值对数据。注意，我们并不会创建 img 元素或把它插入 DOM 树中。 1234567const url = '/status_tracker.php';const params = [ 'step=2', 'time=134152526190'];(new Image()).src = `$&#123;url&#125;?$&#123;params.join('&amp;')&#125;`; 服务器会接收数据并保存下来，它无须向客户端发送任何回馈信息，因此没有图片会实际显示出来。这是给服务器回传信息最有效的方式。它的性能开销开销很小，而且服务器的错误完全不会影响到客户端。 图片信标很简单，但也意味着它能做的事情是有限的。我们无法发送 POST 数据，而使用 GET 方法 URL 的长度有最大上限，所以我们可以发送的数据长度被限制得相当小。 我们可以接收服务器返回的数据，但仅限于非常少得几种方式： 监听 Image 对象的 load 事件 检查返回图片的宽高，利用这些数字通知服务器的状态 信标是向服务器回传数据最快且最有效的方式，服务器根本不需要发送任何响应正文，因此我们也无需担心客户端下载数据。唯一的缺点就是能接收到的响应内心是有限的。 数据格式常见的用于数据传输的数据格式有 XML、XPath、JSON、JSONP、HTML 和自定义格式等，通常来说数据格式越轻量级越好，JSON 和字符串分隔的自定义格式是最好的。如果数据集很大并对解析时间有要求，那么将从以下两种格式中做出选择： JSONP数据：使用动态脚本注入获取。它把数据当作可执行 JavaScript 而不是字符串，解析速度极快。能够跨域使用，但涉及敏感数据时不应使用它 字符分隔的自定义数据格式：使用 XHR 或者动态脚本注入获取，使用 split() 解析。这项技术解析大数据集比 JSONP 略快，而且通常文件尺寸更小 缓存数据最快的 Ajax 请求就是没有请求。有两种主要方法可避免发送不必要的请求： 服务端，设置 HTTP 头信息以确保响应数据被浏览器缓存 客户端，把获取到的信息存储到本地，从而避免再次请求 第一种技术使用最简单而且好维护，而第二种则给予开发人员最大的控制权。 设置 HTTP 头信息如果希望 Ajax 响应能够被浏览器缓存，那么必须使用 GET 方式发出请求。但这还不够，还必须在响应中发送正确的 HTTP 头信息。Expires 头信息会告诉浏览器应该缓存响应多久。它的值是一个日期，过期之后，对该 URL 的任何请求都不再从缓存中获取，而是会重新访问服务器。一个典型的 Expires 头信息如下： Expires: Mon, 28 Jul 2014 23:30:00 GMT 这种特殊的 Expires 头信息告诉浏览器缓存此响应到 2014 年 7 月。 本地数据存储直接把从服务器接收到的数据储存起来。我们可以把响应文本保存到一个对象中，以 URL 为键值作为索引。 总的来说，设置一个 Expires 头信息是更好的方案。它实现起来比较容易，而且其缓存内容能够跨页面和跨会话。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Web Worker]]></title>
      <url>%2F2016%2F12%2F22%2FWebWorker%2F</url>
      <content type="text"><![CDATA[通常一个浏览器会至少存在三个线程：JavaScript 引擎线程，GUI渲染线程以及用于控制交互的浏览器时间触发线程。其中，JavaScript 引擎线程是处理 JavaScript 代码的单线程。 多少年以来，我们都没有办法在浏览器的 UI 线程之外运行 JavaScript 代码。JavaScript 和 UI 共享同一进程的部分原因是它们之间互相访问频繁，但这些任务一旦失控会导致糟糕的用户体验。 Web Workers API 改变了这种状况，它引入了一个接口，能使代码运行且不占用浏览器 UI 线程的时间。它允许加速一个运行特定密集代码的新进程，使得原来的线程不会锁定浏览器，其实就是在后台运行。 本质上来说，由 Web Worker 创建的线程实际是在操作系统中开启了一个全新的线程，意味着该线程与原来的线程是完全不同的。 Web Worker 运行环境Web Worker 没有绑定 UI 线程，这意味着它们不能访问浏览器的许多资源。它不能访问 DOM 中的页面元素，也不能访问页面上所有的全局变量。 但是每个 Web Worker 都有自己的全局运行环境，其功能只是 JavaScript 特性的一个子集。Web Worker 运行环境由如下部分组成： 一个 navigator 对象：只包括四个属性：appName、appVersion、user Agent 和 platform 一个 location 对象（与 window.location 对象相同，不过所有属性都是只读的） 所有的 ECMAScript 对象，诸如：Object、Array、Date 等 XMLHttpRequest 构造器 setTimeout() 和 setInterval() 方法 一个 self 对象，指向全局 worker 对象 一个 importScripts() 方法，用来加载 Worker 所用到的外部 JavaScript 文件 self.close() 方法，worker线程自身调用，停止 worker 代码运行并终止它的线程 terminate() 方法，在主页面中作为 Web Worker 对象的方法调用，使 worker 线程立即被终止，无论它当时处于何种状态，该方法不会给 workder 留下任何完成其他操作的机会 创建一个 Web Worker 线程由于 Web Worker 有着不同的全局环境，因此我们无法从 JavaScript 代码中创建它。为了在现有页面中使用 Web Worker，我们首先需要创建一个完全独立的 JavaScript 文件，并在其中放置需要在 Worker 中运行的代码。然后，我们将这个 JavaScript 文件的 URL 作为参数传给 Worker 构造器即可： 1let workerThread = new Worker('filename.js'); 上述代码一经执行，就会为这个 JavaScript 文件创建一个新的线程和一个新的 Worker 运行环境。该文件会被异步下载，直到文件下载完毕才会启动此 Worker 线程并执行其脚本。 与 Web worker 通信wordker 与页面通过事件接口进行通信。 事件监听器此外，Web Worker 规范为 worker 对象定义了两种 EventListener 类型的属性： onmessage：在 worker 线程传输消息时触发，事件对象的 data 属性中存储着消息内容 onerror：在 worker 线程出错时触发 我们可以通过以下两种方式为 worker 对象绑定时间处理器： worker.onmessage = function(event) {}; worker.addEventListener(&#39;message&#39;, function(event) {}, false); postMessage()方法postMessage() 方法用于向 worker 的内部作用域内传递消息。该方法接收一个单独的参数，即要传递给 worker 的数据。数据可以是任何值或者是经过结构化拷贝算法处理过的 JavaScript 对象，换句话说，可以包含循环引用。 1void postMessage( Object aMessage [, sequence&lt;Transferable&gt; transferList]); aMessage：传输给 worker 的对象；它将包含于传递给 onmessage 处理函数的事件对象中的 data 字段内。你可以传递任意值或是经过结构化拷贝算法处理过的 JavaScript 对象，即可以包含循环引用。 transferList：一个可选的对象数组，用于转让它们的所有权。如果一个对象的所有权被转让，那么它在原来的上下文内将不可使用，而只能在转让到的 worker 内可用。由规范可知， 只有 MessagePort 与 ArrayBuffers 对象能被转让。 通过转让所有权(可转让对象)来传递数据使用 postMessage() 方法的第二个参数可以将特定类型的对象(可转让对象) 传递给一个 worker/从 worker 传回 。可转让对象从一个上下文转移到另一个上下文而不会经过任何拷贝操作。这意味着当传递大数据时会获得极大的性能提升。 与传统的按引用传递不同，一旦对象转让，那么它在原来上下文的那个版本将不复存在。该对象的所有权被转让到新的上下文内。例如，当你将一个 ArrayBuffer 对象从主应用转让到 Worker 中，原始的 ArrayBuffer 被清除并且无法使用。它包含的内容会(完整无差的)传递给 Worker 上下文。 1234567// Create a 32MB "file" and fill it.var uInt8Array = new Uint8Array(1024*1024*32); // 32MBfor (var i = 0; i &lt; uInt8Array .length; ++i) &#123; uInt8Array[i] = i;&#125;worker.postMessage(uInt8Array.buffer, [uInt8Array.buffer]); 注意： 在主页面与 worker 之间传递的数据是通过拷贝，而不是共享来完成的。传递给 worker 的对象需要经过序列化，接下来在另一端还需要反序列化。页面与 worker 不会共享同一个实例，最终的结果就是在每次通信结束时生成了数据的一个副本。大部分浏览器使用结构化拷贝来实现该特性。 加载外部脚本worker 可以通过 importScripts() 方法加载外部 JavaScript 文件，该方法接受一个或多个 JavaScript 文件 URL 作为参数。importScripts() 的调用过程是阻塞式的，直到所有文件加载并执行完毕之后，脚本才会继续运行。 由 importScripts() 导入的每个脚本中的全局对象都能够被 worker 使用。如果脚本无法加载，将抛出 NETWORK_ERROR 异常，接下来的代码也无法执行。而之前执行的代码(包括使用 window.setTimeout() 延迟执行的代码)却依然能够使用。importScripts() 之后的函数声明依然能够使用，因为它们始终会在其他代码之前运行。 注意： 脚本的下载顺序不固定，但执行时会按照你将文件名传入到 importScripts() 中的顺序。这是同步完成的；直到所有脚本都下载并运行完毕， importScripts() 才会返回。 示例下面，我们来写一段简短的代码，演示主页面与 worker 线程 通信的过程。首先是主页面的脚本代码： 12345678// 创建 worker 线程let workerThread = new Worker('code.js');// 开始监听从该线程发出的消息workerThread.onmessage = function (event) &#123; alert(event.data);&#125;;// 向 worker 线程传递消息workerThread.postMessage('lfkid'); 然后是 code.js 文件中的代码： 123456// 在主页面创建 work 线程之后// URL 参数指定的脚本文件self.onmessage = function (event) &#123; self.postMessage(`Hi $&#123;event.data&#125;, I am a Web Worker`); self.close();&#125;; ！！！注意： 无论是在主页面还是 worker 线程内部，我们始终都应该先为 worker 对象的 onmessage（或者 onerror）事件绑定函数处理器，然后再调用 postMessage() 方法传递数据。 图解下面这张图片展示了主页面与 worker 线程通信间的关系： 参考 Worker 使用Web Workers]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[三种方式理解Promise]]></title>
      <url>%2F2016%2F12%2F20%2F%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%90%86%E8%A7%A3Promise%2F</url>
      <content type="text"><![CDATA[Promise 的出现为一直以来饱受“回调地狱”噩梦困扰的异步编程带来了希望，但一开始接触这个概念，理解起来难免有些困难。本文讲述了三种帮助理解 Promise 的方式。 引子下面是一个调用基于 Promise 的函数 asyncFunc() 的例子： 12345678910111213function asyncFunc() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve('DONE'), 100); &#125;);&#125;asyncFunc().then(x =&gt; console.log(`Result: $&#123;x&#125;`));console.log('&gt;_&lt;');// Output:// &gt;_&lt;// Result: DONE 所以呢，什么是 Promise？ 概念上，调用 asyncFunc() 是一个阻塞式函数调用 Promise 既是一个值的容器也是一个事件触发器 概念上：调用基于 Promise 的函数是阻塞的12345678910111213141516function asyncFunc() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve('DONE'), 100); &#125;);&#125;async function main() &#123; const x = await asyncFunc(); // (A) console.log(`Result: $&#123;x&#125;`); // (B) // Same as: // asyncFunc().then(x =&gt; console.log(`Result: $&#123;x&#125;`));&#125;main(); main() 是一个异步函数。其函数体很好地从概念上表明发生了什么——也是我们通常如何看待异步运算： 行(A)：等待，直到 asyncFunc() 执行完毕 行(B)：打印 x 的结果值到控制台日志 在 ES6 和 Generator 之前，你不能暂停并重新恢复代码执行。这就是为什么，对于 Promise，要将恢复代码执行后所发生的一切都置于回调函数中。调用回调与恢复代码是相同的。 Promise 是异步传递的值的容器如果一个函数返回一个 Promise，那么这个 Promise 就像一个空的容器，函数一旦运算完毕，最后就会向其中填充它的结果。你可以通过数组模拟此过程的简单版本： 123456789101112function asyncFunc() &#123; const blank = []; setTimeout(() =&gt; blank.push('DONE'), 100); return blank;&#125;const blank = asyncFunc();// 等待，直到值被填充setTimeout(() =&gt; &#123; const x = blank[0]; // (A) console.log(`Result: $&#123;x&#125;`);&#125;, 200); 使用 Promise，你不必通过 [0]（像在行(A)中那样）访问最终值，你可以使用方法 then() 和回调函数。 Promise 是一个事件触发器另一种看待 Promise 的方式是将其作为一个触发事件的对象。 1234567891011function asyncFunc() &#123; const eventEmitter = &#123; success: [] &#125;; setTimeout(() =&gt; &#123; // (A) for (const handler of eventEmitter.success) &#123; handler('DONE'); &#125; &#125;, 100); return eventEmitter;&#125;asyncFunc().success.push(x =&gt; console.log(`Result: $&#123;x&#125;`)); // (B) 注册事件监听器（行(B)）可以在调用 asyncFunc() 之后完成，因为在这段代码完成后，交给 setTimeout()（行(A)）的回调是异步执行的。 典型的事件触发器专门用于传递多个事件，从你注册时开始。 相比之下，Promise 专门提供一个确定值，并提供内置保护以防止注册太晚：Promise 的结果被缓存并传递到在 Promise 状态确定后注册的事件侦听器。 参考 Three ways of understanding Promises]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript性能优化：（六）加快页面响应速度]]></title>
      <url>%2F2016%2F12%2F19%2FJavaScript%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%EF%BC%88%E5%85%AD%EF%BC%89%E5%8A%A0%E5%BF%AB%E9%A1%B5%E9%9D%A2%E5%93%8D%E5%BA%94%E9%80%9F%E5%BA%A6%2F</url>
      <content type="text"><![CDATA[大多数现代浏览器都是让一个线程共用于执行 JavaScript 代码和更新页面，也就是说，每一时刻浏览器只能执行其中一种操作，这意味着当 JavaScript 代码正在执行时页面就会无法响应，反之亦然。 浏览器 UI 线程用于执行 JavaScript 和更新页面的进程通常被称为“浏览器 UI 线程”（尽管对所有浏览器来说，称为“线程”可能不准确）。、 UI线程的工作基于一个简单的队列系统，任务会被保存到队列中直到进程空闲。一旦空闲，队列中的下一个任务就被重新提取出来并运行。这些任务要么是待执行的 JavaScript 代码，要么是待执行的 UI 更新，包括重绘和回流。 当所有 UI 线程任务都执行完毕，进程进入空闲状态，并等待更多任务加入队列。空闲状态是理想的，因为用户所有的交互都会立刻触发 UI 更新。如果用户试图在任务运行期间于页面交互，不仅没有即时的 UI 更新，甚至可能新的 UI 更新任务都不会创建并加入队列。事实上，大多数浏览器在 JavaScript 运行时都会停止把新任务加入到 UI 线程的队列中，也就是说 JavaScript 任务必须尽快结束，以避免对用途体验造成不良影响。 浏览器限制一般来说，浏览器会限制 JavaScript 任务的运行时间。 有两种方法可以度量脚本运行了多长时间。第一种是记录脚本开始以来执行的语句的数量。这种方法意味着脚本在不同的机器上可能会有不同的运行时间，因为可用内存和 CPU 速度会影响单个语句的执行时间。第二种方法是记录脚本执行的总时长，在指定时间内可运行的脚本数量也因用户的机器性能而有所差异，但是到达执行时间后，脚本会停止运行。毫无疑问的是，不同浏览器检测长时间运行脚本的方法会略有不同。 多久才算“久” Nielsen 指出如果界面在 100 毫秒内响应用户输入，用户会任务自己在“直接操纵界面中的对象”。超过 100 毫秒意味着用户会感到自己与界面失去联系。由于 JavaScript 运行时无法更新 UJI，所以如果 JavaScript 运行时间超过 100 毫秒，用户就会感觉失去了对界面的控制。 最佳实践是限制所有的 JavaScript 任务在 100 毫秒或更短的时间内完成，以避免类似情况出现。 使用定时器理解定时器定时器并不是 ECMAScript 提供的 API，而是由宿主环境浏览器提供的。有一点需要注意的是，当定时器启动之后，只是将其绑定的任务加入到当前线程队列中进行排队，并不会马上执行它。 使用定时器处理数组典型的数组循环模式如下： 123for (let i = 0, len = arr.length; i &lt; len; i++) &#123; process(arr[i]);&#125; 这类循环运行时间过长的原因主要是 process() 的复杂度或 arr 的大小，或两者兼有。 对于这种情况，假如数组无需严格按照顺序处理，且整个处理过程也不要求同步进行，那么我们可以使用定时器来分解此任务。 一种使用定时器帮助处理大数组的方式如下： 1234567891011let todo = arr.concat(); // 克隆原数组setTimeout(function handler(callback) &#123; process(todo.shift()); if (todo.length) &#123; setTimeout(handler, 25); &#125; else &#123; callback(); &#125;&#125;, 25); 每个定时器的真实延时时间在很大程度上取决于具体情况。普遍来讲，最好使用 25 毫秒，因为再小的延时，对大多数 UI 更新来说普遍不够用。——《高性能JavaScript》 使用定时分解任务根据前面使用定时器帮助处理大型数组的经验，对于繁杂的众多一般性任务，我们也可以使用定时器将它们分解为原子任务再处理。 例如，如果要在同一时间段内执行大量函数，我们可以将这些函数放到数组中，然后遍历数组，每隔一定间隔执行下一个函数，这样就可以减轻 JavaScript 线程的压力。 123456789101112131415161718function multistep(steps, args, callback) &#123; // steps：待执行函数组成的数组 // args：Array 类型的实例包裹的传递给待执行函数的参数， // callback：处理结束式执行的回调函数 let tasks = steps.concat(); setTimeout(function handler() &#123; let tasks = tasks.shift(); task.apply(null, args || []); if (tasks.length) &#123; setTimeout(handler, 25); &#125; else &#123; callback(); &#125; &#125;);&#125; 定时器性能同一时间只有一个定时器存在，只有当这个定时器结束时才创建一个新的，通过这种方法使用定时器不会导致性能问题。当多个重发的定时器同时创建往往会出现性能问题。因为只有一个 UI 线程，而所有的定时器都在抢占运行时间。 间隔在 1 秒或 1 秒以上的低频率重复定时器几乎不会影响 Web 应用的响应速度。 当多个重复定时器使用较高的频率（100 ~ 200ms）时，Web 应用就会明显变慢，响应也不及时。 总结：在 Web 应用中限制高频率重复定时器的数量。建议是创建一个独立的重复定时器，每次执行多个操作。 Web Worker本部分参见 Web Worker 参考 《高性能JavaSript》，[美]Nicbolas C.Zakas 著，丁琛 译，电子工业出版社 2015]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript性能优化：（八）编程实践]]></title>
      <url>%2F2016%2F12%2F18%2FJavaScript%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%EF%BC%88%E5%85%AB%EF%BC%89%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%2F</url>
      <content type="text"><![CDATA[每个语言都有它的“痛点”，并且随着时间的推移，它存在的低效模式也不断发展。在精华与糟粕并存的世界中，最佳实践的地位不言而喻。 避免双重求值 避免使用 eval() 和 Function() 对于 setTimeout() 和 setInterval()，建议传入函数而不是字符串作为第一个参数 使用字面量方式创建对象和数组使用对象/数组字面量是创建对象/数组的最快方式，运行速度更快，而且代码量也少。 避免重复工作如同字面意思，在实际编写代码时，我们应该尽可能地避免重复做已经做过的工作。 下面是用于浏览器探测的函数： 1234567function addHandler(target, eventType, handler) &#123; if (target.addEventListener) &#123; target.addEventListener(eventType, handler, false); &#125; else &#123; target.attachEvent('on' + eventType, handler); &#125;&#125; 这个函数隐藏的性能问题在于每次函数调用时都做了重复工作，因为每次调用时其都会经过检查指定方法是否存在。理想状态下，在第一次调用之后就已经知道了当前浏览器所使用的方法，那么后续函数调用就不需要再次检查方法是否存在了。但是，这个函数没能做到这一点，所以每次调用它都是在重复相同的工作，这是极大的资源浪费。 下面以这个函数为例，看一下避免重复工作的几种解决方案。 延迟加载延迟加载意味着信息被使用前不会做任何操作。以之前的浏览器探测代码为例，在函数被调用前，没有必要判断该调用哪个方法去绑定事件处理器。使用了延迟加载技术的函数版本如下： 12345678910111213function addHandler(target, eventType, handler) &#123; if (target.addEventListener) &#123; addHandler = function(target, eventType, handler) &#123; target.addEventListener(eventType, handler, false); &#125; &#125; else &#123; addHandler = function(target, eventType, handler) &#123; target.attachEvent('on' + eventType, handler); &#125; &#125; addHandler(target, eventType, handler);&#125; 上面这个函数实现了延迟加载模式。函数在第一次被调用时，会先检查并决定使用哪种方法去绑定事件处理器。然后原始函数被包含正确操作的新函数覆盖。这样一来，随后每次调用都不会再做检测，因为检测代码已经被新的函数覆盖。 调用延迟加载函数时，第一次总是会消耗较长时间，因为它必须运行检测接着再调用另一个函数完成任务。但是在第一次之后的每次调用，速度将大大加快，因为它不需要再执行检测逻辑。 条件预加载条件预加载技术，会在脚本加载期间提前检测，而不会等到函数被调用。条件检测的操作依然只有一次，只是它在过程中来得更早。 1234567const addHandler = document.body.addEventListener ? function(target, eventType, handler) &#123; target.addEventListener(eventType, handler, false); &#125; : function(target, eventType, handler) &#123; target.attachEvent('on' + eventType, handler); &#125;; 上面这段代码会先检查 addEventListener() 是否存在，然后根据结果指定选择最佳的函数。提前发生的检测 条件预加载确保所有函数调用消耗的时间相同。其代价是需要在脚本加载时就检测，而不是加载后。预加载适用于一个函数马上就要被使用，并并且在整个页面的生命周期中频繁出现的场合。 使用速度快的部分位操作JavaScript 位操作符作用在最基本的层次上，即按内存中表示数值的二进制比特来操作数值。JavaScript 中的数字都依照 IEEE-754 标准以 64 位格式存储。在位操作中，64 位的数字值会被转换位有符号 32 位格式。位操作符会直接操作该 32 位数以得到结果，尽管需要转换，但这个过程与 JavaScript 中其他数学运算和布尔操作相比较要快很多。 科班出身的开发者，应该都知道二进制数、原码、补码、反码、按位操作和左移、右移这些概念吧，在此不再赘述。 ECMAScript 中用于位操作的运算符有： &amp;：按位与 |：按位或 ^：按位异或 !：按位取反 &lt;&lt;：左移 &gt;&gt;：有符号的右移，将数值向右移动，但会保留符号 &gt;&gt;&gt;：无符号的右移，将数值的所有 32 位都向右移动 原生方法无论 JavaScript 代码如何优化，永远都不会比 JavaScript 引擎提供的原生方法更快。 所以开发中，可能地话，应该尽量使用 ECMAScript 规定的标准方法和宿主环境提供的原生 API 解决问题，而不是自己重复造轮子或者滥用类库的接口。特别是数学运算和 DOM 操作，我们应该尽量使用原生方法。 参考 《高性能JavaSript》，[美]Nicbolas C.Zakas 著，丁琛 译，电子工业出版社 2015]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript性能优化：（五）优化字符串操作和正则表达式]]></title>
      <url>%2F2016%2F12%2F18%2FJavaScript%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%EF%BC%88%E4%BA%94%EF%BC%89%E4%BC%98%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[几乎所有的 JavaScript 程序都与字符串操作密切相关。一个典型的应用程序通常需要大量类似合并、分隔、重新排序、搜索、遍历等字符串操作。 对于复杂的文本匹配，正则表达式是必不可少的，我们有必要学习如何编写高性能的正则表达式。 合并字符串拼接字符串是编程中最常见的操作了，我们先来总结一下 JavaScript 中连接字符串的方法： + += Array.prototype.join() String.prototype.concat() ES6 新增的模板字符串 当拼接少量较短字符串，以上这些方法速度都差不多。但随着需要连接的字符串的长度和数量的增加，一些方法开始展现出优势。 待连接字符串是变量如果要拼接的字符串中有以变量形式存在的字符串，优先使用 ES6 中的模板字符串。 将变量名包裹在 ${} 中，然后使用反引号（` ）包裹变量和普通字符串： 1`$&#123;username&#125; is from $&#123;country&#125; .` + 和 +=我们首先必需弄明白一点，在 JavaScript 中字符串一经初始化值便是不可改变的。 下面是一个拼接字符串的常见操作： 1str += 'one' + 'two'; 上面代码在运行时，会历经以下四个步骤： 在内存中创建一个临时字符串 拼接后的字符串 onetwo 被赋值给该临时字符串 临时字符串与 str 当前的值进行连接 将上一步的拼接结构赋值给 str 为了避免产生临时字符串造成额外的性能开销，我们可以这样做： 12str += 'one';str += 'two'; 如果使用下面这种方式，我们能获得更显著的性能提升： 12str = str + 'one' + 'two';// 等价于 str = ((str + 'one') + 'two'); 注意，上面代码中如果赋值号右侧表达式中的 str 不是处在最左侧，那么将得不到优化效果，这与浏览器合并字符串时分配内存的方法有关。大多数浏览器都会尝试为表达式左侧的字符串分配更多的内存，然后简单地将第二个字符串拷贝至它的末尾。如果在一个循环中，基础字符串位于最左侧的位置，就可以避免重复拷贝一个逐渐变大的基础字符串。 合并数组项Array.prototype.join() 方法将数组中地所有元素合并成一个字符串，它接收一个参数作为每项之间的分隔符。如果传入参数为空字符，那么我们就可以使该方法将所有数组项连接为一个字符串。 然而，现实情况是，在大多数浏览器中，数组项合并比其他字符串连接方法更慢。 String.prototype.concat()包装类型 String 的原生方法 String.prototype.concat() 能够接受任意数量的参数，并将每一个参数附加到所调用的字符串上，这是最灵活的字符串合并方法。 遗憾的是，在多数情况下，使用 cancat() 方法比使用简单的 + 和 += 稍慢。 总结：如果要合并的字符串中存在变量，那么使用模板字符串；否则，仅使用简单的 + 操作符合并字符串，并将基础字符串置于表达式最左侧。 正则表达式优化回溯失控回溯失控的正则表达式可能会导致浏览器假死数秒甚至更长时间，为了避免出现回溯失控，编写正则表达式时可以考虑如下方案： 尽可能具体化分隔符之间的字符串匹配模式 使用预查和反向引用的模拟原子组 保证正则表达式的两个部分不能对字符串的相同部分进行匹配 尽可能保持正则表达式简洁易懂 提高正则表达式效率 关注如何让匹配更快：正则表达式慢的原因是匹配失败的过程慢而不是匹配成功的过程慢 以简短、必需的元字符开头：尽可能地避免以分组或分支或选择性元字符开头，这样会造成性能损失 使用量词模式，使它们后面的元字符互斥：具体化匹配模式，避免出现字符与元字符相邻或子表达式能够重叠匹配的情况 减少分支数量，缩小分支范围：字符集比分支更快；如果不可避免地使用分支，应将概率最大的分支放在靠前的位置 尽量避免使用捕获分组：捕获组消耗时间和内存来记录反向引用，并使它保持最新 只捕获需要的文本以减少处理：如果需要引用匹配，应该采取一切手段捕获那些片段，再使用反向引用来处理 暴露必需的元字符：尽可能地让引擎判断那些元字符是必需的 使用合适的量词：贪婪和惰性量词的匹配过程有较大区别，使用更合适的量词类似可以显著提升性能，尤其是在处理长字符时 使用局部变量缓存正则表达式并重用 拆分复杂的正则表达式为简单片段： 避免在一个正则表达式中处理太多任务 不使用正则表达式当仅仅是搜索某个字符串特定位置上的值时，我们没必要动用正则表达式，因为那样不但性能低下，反而可能会弄巧成拙。 包装类型 String 拥有的 charAt()、slice()、substr()、substring()、indexOf() 和 lastIndexOf() 等原生方法都非常适合查找特定字符串的位置，或者判断它们是否存在。 对字符串进行操作，在使用正则表达式之前，先考虑一下这些原生的 String 方法，它们有助于避免正则表达式带来的性能开销。 参考 《高性能JavaSript》，[美]Nicbolas C.Zakas 著，丁琛 译，电子工业出版社 2015 《精通JavaSript开发》，[英]Den Odell 著，邝健威 厉海洋 译，人民邮电出版社 2015]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript性能优化：（四）程序流程控制]]></title>
      <url>%2F2016%2F12%2F15%2FJavaScript%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%EF%BC%88%E5%9B%9B%EF%BC%89%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
      <content type="text"><![CDATA[代码数量多少并不是程序运行速度的决定性因素，代码的组织结构和解决问题的思路才是影响代码性能的主要因素。而代码结构中最重要的就是流程控制：循环、条件分支、函数调用… 循环ES5 及之前版本中有以下四种循环类型： for( ; ; ) {} while() {} do{} while() for...in 上面列表中的所列的前三个循环，一般说来，在性能方面没有差距特别显著的高下之分，大多数人最常用的应该是 for 循环了。 更快的 for 循环对于最常用的 for 循环了，我们唯一可做的性能优化措施就是缓存待遍历数据集的相关属性值。例如进行数组循环时，我们应该缓存数组的 length 属性值，这样就可以避免每次遍历一个元素都会重新访问其 length 属性，从而避免了不必要的性能损失。 123456const arr = [0, 1, 2, 3, 4, 5];const len = arr.length;for (let i = 0; i &lt; len; i++) &#123; console.log(arr[i]);&#125; 反向 while 循环对于大量数据而言最快速的迭代方式是反向 while 循环。这项技术之所以没有使用 for 循环，是因为 for 循环每遍历一项还需要进行终止条件的判断这一步骤（在上面代码中就是 i &lt; len）。 得益于 JavaScript 的隐式类型转换，在反向 while 循环中我们不用写 index &gt;=0 这种表达式，因为 0 值会被自动转换为 false。 123456const arr = [0, 1, 2, 3, 4, 5];let index = arr.length;while (index--) &#123; console.log(arr[index]);&#125; 观察上面的代码，与之前的 for 循环相比，可以看出，反向 while 循环省去了以下步骤： 数值比较：i &lt; len 计算数值比较结果的真假性：(i &lt; len) == true 需要强调的是，虽然反向 while 循环是最快速的迭代方法，但对于超大型数组来说也只是快了几百毫秒而言。因此，这种技术更像是理论应用而不实际的性能优化技巧。注意，由于 JavaScript 是单线程的、事件驱动的、异步的，所以性能开销也依赖于实际执行环境具体而异。 使用 break 或 continue 缩短循环次数如果我们遍历某个数据集的目的是找到某个符合要求的值，那么当已经找出了所要寻找的值时，就应该立马跳出当前这一轮遍历，或结束整个循环。 break 和 continue 关键字可以帮助我们进行这种操作： break 使当前整个循环停止执行，然后程序会转而继续执行循环语句之后的代码 continue 使当前遍历的迭代停止，并开始进行下一次迭代 避免在循环中创建函数为了更快地进行循环，我们应该永远避免在循环中创建函数。每一次创建函数时，都会为该函数分配一定的物理内存，并填充到表示该函数的对象数据。 为了避免在每一次迭代中创建一个函数，可以先在循环语句之前创建并声明一个单独的函数，然后在循环体内引用该函数。 基于函数的迭代ES5 引入为 Array 类型引入了一个名为 forEach() 的原生方法，该方法接受一个函数做参数。执行此方法会遍历一个数组的所有成员，并对每个成员执行传入的函数。这个作为 forEach() 参数的函数接受三个指定的参数：当前数组项的值、当前值的索引、数组本身。 12345const arr = [0, 1, 2, 3, 4, 5];arr.forEach((value, index, arr) =&gt; &#123; process(value); // process() 为一个已经定义的函数&#125;); 但就性能角度考量，不建议使用 forEach() 方法遍历数组。因为现代浏览器引擎内部已经为最常用的 for 循环进行了优化，就遍历时间而言，forEach() 用时多于 for 循环。 另外，这种遍历数组的方式有个缺陷：既不能使用 break 语句中断循环，也不能使用 return 语句返回到外层函数。 减少迭代次数：Duff’s Device如果迭代超过 1e3 数量级了，无论如何循环多会变得慢很多。对于这种情况，我们应该设法减少迭代次数以提高循环性能。 “Duff’s Device” 是一个循环体展开技术，它使得一次迭代中实际上执行了多次迭代的操作。Jeff Greenberg 被认为是将 “Duff’s Device” 代码从原始的 C 实现移植到 JavaScript 中的第一个人。 ——《高性能JavaScript》 下面是该算法的一个较好实现，其基本理念是：每次循环最多可调用 8 次 process()。循环的迭代次数为总数除以 8。由于不是所有数字都能被 8 整除，变量 i 用于存放余数，表示第一次循环应该调用多少次 process()。然后剩余的每次循环都调用 8次 process()。 123456789101112131415161718let i = items.length % 8;while (i) &#123; process(items[i--]);&#125;i = Math.floor(items.length / 8);while (i) &#123; process(items[i--]); process(items[i--]); process(items[i--]); process(items[i--]); process(items[i--]); process(items[i--]); process(items[i--]); process(items[i--]);&#125; 是否应该使用 “Duff’s Device”，很大程度上依赖于迭代次数。当循环迭代次数超过 1000时，使用了 “Duff’s Device” 技术的迭代性能提升显著。 for…of 循环（ES6+）这四种循环类型中，for(...in...) 循环效率低下，究其原因是其本身实际是被用于遍历对象属性的“键”而非“值”，但很多人都误用其去遍历对象属性的 “值”。 考虑到 Web 世界的向下兼容，不能直接修改 fo...in 循环的内部原理以及行为表现，所以 ES6 新引入了 for...of 循环，我们可以用其专门遍历键值对中的“值”。 当执行 for..of 循环时，会首先调用对象的 [Symbol.iterator]() 方法（这是 for...of 循环必需的东西），然后返回一个新的迭代器对象。迭代器对象可以是任意具有 .next() 方法的对象；for...of 循环将重复调用这个方法，每循环一次调用一次。 123456789const arr = ['a', 'b', 'c', 'd', 'e'];for(let i in arr) &#123; console.log(i); // '0' '1' '2' '3' '4'&#125;for(let i of arr)&#123; console.log(i); // 'a' 'b' 'c' 'd' 'e'&#125; 条件分支受 C 语言的影响，JavaScript 中的条件分支语句也有两种：if-else 和 switch。由于不同的浏览器针对流程控制进行了不同的优化，因此使用哪种技术性能开销更小没有绝对定论。 if-else VS switch使用 if-else 还是 switch，最流行的方法是基于测试条件的数量来判断：条件数量越多，越倾向于使用 switch 而不是 if-else。 事实证明，大多数情况下 switch 比 if-else 运行得要快，但只有当条件数量很大时才快得明显。这两种分支语句主要性能区别是：当条件增加时，if-else 性能负担增加得程度比 switch 要多。因此，我们自然倾向于在条件数量较少时使用 if-else，而在条件数量较大时使用 switch，这从性能方面考虑也是合理的。 通常来说，if-else 用于判断两个离散值或几个不同的值域。当判断多于两个离散值时，switch 语句是更加选择。 注意，JavaScript 中 switch 操作符使用的是 “===” 操作符进行比较，所以不会产生类型转换的损失。 if-else 的优化优化 if-else 的目标是，最小化到达正确分支前所需判断的条件数量。 最简单的优化方法就是将概率最大的条件放在第一个分支 if()。 1234567if (x &lt; 3) &#123;&#125; else if (x &gt; 3 &amp;&amp; x &lt; 10) &#123;&#125; else &#123;&#125; 上面这段条件语句，只有当变量 x 的值大于 3时，if-else 语句的性能才是最优的。 另一种减少条件判断次数的方法是把多个并列的 if-else 分支语句组织成一系列嵌套的 if-else 语句。使用单个庞大的 if-else 通常会导致运行缓慢，因为每个条件都需要判断。例如： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546if (x === 0) &#123; return result0;&#125; else if (x === 1) &#123; return result1;&#125; else if (x === 2) &#123; return result2;&#125; else if (x === 3) &#123; return result3;&#125; else if (x === 4) &#123; return result4;&#125; else if (x === 5) &#123; return result5;&#125; else &#123; return undefined;&#125;// 优化之后if (x &lt; 3) &#123; if (x &lt; 1) &#123; if (x === 0) &#123; return result0; &#125; else &#123; return undefined; &#125; &#125; else &#123; if (x === 1) &#123; return result1; &#125; else &#123; return resul2; &#125; &#125;&#125; else &#123; if (x &lt; 5) &#123; if (x === 3) &#123; return result3; &#125; else &#123; return result4; &#125; &#125; else &#123; if (x === 5) &#123; return result5; &#125; else &#123; return undefined; &#125; &#125;&#125; 查找表 在计算机科学中，查找表 是用简单的查询操作替换运行时计算的数组或者关联数组这样的数据结构。由于从内存中提取数值经常要比复杂的计算速度快的多，所以这样得到的速度提升是很显著的。——维基百科 当有大量离散值需要测试时，我们可以使用查找表，将要判断真假的条件表达式可能的值及其对应的表达式操作构建为键值对，然后将这些键值对填充到数组或者普通对象（ES6+之后可以使用 Map 结构）中。 当使用查找表时，我们必需抛弃条件判断语句。这个过程演变为数组项查询或者对象成员查询。查找表的一个主要优点是：不用书写任何条件判断语句，即便候选值数量增加时，也不会产生额外的性能开销。 下面是一个使用查找表改写 switch 分支结构的例子： 123456789101112131415161718192021switch (value) &#123; case 0: return result0; case 1: return result1; case 2: return result2; case 3: return result3; case 4: return result4; case 5: return result5; default: return result6;&#125;// 使用查找表改写const results = [result0, result1, result2, result3, result4, result5, result6];return results[value]; 单个键和单个值之间存在逻辑映射时，查找表的优势就能体现出来。switch 语句更适合于每个键都需要对应一个独特的动作或者一系列动作的场合。 递归最大调用栈限制JavaScript 引擎支持的递归上限于 JavaScript 调用栈大小直接相关，大多数现代浏览器都有固定数量的调用栈限制。 当在程序中使用了太多递归，或者程序递归流程本身有问题时，就有可能会超过 JavaScript 引擎的最大调用栈限制，从而导致栈溢出错误。 递归模式有两种递归模式可能引起栈溢出错误。 第一种模式如下： 12345process();function process() &#123; process();&#125; 另一种模式如下： 123456789first();function first() &#123; second();&#125;function second() &#123; first();&#125; 在这种模式中，两个函数相互调用，形成一个无限循环。 大多数调用栈错误都与这两种模式有关。最常见的的导致栈溢出的原因是不正确的终止条件，因此定位模式错误的第一步是验证终止条件。如果终止条件没有问题，那么可能是算法中包含了太多层递归，为了能在浏览中安全地工作，建议改用迭代、Memoization，或者结合两者使用。 迭代任何递归能实现的算法同样可以使用迭代来实现。迭代算法通常包含几个不同的循环，分别对应计算过程的不同方面，这也会引入它们自身的性能问题。然而，使用优化后的循环替代长时间运行的递归函数可以提升性能，因为运行一个循环比反复调用一个函数的开销要少得多。 提升函数性能MemoizationMemoization 是一种可以缓存之前的结算结果以供后续计算使用的技术。 下面这段代码是常见的计算阶乘的递归函数： 1234567function factorial(n) &#123; if (n === 0) &#123; return 1; &#125; else &#123; return n * factorial(n - 1); &#125;&#125; 现在，我们使用 Meomization 技术改写上面这段代码，以缓存每一次的计算结果： 1234567891011function memFactorial(n) &#123; if (!memFactorial.cache) &#123; memFactorial.cache = new Map([[0, 1], [1, 1]]); &#125; if (!memFactorial.cache.has(n)) &#123; memFactorial.cache.set(n, n * memFactorial(n - 1)); &#125; return memFactorial.cache.get(n);&#125; 我们还可以将 Memoization 技术抽象为一个一般性函数，以将任何普通函数转换带缓存记忆功能的函数。下面是一个简单的封装了 Memoization 技术的函数实现： 1234567891011//function memoize(fn) &#123; fn.cache = fn.cache || new Map(); return function(arg) &#123; if (!fn.cache.has(arg)) &#123; fn.cache.set(arg, fn(arg)); &#125; return fn.cache.get(arg); &#125;&#125; ！！！注意： 上面这种通用的 Memoization 技术与手动针对某个特定函数编写的 memoization 版本相比，优化效果较差。究其本质，memoize() 函数只会缓存特定参数的函数调用结果。例如： 123456789101112131415function factorial(n) &#123; if (n === 0) &#123; return 1; &#125; else &#123; return n * factorial(n - 1); &#125;&#125;const memoizefactorial = memoize(factorial);memoizefactorial(6);console.log(factorial.cache); // Map &#123; 6 =&gt; 720 &#125;memFactorial(6);console.log(memFactorial.cache); // Map &#123; 0 =&gt; 1, 1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 6, 4 =&gt; 24, 5 =&gt; 120, 6 =&gt; 720 &#125; 由此可见，上面那种对于所有函数适用的通用 Memoization 技术存在显著性能问题，所以，如果要适用 Memoization 技术，强烈建为特定函数有针对性地实现，而不是采用通用 Memoization 技术方案。 参考 《高性能JavaSript》，[美]Nicbolas C.Zakas 著，丁琛 译，电子工业出版社 2015 《精通JavaSript开发》，[英]Den Odell 著，邝健威 厉海洋 译，人民邮电出版社 2015]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript性能优化：（三）优化DOM操作]]></title>
      <url>%2F2016%2F12%2F12%2FJavaScript%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%EF%BC%88%E4%B8%89%EF%BC%89%E4%BC%98%E5%8C%96DOM%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[导致大多数网站和应用程序出现性能问题的一个最大因素是低效率的 DOM 操作。浏览器的 JavaScript 引擎独立于其渲染引擎，通过浏览器获取对页面 DOM 元素的引用要涉及从一个引擎跳转到另一个引擎，浏览器则充当了二者之间的媒介。为了提高性能，我们需要减少这种跳转出现的次数。本文记述了一些常用的技巧，以帮助提升 DOM 操作性能。 使用新的选择器API大多数最新版本的现代浏览器都实现了 Selectors API 标准，该标准的核心是两个方法：querySelector() 和 querySelectorAll()。 二者均接受一个 String 类型的 CSS 选择器，不同的是，前者返回与之匹配的第一个元素，而后者则返回一个包含了所有匹配节点的 NodeList 实例。 12const elem1 = document.querySelector('#idName');const elem2 = document.querySelector('.className'); 减少对 DOM 的访问使用局部变量缓存 DOM 元素下面是一段示范代码： 12const header = document.querySelector('header');const nav = document.querySelector('nav'); 引用共同的祖先元素如果需要访问的一些元素均位于同一父元素之下，那么我们可以只获取对该父元素的引用，并从该引用中获取它的各项子元素的引用。 需要注意的是，我们不能贪心，不要通过获取某一公共祖先元素的引用从而实现对多个 DOM 元素的访问，因为祖先元素与这些实际要访问的元素间的层级越多，那么所需的内存占用也越多，而且也会增加 JavaScript 深入 DOM 树查找实际需要访问元素的时间，这势必会对应用程序产生负面的性能影响。所以最佳实践，是综合考量需要处理的 DOM 元素数目以及最近的共同祖先元素离它们自身之间有多少层。 下面是一个简单示范： 123const header = document.querySelector('header');const h1 = header.querySelector('h1');const div = header.querySelector('div'); 如果只是通过共同父元素来获取对各个子元素的引用，我们还可以使用 DOM 元素的 children 属性。当然了，这种方法只适用于需要处理的 DOM 元素有一个共同的父元素的情况。 1234const header = document.querySelector('header').children;const h1 = header[0];const div = header[1]; 利用相邻元素如果需要访问的一些元素正好是同一元素的相邻元素，那么我们可以只获取对该元素的引用，然后使用 previousElementSibling 和 nextElementSibling 来获取其相邻元素。 12345const div = document.querySelector('div');// 我们没有使用 Node.previousSibling，是因为我们只需要 HTML 元素节点，而不需要文本节点和注释节点// 使用 Node.previousSibling 还需要我们手动过滤文本节点和注释节点，没有此种方式效率高const previousElem = div.previousElementSibling;const nextElem = div.nextElementSibling; 克隆已有节点使用 createElement() 方法创建 DOM 元素会带来性能上的损失。为了提高性能，在创建 DOM 元素时，我们应该首先考虑尽可能地利用已有元素来创建新元素。 DOM 节点具有一个名为 cloneNode() 的方法，该方法具有一个可选参数，其接受一个布尔类型的值，用于决定是深克隆还是浅克隆。如果省略，默认值为 false，即浅克隆，仅仅克隆当前节点及其相关对象属性。如果值为 true，即深克隆，也就是当前节点及其相关对象属性和其所有后代节点均会被克隆。尽管参数可以省略，最佳实践是永远传入一个布尔值。 ！！！注意： 如果被克隆的 DOM 元素设置了 id 属性，那么克隆的副本也会带有相同的 id 属性值，所以克隆具有 id 属性的元素后应该重写副本的 id 属性值。 1234567const div = document.querySelector('#test');const copyDiv = div.cloneNode(false);copyDiv.id = 'copyDiv';const list1 = document.createElement('ul');const list2 = list1.cloneNode(false); innerHTML VS 原生 DOM 方法 基于 WebKit 内核的新浏览器中，原生 DOM 方法性能更好 旧版本浏览器中，innerHTML 优势更明显 如果在一个对性能有着苛刻要求的操作中更新一大段 HTML，推荐使用 innerHTML，因为他在绝大部分浏览器中都运行得更快。但对于大多数日常操作而言，二者并没有太大区别。 减少重绘和回流页面的重绘与回流使得实时页面性能开销巨大，当需要对 DOM 元素进行一系列操作时，我们可以通过以下方法来减少重绘和回流的次数： 通过改变元素的类名修改其样式我们应该尽量避免使用 DOM 元素的 style 属性来修改元素的样式，因为那样会额外增加重绘和回流的次数，降低性能。最佳实践是永远通过元素的类来制其获取的 CSS 样式，进而达到改变元素样式的目的。 HTML5 新增了一种操纵元素 class 特性值的方式，现在所有的元素都具有了 classList 这一属性。并配套提供了 add()、remove()、toggle() 和 contains() 方法。 123const header = document.querySelector('header');header.classList.toggle('selected'); 隐藏元素-&gt;应用修改-&gt;重新显示123456789const p = document.createElement('p');const div = document.querySelector('div');div.style.display = 'none';p.text = 'I am a paragraph';div.appendChild(p);div.style.display = 'block'; 使用文档片段 DocumnetFragment(Document Fragment)文档片段是一种轻量级的 DOM 文档，表示没有父节点的最小文档对象。它独立于实时渲染的页面文档而存在，所以它不像实时页面的 DOM 那样会占用额外资源，也称(offline DOM)离线文档。 Document Fragment 继承了 Node 类型的所有属性和方法，我们可以像使用普通文档树中的 DOM 元素那样使用文档片段中的 DOM 元素。 创建一个 DOM Fragment 的方式如下： 12345// 方法一：const fragment = document.createDocumentFragment();// 方法二：此 API 比较新，请查阅浏览器兼容性，不建议在生产环境使用const fragment2 = new DocumentFragment(); 创建了 Document Fragment 之后，我们就可以像操纵实时页面的 DOM 结构树那样操作它了。 12345const header = document.createElement('header');const nav = document.createElement('nav');fragment.appendChild(header);fragment.appendChild(nav); 由于文档片段的离线特性，如果我们将实时页面文档中的节点添加到了文档片段中，那么就会从页面文档树中删除这个节点。同样地，添加到文档片断中的节点与页面文档也没什么关系。 通过将文档片段做参数传给 appendChild() 或 insertBefore() 方法，我们可以将文档片段中的所有内容添加到页面文档树中。注意，添加到实时页面上的是整个离线文档片段中的所有子节点，文档片段本身永远也不会成为文档树中的一部分。 1document.appendChild(fragment); 如果需要同时修改许多 DOM 元素，这是最推荐的方法。 操作副本元素第三种解决方案是为需要修改的节点创建一个备份，然后对其副本进行 DOM 操作。一旦 DOM 操作完成，就可以用新的节点替代旧的节点。 123456const old = document.querySelector('div');const clone = oldNode.cloneNode(true);// do somethingold.parentNode.replaceChild(clone, old); 提升 DOM 事件性能委托事件至祖先元素DOM 事件会从其首次被触发的元素开始冒泡，一直到文档结构的最顶端。对于那些由用户操作的多个同类子元素而言，使用事件委托技术可以帮助我们显著提升 DOM 性能。 下面是一个简单的实现事件委托技术的函数，如果要把事件委托给某一元素处理，就将这个函数注册为该元素相应事件的监听器。其中，第二个参数为真正触发事件的元素的标签名，第三个参数为触发事件之后要执行的回调操作函数。 1234567function delegatesEvent(event, aimTagName, callback) &#123; const aimElement = event.target; if (aimElement !== undefined &amp;&amp; aimElement.tagName === aimTagName.toUpperCase()) &#123; callback(); &#125;&#125; 使用事件框架化处理频密发出的事件某些事件可能会在很短的时间内被触发多次，例如，mousemove、touchmove 等事件。如果有很多事件在很短时间内接连不断地被触发，那么采用 addEventListener() 方式一一注册势必会陷入性能泥淖。 对于这种类型的频密发出的事件，我们可以对代码进行调整，是事件处理函数只负责把当前事件相关的值保存至变量中。将计算密集型的代码迁移至单独的处理函数中，然后使用计时器按一定间隔执行该函数。这一原则被称为事件框架化。 1234567891011121314151617181920const body = document.body;const header = document.querySelector('header');let scrollTopPosition = 0;let scrollLeftPosition = 0;document.addEventListener('scroll', onScroll, false);requestAnimationFrame(writeScrollPosition);function onScroll() &#123; scrollTopPosition = body.scrollTop; scrollLeftPosition = body.scrollLeft;&#125;function writeScrollPosition() &#123; header.innerHTML = `$&#123;scrollTopPosition&#125;px, $&#123;scrollLeftPosition&#125;px`; requestAnimationFrame(writeScrollPosition);&#125; 无论如何，都要避免把计算密集型的事件处理函数直接绑定到会在连续状态改下快速频密触发的事件，我们可以使用事件框架化技术作为替代从而提升事件处理的性能。 参考 《高性能JavaSript》，[美]Nicbolas C.Zakas 著，丁琛 译，电子工业出版社 2015 《精通JavaSript开发》，[英]Den Odell 著，邝健威 厉海洋 译，人民邮电出版社 2015]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript性能优化：（二）作用域管理和对象访问]]></title>
      <url>%2F2016%2F12%2F12%2FJavaScript%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%AE%A1%E7%90%86%E5%92%8C%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%2F</url>
      <content type="text"><![CDATA[若说提高 JavaScript 程序性能，我们无法也不可能绕过作用域不谈。作用域对 JavaScript 有许多影响，从确定哪些变量可以被函数访问，到确定 this 的指向。JavaScript 作用域同整个程序的性能关系密切。JavaScript 中对象不同于传统面向对象程序设计语言，除去使用字面量方式声明对象不谈，我们有必要关注访问对象及其成员的性能问题。 作用域管理基于对作用域、作用域链、标识符解析等的理解，我们应该遵循以下性能法则： 应该尽可能地使用字面量，并减少数组项和对象成员的使用，因为访问字面量的速度最快，相反，访问数组元素和对象成员相对较慢 应该尽可能地使用局部变量，由于局部变量总是存在于执行环境作用域链的最顶端，因此访问局部变量比访问跨作用域变量更快。变量在作用域中的位置越深，访问所需时间越长。由于全局变量总处在作用域链的最末端，因此访问速度也是最慢的 在局部作用域中，最好使用局部变量缓存常用的跨作用域变量 避免使用 try-catcht 语句、eval() 和 with 语句，因为它们会产生动态作用域，从而改变执行环境的作用域链 小心使用闭包，它同时关系到内存和执行速度 对象访问通常来说，访问对象成员的速度比访问字面量或变量要慢，所以在访问对象及其成员，为了提高程序性能，我们应该遵循以下性能法则： 嵌套的对象成员会显著地影响性能，应该尽量少用 属性或方法在原型链中的位置越深，访问它的速度也越慢 把常用的对象成员、数组元素、跨作用域变量缓存在局部变量中，以提高 JavaScript 性能，因为局部变量访问速度最快。 参考 《高性能JavaSript》，[美]Nicbolas C.Zakas 著，丁琛 译，电子工业出版社 2015]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript单例模式]]></title>
      <url>%2F2016%2F12%2F10%2FJavaScript%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[单例模式是一种很常用的模式，有些对象我们往往只需要一个。然而，JavaScript 中实现单例模式的途径与传统面向对程序设计语言有很大不同。 全局变量即单例？ 单例模式的定义是：保证一个类有且仅有一个实例，并提供一个访问它的全局访问点。 由定义可知，单例模式的核心是保证只有一个实例，并提供全局访问，从这点来看，JavaScript 中全局作用域下使用对象字面量方式创建的对象应该算得上是符合单例模式了。 然而，JavaScript 没有真正意义上“类”的概念，所以全局作用域下使用对象字面量方式创建的对象无从谈起是属于哪个类的实例了，因为它自身就是一个实例，从这点上来看，也可以说全局变量不是单例模式。 1234var ming = &#123; name: 'ming', age : 17&#125;; 上面代码中，全局作用域中的对象 ming，从学院派角度而言无论其是否符合所谓“单例模式”的定义，我们都可以将其当作单例使用。所以 JavaScript 中全局变量是否严格符合单例模式的定义并不重要，重要的是，开发人员能将其当作单例使用。 值得注意的是，实际编程中，我们应该尽可能地减少全局变量的使用。 简单的单例模式实现要实现一个单例模式并不难，无非是用一个变量来标志当前是否已经为为某个类创建过对象，如果是，则在下一次获取时，直接返回之前创建的对象。代码如下： 1234567891011121314151617181920var Leader = function() &#123; this.instance = null; this.level = 'supreme'; this.toString = function() &#123; console.log('I am a leader.'); &#125;;&#125;;Leader.getSingle = function() &#123; if (!this.instance) &#123; this.instance = new Leader(); &#125; return this.instance;&#125;;var leader = Leader.getSingle();var leader1 = Leader.getSingle();console.log( leader === leader1 ); // true 上面代码比较简单，我们可以通过 Leader.getSingle() 来获取 Leader 类的唯一对象。这种方式虽然简单，方便理解单例模式，但具有如下缺点： 增加了类的“不透明性” 与传统通过 new 方式调用类不同，对用户不友好 符合单例模式的构造器为什么不是“构造函数”呢？我个人一直认为使用“构造器”而不“构造函数”称呼 ES5(包括之前的版本) 中用于创建对象的函数更好，因为 JavaScript 中没有真正意义上“类”的概念，函数是一等公民，所谓的“构造函数”只不过是使用 new 关键字对普通函数的一种调用而已，与传统面向对象程序设计语言中的“构造函数”有着本质区别。 与在全局作用域下使用字面量方式创建对象不同，如果我们使用了构造器来创建对象，那么就必须保证无论 new 构造器多少次，创建出来的始终都是同一个对象，这样才符合单例模式的概念。 下面我们来创建一个符合单例模式的构造器： 123456789101112131415161718192021var single;var Leader = function() &#123; if (!single) &#123; single = new init(); &#125; return single; function initLeader() &#123; this.level = 'supreme'; this.toString = function() &#123; console.log('I am a leader.'); &#125;; &#125;&#125;;var leader = new Leader();var leader1 = new Leader();console.log( leader === leader1 ); // true 通过测试结果，显然易见，上述代码中的构造器 Leader() 是符合单例模式的。但是上述代码有如下不足： 用于存储单例的变量暴露在全局作用域中 构造器不符合单一职责原则 改进方案为了解决这些问题，我们可以使用闭包、代理模式、原型链对上述方案进行优化： 12345678910111213141516171819var Leader = (function() &#123; var single; return function(fn) &#123; return ( single || ( single = new fn() ) ); &#125;;&#125;)();var initLeader = function() &#123; this.level = 'supreme'; this.toString = function() &#123; console.log('I am a Leader.'); &#125;&#125;var leader = new Leader(initLeader);var leader1 = new Leader(initLeader);console.log( leader === leader1 ); // true 惰性单例惰性单例指的是在需要的时候才创建对象实例。 接下来，我们编写一个通用的惰性单例，它接受一个可用作构造器的函数，并返回这个构造器的惰性单例版本。 12345678var getSingle = function(fn) &#123; var single; return function() &#123; var createor = fn.bind(this, arguments); return ( single || ( single = new createor() )); &#125;;&#125;; 单例模式的 ES6 实现ES6 引入了 class 关键字，这使得 JavaScript 看上去和传统面向对象程序设计语言差不多，然而这只是原型链对象关系的语法糖，本质上其还是构造器和原型链继承。 123456789101112131415161718192021class Leader &#123; constructor () &#123; if (!Leader.single) &#123; this.level = 'supreme'; Leader.single = this; &#125; return Leader.single; &#125; toString() &#123; console.log('I am a leader.'); &#125;&#125;Leader.single = null;const leader = new Leader();const leader1 = new Leader();console.log(Object.is(leader, leader1)); // true 如前所述，在 JavaScript 中实现单例模式的核心是使用一个变量来标志某个类是否已经实例化过对象。在 ES6 中，有了 class 语法，我们可以方便地将这个变量绑定到类自身上，作为其静态变量。 ！！！注意： ES6 规范中并未提出类静态变量的标准写法，也就说，我们只能通过类似 myClassName.staticVar = 0 这种方式来给所谓的类静态变量赋值。 参考 《JavaScript设计模式与开发实践》 曾探.著 人民邮电出版社，2015]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对伪元素使用伪类选择器]]></title>
      <url>%2F2016%2F12%2F08%2F%E5%AF%B9%E4%BC%AA%E5%85%83%E7%B4%A0%E4%BD%BF%E7%94%A8%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
      <content type="text"><![CDATA[有时我们想使用一个伪类选择器去选择一个伪元素以使用一些效果，按照操作的逻辑，选择器看起来可能像这样：.test::before:hover，但事实上这是不正确的。 根据 W3C 的标准，一个伪类选择器是简单的选择器。然而，一个伪元素选择器却不是，尽管它与伪类选择器类似。所以我们不可将伪类选择器置于伪元素选择器之后。 其实，就对伪类有影响的用户行为而言，如果我们仅仅需要在用户与伪元素自身互动时应用效果，那么除非使用一些晦涩难懂的布局，否则这几乎是不可能实现的。 另外，就现在来说，标准的 CSS 伪元素并不能具有伪类。所以，我们应该对真实的 DOM 元素应用伪类选择器而不是伪元素。 如果要使用伪类处理一个伪元素，标准写法如下： 1.test:hover::before &#123;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[边框内圆角]]></title>
      <url>%2F2016%2F12%2F08%2F%E8%BE%B9%E6%A1%86%E5%86%85%E5%9C%86%E8%A7%92%2F</url>
      <content type="text"><![CDATA[边框内圆角就是只在盒子模型的内侧有圆角，而边框或者描边的四个角在外部仍然保持直角的形状。这个效果我们也有两种方式实现它。 双层 div 解决方案使用双层 div 实现这个效果比较容易，只需为内层 div 设置圆角效果，然后给外层 div 设置背景色和一定的 padding 即可。 12345678910.inner-round &#123; background: #655; padding: .8em;&#125;.inner-round &gt; div &#123; background: tan; border-radius: .8em; padding: 1em;&#125; 只使用一个元素如果要求只使用一个元素，我们可以写出如下代码： 1234567.inner-round &#123; background: tan; border-radius: .8em; padding: 1em; box-shadow: 0 0 0 .6em #655; outline: .6em solid #655;&#125; 由于 box-shadow 产生的阴影效果会沿着元素的圆角轮廓包裹元素，而 outline 产生的描边效果依然是矩形，所以我们可以通过结合二者做出边框内圆角效果。 这里的关键在于我们应该为阴影指定多大的扩张值以填补元素圆角与描边矩形间的空白。 假设圆角半径为 r，那么圆心到描边矩形内顶点的距离应该为 (&radic;2 - 1)r，也就是说阴影效果的扩张值我们应该大于这个值，以填补圆角与描边之间的空白。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript去除字符串首尾空白]]></title>
      <url>%2F2016%2F12%2F07%2FJavaScript%E5%8E%BB%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A6%96%E5%B0%BE%E7%A9%BA%E7%99%BD%2F</url>
      <content type="text"><![CDATA[去除字符串首尾空白是个简单常见的任务，ES5 已经添加了原生的 trim() 方法，我们之所以还要探究其实现，是因为其作为学习优化正则表达式的例子再好不过了。 使用正则表达式的解决方案最常见解决方案如果使用正则表达式解决这个问题，我们或许立刻会想到以下解决方案： 12345if (!String.prototype.trim) &#123; String.prototype.trim = function() &#123; return this.replace(/^\s+|\s+$/g, ''); &#125;&#125; 这个方法的不足之处在于，若目标为较长字符串，那么正则表达式中的条件分支功能会拖慢速度。 两次替换方案如果不使用具有条件分支的正则表达式，我们可以写出如下实现： 12345if (!String.prototype.trim) &#123; String.prototype.trim = function() &#123; return this.replace(/^\s+/, '').replace(/\s+$/, ''); &#125;&#125; 这种方式通过对目标字符串执行两次替换操作从而避免了条件分支的性能开销，与最常见的解决方案相比，此种方案在处理长字符串时速度会得到显著提升。 称不上优化的优化我们还可以将两次替换方案中所用正则表达式的 \s+ 改为 \s\s* 来达到额外优化的效果，尽管这并没有什么明显的性能提升。 12345if (!String.prototype.trim) &#123; String.prototype.trim = function() &#123; return this.replace(/^\s\s*/, '').replace(/\s\s*$/, ''); &#125;&#125; 不使用正则表达式的解决方案循环遍历字符串确定空白字符如果不使用正则表达式，那么我们就不可避免地需要使用循环遍历字符串来找出空白字符，然后使用相应的字符串原生方法实现需求： 1234567891011121314151617if (!String.prototype.trim) &#123; String.prototype.trim = function() &#123; const ws = '\n\r\t\f\x0b\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\202f\205f\u3000\ufeff'; let start = 0; let end = this.length - 1; while (ws.indexOf(this.charAt(start)) &gt; -1) &#123; ++start; &#125; while (end &gt; start &amp;&amp; ws.indexOf(this.charAt(end) &gt; -1)) &#123; --end; &#125; return this.slice(start, end + 1); &#125;&#125; 上述代码中的 ws 变量包含了 ECMAScript 中定义的所有空白字符。出于性能考虑，在得到修剪后的起始和终止的位置之前避免拷贝字符串的任何部分。 尽管这个版本的解决方案其性能不受字符串的总长度影响，但它在处理前后有大量空白的字符时却显得费力，这是因为通过循环遍历字符串来确定空白字符串到的效率不够高。 混合解决方案可以通过混合使用正则表达式解决方案与 slice() 方法来使性能更高效，具体来说，即使用正则表达式解决方案过滤字符串头部空白，使用非正则表达式解决方案过滤字符串尾部空白。 1234567891011if (!String.prototype.trim) &#123; String.prototype.trim = function() &#123; const ws = /\s/; let str = this.replace(/^\s\s*/, ''); let end = str.length; while (ws.test(str.charAt(--end))) &#123;&#125; return str.slice(0, end + 1); &#125;&#125; 这种混合解决方案尤其在处理更长的字符串时性能显著，超越了之前的解决方案，但在处理短字符串时耗时还会多于使用正则表达式的解决方案。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySQL免安装版配置]]></title>
      <url>%2F2016%2F12%2F06%2FMySQL%E5%85%8D%E5%AE%89%E8%A3%85%E7%89%88%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[与图形化安装界面不同， MySQL 免安装版在运行之前，还需要自己进行配置。本文记录了在 Windows10 平台上配置 MySQL5.7.16 免安装版的过程。 解压安装将下载好的 zip 压缩包解压到自己喜欢的文件夹，为了避免可能出现的错误，建议文件路径中不包含中文名以及空格。下文以 C:\mysql 这一路径为例进行讲解。 配置环境变量将路径 C:\mysql\bin 加入到 PATH 环境变量之后，用户变量或者系统变量即可，毕竟我们的个人电脑一般都是一个用户。 这一部的目的主要是为了在非 C:\mysql\bin 的其他路径下也能使用 mysql 命令。如果不添加环境变量，那么我们每次在命令中执行 mysql 命令还需进入到 C:\mysql\bin 路径下才能执行。 编辑配置文件路径 C:\mysql 下有一份初始的默认配置文件，即 my-default.ini 文件。在此路径下，新建一份自己的配置文件 my.ini (不要使用其他名称)，然后将 my-default.ini 中的内容复制过来并保存。 使用文本编辑器打开 my.ini ，修改以下几项。还有其他很多参数也都可自定义，感兴趣的同学可以继续研究。下面这几个是最重要的也是我们必须要修改的。 12345678# 默认字符集default-character-set = utf8# mysql 安装路径basedir = C:\mysql# mysql 数据文件夹路径，不要怕，我们现在确实还没有创建这个 data 文件夹datadir = C:\mysql\data# mysql 服务器监听的 TCP/IP 端口号prot = 3306 安装 mysql 服务以管理员身份打开命令提示符，进入到 C:\mysql\bin 路径下，执行： 1$ mysqld install ！！！注意： 是 mysqld 而不是 mysql 。 此时，Win+R 运行键入 services.msc 打开服务，我们可以看到服务列表中已经有了 M有SQL 服务，说明安装成功。 初始化 data 文件夹免安装版的 M有SQL 解压安装之后，在其安装根目录下是没有 data 文件夹，需要我们手动初始化生成，这是最重要的一步。 以管理员身份打开命令提示符，进入到 C:\mysql\bin 路径下，执行： 1$ mysqld --initialize --console 执行上述命令，命令提示符会出现一堆提示信息，我们只关注最后一行的提示信息： 1[Note] A temporary password is generated for root@localhost: ****** 注意到冒号之后的字符串，那是 MySQL 为我们生成的初始密码，请记住，接下来会用到。 启动 MySQL 服务打开命令提示符，执行下面命令以启动 MySQL 服务： 1$ net start mysql 修改 MySQL 初始密码在启动了 MySQL 服务之后，键入以下命令登录到 MySQL 数据库： 1$ mysql -u root -p 回车执行上述命令时，会提示我们输入密码，把刚才 MySQL 生成的初始密码键入以登录。 一旦登录进数据之后，直接执行命令： 1SET PASSWORD = PASSWORD(&apos;这里输入你要设置的新密码&apos;); 回车执行即可完成登录密码的修改。 修改完密码之后，退出数据库，重新启动 M有SQL 服务才会生效。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多重边框]]></title>
      <url>%2F2016%2F12%2F06%2F%E5%A4%9A%E9%87%8D%E8%BE%B9%E6%A1%86%2F</url>
      <content type="text"><![CDATA[多重边框是网页设计中常见的效果，通常我们有两种方式实现它。这两种使用纯 CSS 实现的多重边框各有优缺点，需要我们根据实际自行决定选用哪一种。 box-shadowCSS3 新引入了 box-shadow 属性，用于设置元素的阴影效果。其用法如下： 1box-shadow: inset x y blur spread color; 其中： inset 为关键字值，用于设置元素的阴影类型为内阴影，可选，如果没有使用该关键字声明，则阴影类型为外阴影 x 为阴影的水平偏移值，向右为正偏移，可为负值，必需 y 为阴影的竖直偏移值，向下为正偏移，可为负值，必需 blur 为阴影的模糊程度，不可为负值，可选，单位同 CSS 长度单位 spread 为阴影向外延伸的长度，可为负值，可选，单位同 CSS 长度单位 color 为阴影颜色，必需 另外，box-shadow 支持多重阴影，只需使用逗号分隔每一重阴影即可。 如果将阴影的偏移量和模糊程度均设为 0，而给其一定的外延长度，那么我们就可以通过环绕元素的阴影来模拟多重边框，示例代码如下： 1234.multiple-border1 &#123; box-shadow: 0 0 0 10px #655, 0 0 0 15px deeppink;&#125; 需要注意的地方是，box-shadow 产生的阴影效果是层层叠加的，除了第一层阴影，后续阴影的外延均是在之前阴影的基础上扩展的。例如上述代码中的第二层阴影，虽然其外延值是 15px，但实际阴影宽度应该为 15px-10px = 5px。 这种方式在大多数时候多可以很好的工作，但有以下缺点： 阴影的行为跟真的边框不完全一致，它不会影响布局，而且也不受 box-sizing 影响。解决方法是通过内外边距来模拟出表现为边框的阴影所需要占据的空间。 阴影虽然在元素外围，但它们不会影响到鼠标事件。解决方法是使用 inset 关键字绘制为内阴影，并设置合适内边距容纳它。 outline 和 border第二种方法是使用 outline 产生描边来模拟边框，结合本来的 border 就可构成双层边框的效果。 1234.multiple-border2 &#123; border: 10px solid #655; outline: 5px solid deeppink;&#125; 这种方式虽然避免了第一种方式中阴影不占据元素盒模型宽高以及不影响实际布局的缺点，但其还是有以下不如人意的地方： 只适用于双层边框的场景 边框不一定贴合 border-radius 属性产生的圆角 是具体生产环境而定，描边有可能不是矩形 参考 《CSS揭秘》LEA VEROU 著，CSS魔法 译，人民邮电出版社]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript性能优化：（一）优化脚本加载]]></title>
      <url>%2F2016%2F12%2F04%2FJavaScript%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%EF%BC%88%E4%B8%80%EF%BC%89%E4%BC%98%E5%8C%96%E8%84%9A%E6%9C%AC%E5%8A%A0%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[JavaScript 在浏览器中的性能对于改善用户体验来说，至关重要，而这其中，首当其中的就是页面中 JavaScript 代码的加载时间。本文记述了常用的方法技巧，可以应用到实践中帮助提升 JavaScript 的加载时间。 JavaScript 代码位置大多数情况下，浏览器遇到 &lt;script&gt; 标签时，会停止渲染页面，直到完成对该脚本的读取和解析。所以，我们应该尽可能地把 &lt;script&gt; 标签置于 &lt;/body&gt; 之前。 另外，脚本位置与 &lt;link&gt; 标签位置的关系也值得我们注意： 把一段内嵌脚本放在引用外链样式表的 &lt;link&gt; 标签之后会导致页面阻塞去等待样式表的下载。这样做是为了确保内嵌脚本在执行时能获得最精确的样式信息。因此,建议永远不要把内嵌脚本紧跟在 &lt;link&gt; 标签后面。——《高性能 JavaScript》 合并 JavaScipt 文件每个 &lt;script&gt; 标签初始下载时都会阻塞页面渲染，所以一般来说，我们应该进可能地减少页面中 &lt;script&gt; 标签的数量。 对于处理以 src 属性外链 JavaScript 文件的 &lt;script&gt; 标签而言，考虑到 HTTP 请求会带来额外的性能开销，因此单独下载单个 100KB 的文件将比下载 4 个 25KB 的文件更快。也就是说，我们应该尽可能地合并多个 JavaScipt 文件，以减少页面渲染所需的 HTTP 请求数，从而提高脚本加载性能。 ！！！注意： HTTP2 标准的发布，将使得这一现状发生改变，对于使用了 HTTP2 的客户端和服务器端而言，同时下载多个文件将比单独下载一个合成文件性能开销更小。 压缩 JavaScript 文件压缩 JavaScript 源文件JavaScript 源文件越小，浏览器所用的下载时间就越少。因此，我们要想方设法地让包含源代码的 JavaScript 文件的体积尽可能地小。有三种方法可以帮助我们减小 JavaScript 源文件的体积： 缩编：将 JavaScript 源文件中所有的空格和换行符移除 混淆：使用短小精悍的名称对局部变量和局部函数进行重命名 编译：对代码进行全面分析，并对代码中的语句进行简化、缩减、整合，生成有着相同处理行为的另一语句 好在我们无需手动去做这种重复性高效率低下的工作，有许多工具可以帮助我们很好地完成以上这些工作，下面推荐几款比较流行的： JSMin UglifyJS YUI Compressor Google Closure Compiler（大多数情况下，这个工具的压缩结果最理想） 根据这些工具压缩 JavaSript 源文件的原理，我们知道，代码中使用的全局变量或函数越小，压缩后代码的体积就越小，因此在实际开发中，我们应该尽可能地减少全局变量。 JavaScript 文件的 HTTP 压缩当浏览器请求一个资源时，它通常会发送一个 Accept-Encoding HTTP 头（始于 HTTP/1.1）来告诉服务器它支持哪种编码转换类型。这个信息主要用于压缩文档以获得更快地下载，从而改善用户体验。 Accept-Encoding 可用的值包括： gzip compress deflate identity 如果 Web 服务器在 HTTP 请求中看到这些头信息，它就会选择最合适的编码方案，并通过 Content-Encoding HTTP 响应头通知浏览器它的决定。 Gzip 是目前最流行的编码方式，它通常能减少 70% 的下载量。目前几乎所有的服务器都支持启用这项设置，例如 Apache、Microsoft IIS、Node.js Express 等。 ！！！注意： 在每个请求发生时进行即时的 Gzip 编码处理会额外消耗服务器上的资源和 CPU 处理时间。另外，Gzip 压缩主要适用于文本文件，包括 JavaScript 源文件。而二进制文件，诸如图片或 PDF 文件，则不应该使用 Gzip 压缩，因为它们本身已经被压缩过了，试图重复压缩只会浪费服务器资源。 缓存 JavaScript 文件缓存 HTTP 组件能极大提高用户体验。缓存适用于大多数静态文件，Web 服务器通过 “Express HTTP 响应头” 来告诉客户端一个资源应该缓存多长时间。它的值是一个遵循 RFC1123 标注的绝对时间戳。例如：Express: Thu, 01 Dec 1994 16:00:00 GMT。 某些浏览器，特别是移动设备上的浏览器，可能会有缓存限制。这种情况下，应该权衡 HTTP 组件数量和它们的可缓存性，考虑将它们分解成更小的块。 还有一种技术是使用 HTML5 离线应用缓存，这种不展开论述了。 静态资源更新了？适当的缓存能切实提升用户体验，但它有一个缺点：当应用升级时，浏览器可能还是会从缓存中加载静态资源而不是重新向 Web 服务器请求更新之后的静态资源。 对于这个问题，我们可以通过给静态资源文件名附加时间戳来解决。 使用 CDN内容分发网络（CDN）是在互联网上按地理位置分布计算机网络，它负责传递内容给终端用户。使用 CDN 的主要原因是增强 Web 应用的可靠性、可扩展性，更重要的是提升性能。事实上，通过向地理位置最近的用户传输内容，CDN 能够极大地减少网络延时。 一般说来，大型互联网公司和一些第三方 Web 服务商都可能会提供部分的免费 CDN 服务，对于 Web 世界普遍使用的一些库和框架，我们应该尽可能地使用这些免费的 CDN 服务，以提高用户的访问速度。 无阻塞加载使用 defer 或 async 属性HTML4 为 &lt;script&gt; 标签引入了 defer 属性，而 HTML5 又为 &lt;script&gt; 标签引入了 async 属性；我们可以通过使用这两个属性来实现异步加载脚本。 12&lt;script src="" defer&gt;&lt;/script&gt; &lt;!-- 延迟加载 --&gt;&lt;script src="" async&gt;&lt;/script&gt; &lt;!-- 异步加载 --&gt; ！！！注意： 按照 HTML5 规范，defer 和 async 属性只适用于外部脚本文件。 使用了 async 和 defer 属性的 &lt;script&gt; 的脚本均是在页面下载解析过程中异步下载，不同的是： 使用了 async 属性的脚本在下载完毕后就会立刻开始执行脚本，会中断 HTML 的解析过程 使用了 defer 属性的脚本会延迟到 HTML 解析完毕之后再执行 动态添加 JavaScript我们可以动态地创建 &lt;script&gt; 标签并添加到 DOM 树中从而实现无阻塞地加载外部脚本文件，其优点是：脚本文件的下载和执行过程不会阻塞页面其他进程。 通常来将，把新创建的 &lt;script&gt; 标签添加到 &lt;head&gt; 标签里比添加到 &lt;body&gt; 标签里更保险，尤其是在页面加载过程中执行代码更是如此。当 &lt;body&gt; 标签中的内容没有全部加载完成时，IE可能会抛出一个“操作已中止”的错误消息。——《高性能 JavaScript》 下面是一个通用的动态添加脚本的函数： 123456function loadScript(url, handler) &#123; const script = document.createElement('script'); script.addEventListener('load', handler, false); script.src = url; document.head.appendChild(script);&#125; XMLHttpRequest注入通过使用 XMLHttpRequest 对象，我们也可以实现无阻塞加载外部脚本文件。 123456789101112131415161718function xhrLoadScript(url, handler) &#123; const xhr = new XMLHttpRequest(); xhr.open('get', url, true); xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; const script = document.createElement('script'); script.addEventListener('load', handler, false); script.text = xhr.responseText; document.body.appendChild(script); &#125; &#125; &#125;&#125; 传入合适的 URL 和回调函数，调用上面这段函数，结果就是创建一个带有内联脚本的 &lt;script&gt; 标签。 这种方法优点如下： 可以下载 JavaScript 代码但不立即执行 浏览器兼容性好 但有以下缺点： 请求的 JavaScript 文件必须与当前页面出于相同的源 推荐的无阻塞加载模式如果需要向页面中添加大量 JavaScript，推荐按如下方式加载： 先加载页面必需的最少代码和用于动态添加脚本的 loadScript() 函数 初始化页面之后使用 loadScript() 函数动态地加载剩余的 JavaScript 文件 参考 《高性能JavaSript》，[美]Nicbolas C.Zakas 著，丁琛 译，电子工业出版社 2015 《精通JavaSript开发》，[英]Den Odell 著，邝健威 厉海洋 译，人民邮电出版社 2015]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[同源策略]]></title>
      <url>%2F2016%2F12%2F03%2F%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%2F</url>
      <content type="text"><![CDATA[“源”的概念很早之前就有了，但其标准定义一直不够精确。 RFC 6454 定义并描述了同源策略的原则，更重要的是，推出了“源”首标。 “源”由协议、主机、端口三部分组成。在序列化形式中，“源”看起来类似 URL：协议和主机由 :// 分隔，端口前面是一个 :。对于端口与协议默认端口相同的源，端口可以省略。 由于大部分序列化源使用 80 端口，与默认的 HTTP 端口相同，所以源中通常省略端口。 下面是一个“源”的例子： 1http://example.com:8000 按照“源”的定义可分解如下： http ：协议 example.com ：主机 8080 ：端口 同源策略的原则是：如果两个源的任何一部分不同，浏览器就将它们看作完全不同的源。 ”源“标准的出现替代了之前标准化程度低、更为复杂的旧规则——”同域策略“。源模型清除了所有用于 Web 应用程序的跨域规则。 HTML5 跨文档消息传递通过允许消息在不同源之间交换，克服了同源策略的限制。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WebSocket协议]]></title>
      <url>%2F2016%2F11%2F30%2FWebSocket%E5%8D%8F%E8%AE%AE%2F</url>
      <content type="text"><![CDATA[WebSocket 是定义服务器和客户端如何通过 Web 通信的一种网络协议。组成互联网的协议组通常由 IETF（互联网工程任务组）发布。2011 年 12 月，IETF 发布 RFC，对 WebSocket 协议（RFC 6455）做出了精确地规定，其中，包含了实现 WebSocket 客户端和服务器端时必须遵循的原则。 简介WebSocket 为 Web 应用程序保留了我们所喜欢的 HTTP 特性（URL、HTTP 安全性、更简单的基于数据模型的消息和内置的文本支持），同时提供了其他网络架构和通信模式。和 TCP 一样，WebSocket 是异步的，可以用作高级协议的传输层。 WebSocket 为 Web 应用程序提供了 TCP 风格的网络能力。寻址仍然是单向的，服务器可以异步向客户端发送数据，但是只在 WebSocket 连接打开时才能做到。WebSocket 服务器也可作为 WebSocket 客户端。WebSocket 客户端不能接受不是由它建立的连接。 WebSocket 的层次在 TCP/IP 之上，更在 HTTP 之上。 下表比较了 TCP、HTTP、WebSocket 三者的主要特性： 特性 TCP HTTP WebSocket 寻址 IP地址和端口 URL URL 并发传输 全双工 半双工 全双工 内容 字节流 MIME 消息 文本和二进制消息 消息定界 否 是 是 连接定向 是 否 否 WebSocket 连接握手每个 WebSocket 连接都起始于一个 HTTP 请求。该请求类似普通的 HTTP 请求，但是其请求报文包含了一个特殊的头部字段名 Upgrade。这个字段名表示表示客户端将要把连接升级到一个不同的协议，这个协议就是 WebSocket 协议。 下面我们看一下具体的 HTTP 报文，使用 Chrome 或者 Firefox 打开 https://www.websocket.org/，在 Developer Tools 控制台输入以下代码： 1const ws = new WebSocket('wss://echo.websocket.org/echo'); 以下是上面代码发起 WebSocket 连接所产生的 HTTP 请求报文：（摘自 Firefox Developer Tools，只列出部分数据） 1234567GET /echo HTTP/1.1Host: echo.websocket.orgOrigin: https://www.websocket.orgSec-WebSocket-Version: 13Sec-WebSocket-Key: N7ZEbE8f34TK6i59o+DEGA==Connection: keep-alive, UpgradeUpgrade: websocket 下面是服务器的响应报文： 123456101 Web Socket Protocol HandshakeConnection: UpgradeDate: Sat, 03 Dec 2016 03:30:38 GMTSec-WebSocket-Appect: WfkfBi2Tlw5EBRPcaQ4ReZQdtsE=Server: Kaazing GatewayUpgrade: websocket 像这种要求升级为 WebSocket 连接的 HTTP 请求，一般称之为 WebSocket 初始握手。 与普通 HTTP 连接相比，对于 WebSocket 初始握手而言，HTTP 请求报文中还必需以下首部字段名： Sec-WebSocket-Version Sec-WebSocket-Key Upgrade ： 响应报文中必需以下首部字段名： 101 Web Socket Protocol Handshake（服务器正常成功响应的情况下） Sec-WebSocket-Appect Upgrade 在成功升级协议之后，连接的语法切换为用于 WebSocket 消息的数据帧格式。 ！！！注意 只有服务器响应 101 Web Socket Protocol Handshake、Upgarde: websocket 和 Sec-WebSocket-Accept，WebSocket 初始握手才能成功，才能建立起 WebSocket 连接。 计算响应键值为了成功地完成 WebSocket 握手，WebSocket 服务器必须响应一个由客户端计算的键值。这个响应说明服务器理解 WebSocket 协议。没有精确响应，就可能诱导 HTTP 服务器意外地升级一个连接。 Sec-WebSocket-Accept 响应头部字段名的值从客户端 Sec-WebSocket-Key 请求头部字段名继承而来，包含一个特殊的响应键值，必须与客户端的预期精确匹配。 在服务器端，响应函数会从客户端发送的 Sec-WebSocket-Key 中取得键值，并在 Sec-WebSocket-Accept 中返回根据客户端预期计算出的匹配键值。 WebSocket Sec- 首部字段名在 WebSocket 初始握手和响应键值的计算中，WebSocket 协议依靠 RFC-6455 中定义的 Sec- 首部字段名标志。下面列出了 RFC 6455 标准定义的 WebSocket Sec- 首部字段名，它们均是用于从客户端到服务器的 WebSocket 初始握手。其中有些是 HTTP 请求响应必需的，而有些是可选的。 Sec-WebSocket-Version ：表示版本兼容性。RFC 6455 的版本总是 13。(必需) Sec-WebSocket-Key ：避免跨协议攻击。在 HTTP 请求中只能出现一次。(必需) Sec-WebSocket-Accept ：确认服务器理解 WebScoket 协议。在 HTTP 响应中只能出现一次。(必需) Sec-WebSocket-Extensions ：用于初始握手过程中从服务器到客户端的响应，帮助客户端和服务器商定一组连接期间使用的协议集扩展。可能在 HTTP 请求中出现多次，但是在 HTTP 响应中只出现一次。(可选) Sec-WebSocket-Protocol ：用于初始握手过程从服务器到客户端的响应。这个首部字段名告诉客户端应用程序可以使用的协议。(可选) 消息格式Web Socket 连接所发送的消息，在网络上用二进制语法表示。这些二进制语法标记了消息的边界并包含了简介的类型信息。更准确地说，这些二进制标志字段标记了另一个单位——帧 之间的边界。帧是可以组成消息的部分数据。一个消息可以由多个帧构成，但通常来说，很少有一个消息使用超过一个帧。 下图是 WebSocket 帧的特征示意图： WebSocket 帧头的二进制代码主要负责： 操作码 长度 解码文本 掩码 多帧消息 操作码每条 WebSocket 消息都有一个指定消息载荷类型的操作码。操作码由帧头的第一个字节中最后 4bit 组成，值位数字类型。4bit 操作码共有 16 可能取值，WebSocket 协议只定义了 5 种。 操作码 消息载荷类型 描述 1 文本 消息数据类型为字符串 2 二进制 消息数据类型为二进制的 8 关闭 客户端或服务端向对方发送了关闭握手 9 ping 客户端或服务端向对方发送 ping 10(十六进制 0xA) pong 客户端或服务端向对方发送 pong 长度WebSocket 协议使用可变位数来编码帧长度。 &lt; 126 字节的消息，长度用帧头前两个字节之一表示 126 ~ 216 字节的消息，使用额外的两个字节表示 > 216 字节的消息，长度为 8 字节 长度编码保存于帧头第二个字节的最后 7bit。该字段中 126 和 127 两个值被当作特殊的信号，表示需要后面的字节才能完成长度解码。 解码文本WebSocket 文本消息使用 UTF-8 编码，这是 WebSocket 文本消息允许的唯一编码。 掩码从浏览器向服务器发送的 WebSocket 帧在实际内容之前还有一个 4字节的掩码，这是为了不常见的安全原因，以及改进与现有 HTTP 代理的兼容性。 WebSocket 协议要求客户端所发送的帧必需掩码，帧头在第二个字节的第一位表示该帧是否使用了掩码。 WebSocket 服务器接收的每个载荷在处理之前首先需要处理掩码，解除掩码之后，服务器将得到原始消息内容。二进制消息可以直接交付，文本消息将进行 UTF-8 解码并输出到字符串中。 多帧消息帧格式中的 fin 标志位考虑了多帧消息或者部分可用消息的流化，这些消息可能不连续或者不完整。fin 标志位值为 0 表示当前帧不是消息的最后一帧，fin 标志位值为 1 表示当前帧是消息的最后一帧。 WebSocket 关闭握手Web Socket 连接自身是可以在任何被关闭的，比如下层的 TCP 套接字突然关闭也会导致上层的 WebSocket 连接关闭。只有连接是由建立通信的双方在 WebSocket 层次上正常发起关闭的，那么才会以 WebSocket 关闭握手结束。 当进行 WebSocket 关闭握手时，终止连接的一端可以发送一个数字状态代码，以及一个表示关闭套接字原因的字符串。状态代码和原因编码为具有关闭操作码（8bit）的一个帧的载荷。数字代码用一个 16 位无符号整数表示，原因编码则是一个 UTF-8 编码的短字符串。RFC 6455 定义了多种特殊的关闭代码。代码 1000~1015 规定用于 WebSocket 连接层。这些代码表示网络中或协议中的某些故障。 下面列出了部分常用的 WebSocket 关闭握手代码： 代码 描述 使用场景 1000 正常关闭 会话成功完成时 1001 离开 应用程序离开且不期望后续连接尝试而关闭连接 1002 协议错误 协议错误而关闭连接 1003 不可接受的数据类型 应用程序接收到无法处理的意外类型消息 1007 无效数据 接收一个格式与消息类型不匹配的消息 1009 消息过大 接收消息太大，应用程序无法处理 1010 需要扩展 应用程序需要一个或多个服务器无法协商的特殊扩展时(客户端负责发送) 1011 意外情况 应用程序由于不可预见的原因，无法继续处理连接 1015 TLS失败(保留) 不要发送这个代码。它用于表示 TLS 在 WebSocket 握手之前失败 对其他协议的支持WebSocket 协议支持更高级的协议和协议商。在 WebSocket 客户端编程中，协议协商表现为 WebSocket 构造函数的第二个参数值。而在 HTTP 请求中，协议协商表示为可选 HTTP 首部字端 Sec-WebSocket-Protocol 的值。 服务器会根据客户端的 HTTP 请求中 Sec-WebSocket-Protocol 提供的协议来进行协议协商，然后将其选定的协议名作为 Sec-WebSocket-Protocol 的值在 HTTP 响应头中发给客户端。 扩展 不能同时协商多个协议，但是可以同时协商多个扩展。 HTTP 请求中可选的首部字段名 Sec-WebSocket-Extensions 用于扩展 WebSocket 协议，其值为所支持的扩展名称。 扩展可以为帧添加新的操作码和数据字段。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WebSocket客户端编程]]></title>
      <url>%2F2016%2F11%2F29%2FWebSocket%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%96%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[通常，浏览器访问网页时，会向页面所在的服务器发送一个 HTTP 请求。Web 服务器确认请求并向浏览器发回响应。然而大多数情况下，当浏览器显示页面时实时信息已经过时了。幸运的是，随着 WebSocket 协议标准化，我们将向这一昔日窘况挥手告别。 新建连接：实例化一个 WebSocket 对象本文主要讲述客户端编程中 WebSocket 的使用，所以不涉及服务器端配置及编码，我们就假设服务器端一切都配置好了。 为了建立一个到服务器端的连接，我们首先需要使用 WebSocket 构造函数实例化一个 WebSocket 对象： 1const ws = new WebSocket('ws://www.websocket.org'); WebSocket 构造函数第一个参数WebSocket 构造函数可接受两个参数，其中，第一个参数必须是以 ws:// 或 wss:// 开头的完全限定的 URL，如果 URL 有语法错误，调用构造函数时将会抛出异常。该参数是必须的，不可省略。 这两种 URL 方案实际上是由 WebSocket 协议标准规定的，两者区别如下： ws：传输流量未经加密 wss：在 ws 基础上使用传输层安全性 TLS（SSL）加密要传输的流量 两种 URL 方案的主要区别类似 HTTP 和 HTTPS，其中 wss 安全性更高，推荐使用，不过需要服务器端和客户端双方均支持。 WebSocket 构造函数第二个参数WebSocket 构造函数接受的第二个参数，并非必须的，其主要用于客户端和服务器端间的协议协商。 协议协商对于确定 WebSocket 服务器支持的协议及版本很有用。当应用程序支持多个协议时，我们可以通过为 WebSocket 构造函数传入第二个参数，以使用协议协商选择与特定服务器通信的协议。 该参数类型有两种可能的类型： String 类型，值为客户端和服务器端均能理解的协议 Arrary 类型，包含一组客户端支持的协议（String 类型） 1const ws = new WebSocket('ws://echo.websocket.org', ['myProtocol1', 'myProtocol2']); WebSocket 事件处理WebSocket 协议与 WebSocket API 均是事件驱动的，WebSocket 编程也遵循异步编程模式。只要 WebSocket 连接打开，应用程序就简单地监听事件。 要开始监听事件，只要为 WebSocket 事件添加回调函数即可。可以使用 addEventListener() 方法，也可以采用直接为 WebSocket 对象绑定事件处理函数的方式。 WebSocket 对象具有以下 4 个事件： open 事件一旦服务器响应了 WebSocket 连接请求，open 事件触并建立一个连接，open 事件对应的回调函数是 onopen()。 12345678ws.open = (event) =&gt; &#123; console.log('Connection open...');&#125;// 或者ws.addEventListener('open', (event) =&gt; &#123; console.log('Connection open...');&#125;, false); 到 open 事件触发时，服务器端与客户端之间的 WebSocket 协议握手已经完成，此时 WebSocket 已经准备好发送和接收数据。 message 事件message 事件在接收到消息时触发，消息内容储存于事件对象 event 的 data 属性中，该事件回调函数是 onmessage()。 1234567ws.onmessage = (event) =&gt; &#123; if (typeof event.data === 'string') &#123; console.log(`String message received: $&#123;event.data&#125;`); &#125; else &#123; console.log(`Other message received: $&#123;event.data&#125;`); &#125;&#125; 除了普通文本，WebSocket 消息内容还可以是二进制数据，这种数据作为 Blob 消息或者 ArraryBuffer 消息处理。由于设置 WebSocket 消息二进制数据类型的应用程序会影响二进制消息，所以必须在读取数据之前决定用于客户端二进制数据的类型。 12345678ws.binaryType = 'blob';ws.onmessage = (event) =&gt; &#123; if (event.data instanceof Blob) &#123; console.log(`Blob message received: $&#123;event.data&#125;`); const blob = new Blob(event.data); &#125;&#125; 上面是 Blob 消息 message 事件处理程序示例代码，下面展示一下 ArraryBuffer 消息类型的处理过程： 12345678ws.binaryType = 'arrarybuffer';ws.onmessage = (event) =&gt; &#123; if (event.data instanceof ArraryBuffer) &#123; console.log(`ArraryBuffer message received: $&#123;event.data&#125;`); const a = new Uint8Array(event.data); &#125;&#125; error 事件error 事件在响应意外故障时触发，与该事件对应的回调函数是 onerror()。错误会导致 WebSocket 连接关闭。 close 事件close 事件在 WebSocket 连接关闭时触发，对应的回调函数是 onclose()。一旦连接关闭，客户端和服务器端之间不能再继续收发消息。 close 事件对象有 3 个有用的属性： wasClean：布尔值，表示连接是否顺利关闭。如果关闭连接是对来自服务器的一个 close 帧的响应，则该属性值为 true；如果是因为其他原因关闭连接，则该属性值为 false code：服务器发送的关闭连接握手状态码 reason：服务器发送的关闭连接握手状态 WebSocket 方法WebSocket API 为 WebSocket 对象提供了两个方法供我们调用。 send()使用 send() 方法可以从客户端向服务器端发送消息。当 WebSocket 在客户端与服务器端之间建立了全双工双向连接之后，才可以在连接打开时调用 send()方法。具体来说，我们应该在 open 事件触发之后，且在 close 事件触发之前调用 send() 发送消息。 123ws.open = (event) =&gt; &#123; ws.send('Initial dat...');&#125; 除了普通文本消息，WebSocket API 还允许使用该方法发送二进制数据。 1234567const binaryBlob = new Blob('blob contents');const bianaryBuffer = new Uint8Array([8, 7, 6, 5, 4]);ws.open = (event) =&gt; &#123; ws.send(binaryBlob); ws.send(bianaryBuffer);&#125; close()通过使用 close() 方法，我们可以人为地手动关闭 WebSocket 连接或者终止连接尝试。如果连接已经关闭，那么该方法就什么都不做。 可以向 close() 方法传递两个可选参数： code：Number 类型，状态代码 reason：String 类型，文本字符串，传递一些关于关闭连接的信息 ！！！注意： 这两个可选参数与 close 事件对象的属性值一致。 123ws.onmessage = (event) =&gt; &#123; ws.clsoe(1000, 'message received');&#125; WebSocket 对象属性WebSocket API 提供了多个开发者可以访问的 WebSocket 对象的属性，这些属性都从某一方面反映了 WebSocket 连接的信息。s readyStateWebSocket 对象的 readyState 属性表示当前 WebSocket 连接状态，属性值与连接状态的对应关系如下表所示。 该属性是编程时最常使用的 WebSocket 对象属性，我们应该牢记其值所代表的 WebSocket 连接状态。 特性常量 取值 状态 WebSocket.CONNECTING 0 连接正在进行中，但还未建立 WebSocket.OPEN 1 连接已经建立 WebSocket.CLOSEING 2 连接正在进行关闭握手 WebSocket.CLOSED 3 连接已经关闭 bufferedAmountWebSocket 对象的 bufferedAmount 属性可以用检查已经进入发送队列，但是还未发送到服务器的字节数。 值得注意的是，这个属性报告的值不包括协议组帧开销或者操作系统、网络硬件所进行的缓冲。 protocolWebSocket 对象的 protocol 属性值为 WebSocket 打开连接握手期间，服务器端所选择的协议名。 protocol 属性在最初的握手完成之前为空，如果服务器没有选择客户端提供的某个协议，则该属性保持空值。 开发工具推荐 Chrome Developer Tools：监控网络流量，分析 HTTP 请求及响应头部 Firefox Developer Tools：监控网络流量，分析 HTTP 请求及响应头部 WireShark：抓取网络流量，详细分析网络协议帧、传送数据等 websocket-monitor：强烈推荐！！！Firefox 大法好。这是一个 Firefox Developer Tools 扩展，可以方便地监控 WebSocket 流量。也可以直接在 Firefox Add-ons 下载：https://addons.mozilla.org/en-US/firefox/addon/websocket-monitor/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo教程：（四）将本地Hexo站点部署到GitHubPages]]></title>
      <url>%2F2016%2F11%2F16%2FHexo%E6%95%99%E7%A8%8B%EF%BC%9A%EF%BC%88%E5%9B%9B%EF%BC%89%E5%B0%86%E6%9C%AC%E5%9C%B0Hexo%E7%AB%99%E7%82%B9%E9%83%A8%E7%BD%B2%E5%88%B0GitHubPages%2F</url>
      <content type="text"><![CDATA[Hexo 支持一键部署到 GitHub 仓库，所以我们可以使用 Hexo 结合 GitHub Pages 来搭建在线个人博客。 本地 Git 客户端本地 Git 客户端配置，主要是为了能够在命令行模式下与远程的 GitHub 通信。 Git配置打开命令行，键入以下命令： 12$ git config --global user.name "你的用户名"$ git config --global user.email "你的email" 其中，字符串中的内容替换为你自己的信息，这里为了清晰一致，建议使用 GitHub 账户相同的配置信息。 创建 SSH Key打开安装好的 Git Bash，键入： 1$ git gui 回车之后，会启动 Git GUI 软件。在 Git GUI 软件界面，依次点击 Help =&gt; Show SSH Key 在出现的 OpenSSH 界面，点击右上角的 Generate Key 以创建 SSH Key。注意，期间会让你输入密码两次，这个密码是本地 Git 与远程 Git 通信时要用到的，要牢牢记住。 OpenSSH 创建好的 SSH Key，会被存储到为一个私钥文件和一个公钥文件；如果是 Windows 操作系统的话，则他们位于 ./c/Users/pcusername/.ssh 路径下，名称分别是 id_rsa 和 id_rsa.pub。 远程 GitHub创建github.io仓库登入你自己的 GitHub 账户，创建一个新的仓库，仓库名为 username.github.io，其中 username 替换为你自己的 GitHub 用户名，就是你个人 GitHub 主页 URL 中的最后一部分。 创建好仓库后，做一次初始提交，以便初始化这个仓库。 配置 SSH Pub Key打开你的 GitHub 个人主页，点击右上角个人头像，选择 Settings，进入设置页面。 在左侧选择 SSH and GPG keys，然后在右侧点击 New SSH key，将刚刚创建的 SSH Key 的公钥文件 id_rsa.pub 中的内容复制到 Key 文本框中。 本地 Git 与远程 GitHub 通信上面配置都搞定以后，我们来测试一下 Git 是否可以和我们远程的 Git 仓库通信。 命令行键入以下命令： 12$ ssh -T git@github.comEnter passphrase for key '/c/Users/pcusername/.ssh/id_rsa': 当键入以上命令回车后，会出现让我们输入密码的提示，这个密码就是刚刚我们使用 Open SSH 创建 SSH Key 时所输入的密码。 注意！！！ 输入密码时冒号之后什么也不会显示，所以你只管输入就行，正确无误后按下回车键即可。 如果成功连接，会出现提示信息： Hi your-github-username! You’ve successfully authenticated, but GitHub does not provide shell access. Hexo依赖为了正常部署到远程 Git 仓库，我们还需要先安装一个 Hexo 插件 hexo-deployer-git。 在站点文件夹根目录下打开命令行，键入以下命令： 1$ npm install hexo-deployer-git --save 配置由于是部署到远程的 Git 仓库，所以我们需要修改一些配置参数以使其符合针对 Git 的部署配置。 使用文本编辑器打开站点文件夹根目录下的 _config.yml 文件，修改其 deploy 字段之后的内容： 12345deploy: type: git repo: git@github.com:你的GitHub用户名/你的GitHub用户名.github.io.git brandh: master messge: 其中，各个参数意义如下： repo ：要部署的远程 Git 仓库地址 branch ：仓库分支名称，程序会自动检测，如果你创建的仓库没有做过修改，那么该值应该就是master message ：自定义 Git 的本次 commit 信息（Hexo会按照一定默认生成） 部署如果我们已经生成好了本地静态站点，那么只需下面的命令，即可将其一键部署到服务器上。使用安装好的 Git Bash 终端，在站点根目录下键入： 1$ hexo deploy !!!注意： 以上命令一定要在 Git Bash 终端中键入，因为我们使用的 SSH 协议推送本地仓库到远程分支，必需使用到 Git Bash 内置的 Open SSH 客户端。在此期间，会跳出 Open SSH 的界面，让我们输入密码，就是之前我们用来加密 SSH Key 的在命令行输入的那个密码。 现在，打开 GitHub Pages 看一下效果吧。 完成后部署我们可以让 Hexo 在生成完毕后自动部署网站到服务器，只需使用以下两个命令之一即可： 12$ hexo generate --deploy$ hexo deploy --generate 上面这两个命令是等价的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo教程：（三）使用Hexo写博客]]></title>
      <url>%2F2016%2F11%2F16%2FHexo%E6%95%99%E7%A8%8B%EF%BC%9A%EF%BC%88%E4%B8%89%EF%BC%89%E4%BD%BF%E7%94%A8Hexo%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[尽管 Hexo 支持 MarkDown，但是我们却不能像写单独的 MarkDown 文档时那样肆无忌惮。由于我们所写的文档是需要被解析为静态网页文件的，所以我们必须严格遵从 Hexo 的规范，这样才能解析出条理清晰的静态网页文件。 新建文档假设我们的文章名为 “hello hexo markdwon”，在命令行键入以下命令即可： 1$ hexo new "hello hexo markdown" 上述命令的结果是在 ./hexo/source/_posts 路径下新建了一个 hello-hexo-markdown.md 文件。 然后，我们就可以打开编辑器尽情地写作了。 文档格式我们使用文本编辑器打开刚刚新建的 hello-hexo-markdown.md 文件，会发现其中已经存在内容： 12345---title: hello hexo markdowndate: 2016-11-16 18:11:25tags:--- 这些内容是干嘛的呢？事实上，他们就是用于设置 MarkDown 文档在被解析为静态网页文件时的相关配置，这些配置参数一般位于文件中最上方以 --- 分隔的区域。 其中，title 的值是当前文档名，也是将来在网页中显示的文章标题。 date 值是我们新建文档时的当地时区时间。 tags 值是文档的标签，我们可以随意赋值为文档贴标签。其用法如下： 12345678---title: hello hexo markdowndate: 2016-11-16 18:11:25tags:- hello- hexo- markdown--- 上面的配置参数为这篇文档贴上了 hello、hexo、mardown 标签，如果站点使用的主题支持标签功能，MarkDown 文档被解析为静态网页文件后就可以看到效果。 除了以上这些，还有很多预先定义的参数 Front-mtter，我们这里选取一个常用且较为典型的配置参数 categories 讲解一下。 文章分类categories 是用来给文章分类的，它跟 tags 不同的是其具有顺序性和层次性。 例如，我们写一篇关于 CSS3 动画的文章，我们可能会为其打标签 ”CSS3“、”动画“等，但是我们却会将其分在 CSS/CSS3 类别下，这个是有一定的相关性、顺序性和层次性。简单来说，categories 有点儿像新建文件夹对文档进行分门别类的归置。 categories 的用法同 tags 一样，只不过斗个 categories 值是分先后顺序的。 引用资源写个博客，有时候我们会想添加个图片啦 O.O，或者其他形式的资源，等等。 这时，有两种解决办法： 使用绝对路径引用资源，在 Web 世界中就是资源的 URL 使用相对路径引用资源 文章资源文件夹如果是使用相对路径引用资源，那么我们可以使用 Hexo 提供的资源文件夹功能。 使用文本编辑器打开站点根目录下的 _ config.yml 文件，将 post_asset_folder 值设置为 true。 1post_asset_folder: true 上面的操作会开启 Hexo 的文章资源文件管理功能。Hexo 将会在我们每一次通过 hexo new &lt;title&gt; 命令创建新文章时自动创建一个同名文件夹，于是我们便可以将文章所引用的相关资源放到这个同名文件夹下，然后通过相对路径引用。 相对路径引用的标签插件通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。我们可以通过使用 Hexo 提供的标签插件来解决这个问题： 123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](/example.jpg) ，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作） ！！！注意： 如果已经开启了文章的资源文件夹功能，当使用 MarkDown 语法引用相对路径下的资源时，只需 ./资源名称，不用在引用路径中添加同名文件夹目录层级。 正确的引用图片方式是使用下列的标签插件而不是 markdown ： 1&#123;% asset_img example.jpg This is an example image %&#125; 通过这种方式，图片将会同时出现在文章和主页以及归档页中。 文章摘要有的时候，主题模板配置的不够好的话，Hexo 最终生成的静态站点是不会自动生成文章摘要的。 所以，为了保险起见，我们也自己手动设置文章摘要，这样也方便避免自动生成的摘要不优雅的情况。 设置文章摘要，我们只需在想显示为摘要的内容之后添 &lt;!-- more --&gt; 即可。像下面这样： 1234567891011121314---title: hello hexo markdowndate: 2016-11-16 18:11:25tags:- hello- hexo- markdown---我是短小精悍的文章摘要(๑•̀ㅂ•́)و✧&lt;!-- more --&gt;紧接着文章摘要的正文内容 这样，&lt;!-- more --&gt; 之前、文档配置参数之后中的内容便会被渲染为站点中的文章摘要。 注意！文章摘要在文章详情页是正文中最前面的内容。 生成文件清除缓存文件为了避免不必要的错误，在生成静态文件前，强烈建议先运行以下命令： 1$ hexo clean 上述命令会清除本地站点文件夹下的缓存文件（db.json）和已有的静态文件（public）。 生成静态文件写好 MarkDown 文档之后，我们就可使用以下命令生成静态文件： 1$ hexo generate 然后我们就可以启动 Hexo 服务器，使用浏览器打开 http://localhost:4000 查看效果了。 示范下图是一篇经过配置的简单文档，生成静态文件后在网站首页显示的结果。我们可以看到手动设置的摘要，以及打的标签生效了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo教程：（二）Hexo站点配置]]></title>
      <url>%2F2016%2F11%2F16%2FHexo%E6%95%99%E7%A8%8B%EF%BC%9A%EF%BC%88%E4%BA%8C%EF%BC%89Hexo%E7%AB%99%E7%82%B9%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[Hexo 所初始化的站点文件夹根目录下的 ._config.yml 文件声明了网站的配置信息，我们可以通过修改此文件的配置参数以个性化网站。 配置文件_config.ymlHexo 生成的网站的配置信息均保存在 ._config.yml 文件中，该文件位于站点文件夹下的根目录下。 我们可以通过修改 ._config.yml 文件中的参数配置来自定义 Hexo 生成的静态站点。 使用文本编辑器打开该文件，我们会发现其中有详尽的参数，这里只选取一部分具有代表性的参数配置进行介绍。详情戳这里 ⇨ 配置。 网站相关 title ：网站标题 subtitle ：网站副标题 description ：网站描述 author ：作者名字 网址相关 url ：网址 root ：网站根目录 文章相关 auto_spacing ：在中文和英文之间加入空格，默认值为 false external_link ：在新标签中打开链接，默认值为 true render_drafts ：显示草稿，默认值为 false post_asset_folder ：开启文章地资源管理文件夹，默认值为 false highlight ：代码块的设置，包括有 enable、line_number、auto_detect 和 tab_replace 属性可设置。不过一般不用修改，大多数主题都默认是支持代码语法高亮等设置的。 分页相关 per_page ：每页显示的文章数，默认值为 10，值为 0 时会关闭分页功能 新建菜单页Hexo 生成的站点默认菜单也有限，如果我们想自定义添加菜单页该怎么操作呢？比如说，我们想新建一个名为 Abou 的菜单页。 站点根目录下，命令行中输入： 1$ hexo new page "about" 上面的命令生效以后，根目录下的 source 文件夹中会新增一个名为 about 的文件夹，里面有个 index.md 文档。我们将想要在 About 菜单页中显示的内容，按照博文格式写在这个文档里即可。 然后，修改 ./themes/your-theme-name/_config.yml 文件中的 menu 项，在下面添加一行 About: /about 即可。 示范下图是我修改了网站相关配置参数值之后的网站首页，可以很明显地看出与网站标题与副标题发生了变化。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo教程：（一）安装及使用初体验]]></title>
      <url>%2F2016%2F11%2F16%2FHexo%E6%95%99%E7%A8%8B%EF%BC%9A%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
      <content type="text"><![CDATA[Hexo 是一个由 Node.js 驱动的快速、简洁、高效的博客框架。Hexo 具有许多优点，使用它我们可以快速地搭建自己的本地博客站点，并能将其推送到 GitHub 仓库。这篇文章简单介绍了 Hexo 地安装及初次使用。 安装前提 Git Node.js 此处不再赘述以上二者的安装过程，点击链接去官网下载与自己操作系统对应的版本，按照默认配置一步步安装即可。 安装完之后，命令提示符输入以下命令检测是否成功安装： 12$ git --version$ node --version 出现上图所示的提示信息，即成功安装 Git 和 Node.js，如此，方可进行后续操作。 安装 Hexo在命令行输入以下命令，以将 Hexo 安装到全局环境： 1$ npm install hexo-cli -g 成功安装后，会出现诸如 -- hexo-cli@1.0.2 的提示信息。 注意！提示信息末尾可能会出现 npm WARN 警告信息，不过不要怕，那不会影响使用的，只要不是 npm ERROR 错误消息就好 (^_^)！ 初始化站点文件夹接下来，我们将运行命令初始化一个新的文件夹，作为我们的本地站点： 1$ hexo init hexo 以上命令将先在当前路径下新建一个名为 hexo 的文件夹，然后 Hexo 会对其初始化，即从远程 git 仓库 clone 站点所需的文件。 接着，进入新建的站点文件夹 hexo，继续安装站点文件所需的 npm 包依赖： 12$ cd hexo$ npm install 现在，我们文件夹的目录结构看起来应该像下面这个样子： 123456789101112.|—— node_modules|—— scaffolds|—— source| |—— _posts|—— themes| |—— landscape|—— .gitignore|—— .npmignore|—— _config.yml|—— db.json|—— package.json 安装服务器Hexo 3.0 把服务器独立成了个别模块，我们必须得在站点文件夹根目录下安装之后才能使用。 在命令行中打开我们的 hexo 文件夹，键入以下命令，以将 hexo-server 安装到我们的 hexo 文件夹： 1$ npm install hexo-server --save Hexo站点初体验接下来，我们演示一下 Hexo 生成的静态站点。 别担心，尽管到现在为止我们一篇文章也没写，而且站点主题也没经过任何配置，但还是会看到效果的。因为 Hexo 初始化的全新站点文件夹有一个内置的默认主题样式，同时也有一篇 Hello World 文章。 清除缓存文件1$ hexo clean 此命令用于清除缓存文件（db.json）和已生成的静态文件(public)。 生成静态文件1$ hexo generate 此命令用于生成静态文件，就是按照主题的模板文件配置将 markdown 文件生成为静态 html 文件。 此命令可简写为 hexo g。 当运行上述命令后，我们站点文件夹的目录结构下会多出一个 public 文件夹，这个文件夹中的文件就是 Hexo 帮我们生成的站点静态文件。 启动服务器1$ hexo server 此命令会启动 Hexo 服务器，可简写为 hexo s。 默认状态下，我们的网站是运行在 http://localhost:4000 ，使用浏览器打开这个地址就可看到效果。 看！⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣ 这就是 Hexo 在本地生成的站点效果 (●’◡’●)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6之模块]]></title>
      <url>%2F2016%2F11%2F04%2FES6%E4%B9%8B%E6%A8%A1%E5%9D%97%2F</url>
      <content type="text"><![CDATA[ES6 终于将模块写进了标准，JavaScript 也终于有了自己的模块机制。 ES6的模块自动采用严格模式。 export命令export 命令用于规定模块的对外接口。JavaScript中，一个 .js 文件就是一个模块。文件内部的所有变量，外部无法获取，如果希望外部能够使用模块内部的变量，就需要使用 export 关键字导出。 123// first.jsexport const a = 0;export const b = 1; 上面代码是 first.js 文件，ES6将其视为一个模块，我们使用 export 关键字导出了两个变量。 export 命令还可写成以下形式： 123const a = 0;const b = 1;export &#123; a, b &#125;; 推荐此种写法，清晰明了，提高代码可读性。 通常情况下，expore 关键字导出的变量就是其在模块内部的名字，不过我们可以使用 as 关键字在导出时进行重命名。 1234export &#123; a as a0, b as b1&#125;; 关于 export 命令的使用需要注意以下几点： export 命令规定的是当前模块的对外接口，必须与模块内部的变量建立一一对应关系，也就说我们不能直接使用 export 关键字导出原始值与变量名 export 命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于某个块级作用域内，就会报错。 import命令当使用 export 命令定义了某个模块的对外接口后，我们便可以在其他 .js 文件中使用 import 命令加载这个模块导出的变量。 1import &#123; a, b &#125; from "./first"; 使用 import 命令时，文件名后缀 .js 可以省去。 同 export 命令类似，我们也可以在导入另一个模块的变量时对其进行重命名： 1import &#123; a as a0 &#125; from "./frist"; 整体加载除了逐一导入另一模块的各个变量，我们还可以使用整体加载的方式，即使用 * 指定一个对象，将导入的值都加载这个对象上。 12// first.jsexport &#123; a, b &#125;; 普通加载方式如下： 1import &#123; a, b &#125; from "./first"; 整体加载方式如下： 1import * as first from "./first"; export defaultexport default 用于为当前模块指定默认导出，其本质上相当于把要导出的值赋值给一个名为 default 的变量，然后使用 export 命令导出这个 default 变量。这种语法的意义在于，当在另一模块中导入相关值时，无需使用此模块的导出变量名。 12// first.jsexport default a; 123// second.jsimport xxx from "./first"` export default 命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此 export default 命令只能使用一次。所以 import 命令后才可不用加大括号，因为只可能对应一个值。 参考 《深入浅出ES6》 by InfoQ 《ECMAScript 6入门》 by 阮一峰]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6之Generator对象]]></title>
      <url>%2F2016%2F11%2F04%2FES6%E4%B9%8BGenerator%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[生成器真是 ES6 中了不起的一项特性 基本概念1234567function* sayHi(name) &#123; yield `Hello! $&#123;name&#125;`; yield `This is ES6 Generator`; yield `ByeBye!`; let sum = 3 + 5; return sum;&#125; 上面这段代码看起来很像一个函数，我们称之为生成器函数，它与普通函数有很多共同点，主要区别如下： 普通函数使用 function 声明，而生成器函数使用 function* 声明 生成器函数体内部，有一种类似 return 的语法：关键字 yield 。二者区别是普通函数只可以 return 一次，而生成器函数可以 yield 多次。在生成器的执行过程中，遇到 yield 表达式立即暂停，后续可恢复执行状态 当需要调用 Generator 函数，我们可以像下面这样： 123456let message = sayHi('sam');message.next(); // Object &#123; value: "Hello! sam", done: false &#125;message.next(); // Object &#123; value: "This is ES6 Generator", done: false &#125;message.next(); // Object &#123; value: "ByeBye", done: false &#125;message.next(); // Object &#123; value: 8, done: true &#125;message.next(); // Object &#123; value: undefined, done: true &#125; 调用 Generator 函数，它并非立即开始运行，而是返回一个已暂停的 Generator 对象（在上面代码中就是 message）。 然后，我们可以调用 Generator 对象的 .next() 方法，以执行函数体内的代码。 Generator对象的 next() 方法语执行逻辑如下： 正常执行函数体内的代码，遇到 yield 语句，就暂停执行后面的操作，并将紧跟在 yield 关键字后面的那个表达式的值作为返回对象的 value 属性值，返回对象同时还有一个 done 属性值，如果当前执行的代码不是函数体内最后一条语句，done 属性值就为 false，否则 done 属性值为 true。 继续调用 next() 方法时，继续执行函数体内后续代码，直到遇到下一个 yield 语句，重复步骤 1 中的执行逻辑 如果没有遇到新的 yield 语句，就一直执行到函数体结束 如果函数有 return 语句，将 return 语句表达式的值做为返回对象的 value 属性值 如果函数没有 return 语句，返回对象的 value 属性值设置 undefined 当函数体内所有代码都执行完毕时，再调用 Generator 对象的 next() 方法总是返回 { value: undefiend, done: true} 与 Iterator 接口的关系任意一个对象的 Symbol.iterator 方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。 由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的 Symbol.iterator 属性，从而使得该对象具有 Iterator 接口 Generator函数执行后，返回一个遍历器对象。该对象本身也具有 Symbol.iterator 属性，执行后返回自身。 next() 方法的参数yield 语句本身没有任何返回值，或者说总是返回 undefiend 。 Generator 对象的 next() 方法可以带一个参数，该参数就会被当作上一个 yield 语句的返回值。 for…of 循环for...of 循环·可以自动遍历 Generator 函数调用生成的 Iterator 对象。 12345678910function* foo() &#123; yield 1; yield 2; yield 3; return 4;&#125;for (le i of foo()) &#123; console.log(i);&#125; // 1 2 3 4 Generator.prototype.throw()Generator 函数返回的遍历器对象，都有一个 throw 方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获 thorw 方法可以接受一个参数，该参数会被 catch 语句接受，建议抛出 Error 对象的实例。 Generator.prototype.return()Generator 函数返回的遍历器对象，还有一个 return() 方法，可以接受参数，指定返回对象的 value 属性值，并且终止遍历 Generator 函数。如果调用 return() 时不传入参数，那么返回对象的 value 属性值为 undefined. yield*如果在一个 Generator 函数内部调用另一个 Generator 函数，需要使用 yield* 语句。 1234function* bar() &#123; yield* foo();&#125;function* foo() &#123;&#125; 作为对象属性的 Generator 函数如果一个对象的属性是 Generator 函数，可以简写： 1234567let obj = &#123; * test() &#123;&#125;&#125;// 等价于let obj = &#123; test: function*() &#123;&#125;&#125; Generator 函数的 thisGenerator函数总是返回一个遍历器，ES6规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的 prototype 属性所指向对象上的方法。 Generator 函数不可与 new 命令一起使用，否则会报错。 参考 《深入浅出ES6》 by InfoQ 《ECMAScript 6入门》 by 阮一峰]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6之Class]]></title>
      <url>%2F2016%2F11%2F04%2FES6%E4%B9%8BClass%2F</url>
      <content type="text"><![CDATA[关于 ES6 种新引入的 Class，争执已久，支持和反对的各有一套说辞，但不管怎么说，后来者从来只管用新特性，并不关心这些事儿。殊不知，Class 的背后依然还是 Prototype 原型链结构。 基本语法ES6引用的 class 语法本质上来说是 JavaScript 中已有创建对象方式及原型链继承的语法糖。下面 ES6 代码中的 Person 类本质上相当于 ES5 中的构造函数 Person()。 12345678class Person &#123; constructor(name) &#123; this.name = name; &#125; toString() &#123; return `$&#123;this.name&#125;`; &#125;&#125; 上面的代码定义了一个 “类”。使用 class 的语法规则如下： 每一个 class 必须声明一个 constructor 方法，当通过 new 类名生成对象实例时，会自动调用该方法；如果没有显式定义，那么将会默认添加一个空的 constructor 方法 类内部的方法声明无需使用 function 关键字，且全都被定义在 property 对象上面 类内部的方法声明之间无需使用逗号分隔 类内部定义的所有方法都是不可枚举的 类内部的 this，默认指向类的实例 使用类创建新的实例对象时，必须使用 new 命令调用类名 class 关键字声明的类在作用域中没有变量提升 类具有 name 属性，其值为类名 class表达式我们也可以使用表达式的方式来定义一个类： 12345const Person = class Them &#123; constructor(name) &#123; this.name = name; &#125;&#125;; 这种情况下，class 关键字后面的类名只在类的内部有效。当然，如果用不到，我们也可以省去 class 后面的类名，这跟匿名函数表达式相似： 12345const Person = class &#123; constructor(name) &#123; this.name = name; &#125; &#125; Class的继承Class之间可以使用 extends 关键字实现继承： 123456789class Student extends Person &#123; constructor(name, subject) &#123; super(name); this.subject = subject; &#125; toString() &#123; return `$&#123;super.toString()&#125; $&#123;this.subject&#125;`; &#125;&#125; 使用 extends 关键字实现继承时，语法规则如下： 子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错，这里的 super 关键字表示的方法为父类的构造函数。子类没有自己的 this 对象，调用 super 方法是为了继承父类的 this 对象 在子类的 constructor 方法中，只有调用 super 之后才可以使用 this 关键字。这是因为子类实例的构建，是基于对父类实例的加工，只有 super 方法才能返回父类实例 两条继承链Class作为构造函数的语法糖，同时拥有 prototype 属性和 _proto_ 属性，因此同时存在两条继承连： 子类的 [[Prototype]] 属性，表示构造函数的继承，总是指向父类 子类的 prototype 属性的 [[Protoype]] 属性，表示方法的继承，总是指向父类的 prototype 属性 继承目标extends 关键字后面可以跟多种类型的值： 1class B extens A &#123;&#125; 上面代码中的 A ，只要是一个有 prototype 属性的函数，就能被 B 继承。 判断继承关系Object.getPrototypeOf() 方法可以用来获取子类的父类 super关键字super 关键字有两种用法，含义不同： 作为函数调用时，super 表示父类的构造函数 作为对象调用时，super 代表父类。此时，super 既可以引用父类实例的属性和方法，也可引用父类的静态属性和方法。 Class的 getter 和 settter与 ES5 一样，在 Class 内部可以使用 get 和 set 关键字，对某个属性设置存值函数和取值函数。 Class的 Gernerator 方法如果在某个方法之前加上 * ，就表示该方法是一个 Generator 函数。 Class的静态方法静态方法指的是 Class 本身的方法。 在 Class 内部声明的方法之前加上 static 关键字，就可声明一个类的静态方法。只可以使用类名调用。 父类的静态方法可以被子类继承 静态方法也可从 super 对象上调用。 Class的静态属性和实例属性new.target 属性ES6 为 new 命令引用了一个 new.taret 属性（在构造函数中），其值为 new 命令作用于的那个构造函数。如果构造函数不是通过 new 调用的，那么将返回 undefined。 注意：此属性只能在函数内部使用。 参考 《深入浅出ES6》 by InfoQ 《ECMAScript 6入门》 by 阮一峰]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6之Function]]></title>
      <url>%2F2016%2F11%2F04%2FES6%E4%B9%8BFunction%2F</url>
      <content type="text"><![CDATA[ES6 为函数引入了很多新特性，本文将一一总结。 函数参数的默认值ES6允许为函数的形参设定默认值，示例如下： 1function foo(a = 0, b = 1) &#123;&#125; 与解构赋值的默认值类似，默认值生效条件为传入的实参值为 undefined。 通常情况下，定义默认值的形参应该是函数的尾参数，代码可读性高，而且传入实参时也可只省略此参数。如果有默认值的参数不是尾参数，那么再传入实参时无法只省略此参数。所以最佳实践是将定义了默认值的参数写在函数的形参列表末尾。 有一点需要注意的是，指定了形参默认值后，函数的 length 属性会失效。其将返回没有指定默认值形参个数，另外如果设置了默认值的形参不是尾参数，那么 length 属性值也不计入后续形参。 rest参数ES6引入了 rest参数，形式为 ...变量名， 用于获取函数的多余参数，这样就不需要使用 arguments 对象了。rest参数 搭配的变量是一个数组，该变量将多余的参数放入数组中。 12345678function add(...values) &#123; let sum = 0; for (let val of values) &#123; sum += val; &#125; return sum;&#125;add(1, 2, 3) // 6 有了 rest参数 之后，多数场景下我们就不需要使用 arguments 对象了。并且 rest参数 中的变量是一个数组，所有数组特有的方法都可用于这个变量。 需要注意的有以下几点： rest参数 之后不能再有其他参数，否则会报错。 函数的 length 属性值不包括 rest参数 扩展运算符（…）扩展运算符是三个点 ...。它就好比是 rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。 12// 等价于 console.log(0, 1, 2)console.log(...[0, 1, 2]); // 0 1 2 有了该运算符，我们就不再需要 apply() 方法，将数组转换为函数参数了。 本质上来说，任何实现了 Iterator 接口的对象，都可以使用扩展运算符转为真正的对象。 name属性函数的 name 属性，返回该函数的函数名。这一点直到 ES6 才终于写入了标准。 需要注意的有以下几点： ES5中，如果将一个匿名函数赋值给一变量，其 name 属性会返回空字符串，而 ES6 中 name 属性则会返回变量名称。 12345const f = function() &#123;&#125;;// ES5f.name // ""// ES6f.name // "f" Function 构造函数返回的实例，name 属性的值为 anonymous bind() 调用返回的新函数，name 属性值会加上 bound 前缀 箭头函数ES6 允许使用 =&gt; 定义函数： 1const add = (num1, num2) =&gt; &#123; return num1 + num2; &#125;; 上面的箭头函数等同于： 123const add = function(num1, num2) &#123; return num1 + num2;&#125; 从上面可以看出定义箭头函数的规则： 赋值号左侧为函数名称 赋值号右侧（即箭头左侧）为参数列表 箭头右侧为函数体内的代码块 如果箭头函数不需要形参或需要多个形参，就是用一个圆括号包裹参数部分。如果箭头函数的代码块部分多余一条语句，就要使用大括号括起来，并且使用 return 语句返回。 如果函数的形参列表和函数体比较简单，箭头函数也可以省略圆括号、大括号和 return 关键字： 12345const f = a =&gt; a;// 等价于const f = function(a) &#123; return a;&#125; 这种方式有一点需要注意：返回一个对象时，应该使用圆括号将对象括起来，因为 JavaScript 引擎会将大括号解释为代码块的开始。 使用箭头函数时需要注意以下几点： 箭头函数体内的 this 对象，就是定义时所在作用域的 this，并非执行时的上下文 箭头函数不可用作构造对象，即不可使用 new 关键字调用箭头函数 箭头函数体内不存在 arguments 对象，如果需要，请使用 rest参数 箭头函数不可使用 yield 命令，因此不能用作 Generator 函数 参考 《深入浅出ES6》 by InfoQ 《ECMAScript 6入门》 by 阮一峰]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6之迭代器与for...of循环]]></title>
      <url>%2F2016%2F11%2F04%2FES6%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8Efor-of%E5%BE%AA%E7%8E%AF%2F</url>
      <content type="text"><![CDATA[迭代器是 ES6 种非常特殊的一个东西。 Iterator(迭代器)Iterator是一种接口，为各种不同的数据结构提供了统一的访问机制，即for...of循环。任何数据结构只要部署了Iterator接口，就可以完成遍历操作，即依次访问该数据结构的所有成员。 ES6规定，默认的Iterator接口部署在对象的Symbol.iterator属性。这些拥有Symbol.iterator的对象被称为可迭代的。在ES6中，有四类数据结构原生具有Symbol.iterator属性，可以直接使用for...of循环进行迭代操作：数组、某些类数组对象、Set和Map。 如果想让一个对象可以被for...of循环遍历，就必须在其Symbol.iterator属性上部署迭代器生成方法（原型链上的对象具有该方法也可）。 for…of循环ES6之前，JavaScript中只有for...in 循环，但是这个循环不仅缺点多多，而且本质上是遍历对象属性的键名，所以无法用来遍历数组等非普通对象的数据结构。 现在，横空出世的for...of 循环改变了这一混乱现状，它不仅支持遍历数组，而且还支持大多数类数组对象，当然，同样支持Set和Map。 这种遍历的背后原理是：for...of循环首先会调用部署在对象Symbol.iterator属性上的方法，紧接着返回一个新的迭代器对象。迭代器对象可以是任意具有.next() 方法的对象；然后for...of循环将重复调用这个方法，将指针逐次移向对象的下一个成员。 每一次调用.next()方法，都返回对象当前成员的信息。具体来说，就说返回一个包含value和done 两个属性的对象。其中，value属性是当前成员的值，done 属性是一个布尔值，表示迭代是否完成。 参考 《深入浅出ES6》 by InfoQ 《ECMAScript 6入门》 by 阮一峰]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6之Set/Map]]></title>
      <url>%2F2016%2F11%2F03%2FES6%E4%B9%8BSet-Map%2F</url>
      <content type="text"><![CDATA[Set 和 Map 是 ES6 新引入的两种数据结构，有了这两个数据结构，我们再也不用使用 Array 到处模拟集合和字典了。 Set一个Set是一群值的集合，它是可变的，能够增删元素。就像数学科学中的“集合”概念，一个Set的成员是无序且唯一的。也就是说，Set中没有相同元素，也不提供对值的索引。 Set() 函数可以用来生成Set数据结构，但其只接受可遍历数据做参数，例如数组、字符串等。 12let set1 = new Set([0, 0, 1, 1, 2, 3, 4]);set1; // Set &#123; 0, 1, 2, 3, 4 &#125; 由于集合Set是不支持索引的，所以Set中没有传统键值对的键名概念。在遍历Set时，传统意义上的键名的值使用当前元素的实际键值。还有一点需要注意，遍历Set的顺序是各个元素插入的顺序。 Set支持的所有操作如下： new Set()：创建一个新的、空的Set new Set(iterable&lt;T&gt;)：从任何可遍历数据中提取元素，构造一个新的Set set.size：返回集合set中元素的个数 set.has(value)：判断集合set中是否存在给定值，返回一个布尔值 set.add(value)：向集合set中添加元素，如果与已有元素重复则无效果（Set实例中只能存在一个NaN，另：所有对象被认为不相等），返回集合set本身 set.delete(value)：删除集合set中的给定值，返回一个布尔值，表示操作是否成功 set.clear()：清空集合set set.forEach(fun(key, value, set){ }) ：类似数组的 forEach() 方法，对set的每个元素调用处理函数进行操作，该函数接受三个参数：当前键名、当前键值、集合本身。 set.keys() set.values() set.entries() 分别返回遍历set所有元素的键名、键值、键值对的迭代器 Map一个 Map对象由若干键值对组成，它本质上是键值对的集合，类似于传统对象。与Set类似，Map对象的键名唯一且不支持索引。遍历Map时也是按照其元素的插入顺序进行。 12let map1 = new Map([["name", "lfkid"], ["age", 21]])；map1 // Map &#123; 'name' =&gt; 'lfkid', 'age' =&gt; 21 &#125; Map支持的所有操作如下： new Map() ：返回一个新的、空的Map new Map(Iterable&lt;Array&gt;)：根据形如[key, value]的数组组成的二维数组创建一个新的Map实例 map.size：返回map中键值对的个数 map.has(key)：判断给定键名是否存在，返回一个布尔值 map.get(key)：给定键名，返回其对应的键值，若键名不存在则返回undefined map.set(key, value)：添加一个新的键值对，若键名已存在则更新键值，返回map本身 map.delete(key)：按给定键名从map中删除键值对，返回一个布尔值 map.clear()：清空map map[Symbol.iterator]()：返回遍历所有项的迭代器，每项用一个由该项键和值构成的二元数组表示，本质上调用的就是map.entries() map.forEach(function(key, value, map) { })：同数组的forEach()方法类似 map.keys() map.values() map.entries() ：分别返回遍历map所有键名、键值、项的迭代器 WeakSet和WeakMapWeakSet和WeakMap与Set和Map类似，也是不能重复的值的集合。但是，它们与Set和Map有以下区别： WeakSet的值和WeakMap的键只能是对象 WeakSet只支持new has add delete 操作 WeakMap只支持new has get set delete 操作 WeakSe和WeakMap属于弱集合，都不可迭代 WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用。也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。 WeakMap中的对象都是弱引用，即垃圾回收机制不考虑WeakMap对该对象的引用。键名对应的对象被自动回收后，WeakMap会自动移除对应的键值对。 WeakSet和WeakMap都有助于防止内存泄漏。 参考 《深入浅出ES6》 by InfoQ 《ECMAScript 6入门》 by 阮一峰]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6之解构赋值]]></title>
      <url>%2F2016%2F11%2F03%2FES6%E4%B9%8B%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
      <content type="text"><![CDATA[ES6 的解构赋值为我们带来了一种全新的赋值方式，简介高效，但某些场景下如果使用不当反倒是一种混乱。 基础概念解构赋值允许我们使用类似数组或对象字面量的语法形式将数组和对象的属性赋给各种变量。 12345678// 传统赋值方式let first = arr[0];let seconde = arr[1];let third = arr[2];// 为各个变量解构赋值，注意不是给数组赋值let [first, second, third] = arr;// 或者let [a. b. c] = [0, 1, 2]; 需要注意的有以下几点： 如果解构赋值失败，待赋值变量的值为 undefined 赋值号左侧的模式只匹配赋值号右侧的部分模式，依然可以解构成功 1let [a, b] = [1, 2, 3] 如果赋值号右侧的值不是可遍历的结构，即具备 Iterator 接口，那么赋值操作将会报错 解构赋值对于 var、let、const 关键字声明的变量均适用 指定默认值解构赋值允许制定默认值，示例如下： 12let [a = 0] = [];console.log(a); // 0 需要注意的有以下几点： 只有当用于赋值的数组成员的值严格等于(===) undefined 时，默认值才会生效 如果默认值是一个表达式，其将会被惰性求值，即只有用到它的时候，才会对其进行运算 默认值可以引用解构赋值的其他变量，但该变量必须之前已经声明过 解构对象解构亦可用于对象，示例如下： 1let &#123; a, b &#125; = &#123; a: 0, bar: 1&#125;; 对象的解构与数组的解构主要区别是，对象的各个属性名必须与要赋值的变量名相同。本质上，对象的解构赋值，是在对象内部先找到同名属性，然后将属性值赋值给同名变量。 其他规则与数组的解构类似： 对象的解构也可指定默认值，生效条件是对象的同名属性值严格等于 undefined 如果解构失败，变量值为 undefined 值得注意的是，大括号单独写在行首时，JavaScript引擎会将其理解成一个代码块，解决方法是使用一个小括号将整个表达式包裹起来 字符串的解构字符串也可用于解构赋值，这种场景下，字符串在后台被转换为了一个类似数组的对象： 12let [ a, b, c ] = "ufo";console.log(a, b, c); // "u" "f" "o" 圆括号问题解构赋值的一个问题是，对于JavaScript引擎来说，语句到底是模式还是表达式，没有办法从一开始就判断，必须解析到（或解析不到）复制号时才能确定。 由此带来的问题是，如果模式中出现圆括号该怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。 不能使用圆括号的情况 变量声明语句中，不能带有圆括号 函数参数中，模式不能带有圆括号 赋值语句中，不能将整个模式或嵌套模式中的一层，放在圆括号之内 可以使用圆括号的情况可以使用圆括号的情况只有一种：赋值语句的非模式部分。 12[(a)] = [0];( &#123; a: (0) &#125; = &#123;&#125; ); 参考 《深入浅出ES6》 by InfoQ 《ECMAScript 6入门》 by 阮一峰]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6之Symbol]]></title>
      <url>%2F2016%2F11%2F03%2FES6%E4%B9%8BSymbol%2F</url>
      <content type="text"><![CDATA[Symbol （符号）是ES6新引入的一种基本数据类型，也就说 ES6 之后，JavaScript 的基本数据类型从原来的 6 种变为了 7 种：Undefined、Null、Boolean、Number、Sting、Object 和 Symbol。 概念在 ES6 之前，JS代码中每一个值都是以下几种类型之一： Undefined Null Boolean Number String Object 但是现在 ES6 引入了第 7 种原始类型，那就是 Symbol——一种全新的数据类型。新的 Symbol类型的值每一个都是独一无二的，不与其他的 Symbol值相同。Symbol值被创建后就不可变更，也不能为它设置属性。但 Symbo值可以用作对象的属性名称。 通常使用 Symbol() 来生成 Symbol值。每调用一次 Symbol() 都会返回一个全新的唯一 Symbol值。 123let s1 = Symbol();let s2 = Symbol();console.log(Object.is(s1, s2)); // false 注意：用于生成 Symbol 类型值的 Symbol() 函数之前不能使用 new 关键字，否则会报错。原因在于生成的值本质上是一个原始类型的值而不是引用类型的。 Symbol() 函数还可以接受一个其他类型的值作为参数，这个参数被称作该 Symbol值的 描述。 1234567Symbol(); // Symbol()Symbol(undefined); // Symbol()Symbol(null); // Symbol(null)Symbol(true); // Symbol(true)Symol(0); // Symbol(0)Symbol('a'); // Symbol(a)Symobl(&#123; &#125;); // Symbol([object Object]) 不过通常传入的都是一个字符串参数，这样做是为了使描述具有语义。Symbol() 也可接受多个参数，但只有第一个参数值才有效： 1Symbol('a', 0, true, &#123;&#125;); // Symbol(a) 注意：Symbol() 函数的参数只是用于描述该 Symbol值，因此即使传入相同的参数，Symbol() 函数返回的值也是不相同的。这正是 Symbol类型值的本质。 获取 Symbol值有三种获取 Symbol值的方法： 使用 Symbol()，每调用一次都返回一个新的 Symbol值。 调用 Symbol.for(string)。使用这种方式首先会访问全局环境下的 Symbol注册表，检查是否已有 Symbol.for() 使用同名参数创建过 Symbol 值，若存在即返回该值；否则，创建一个新的 Symbol值并将其注册到 Symbol注册表中。这种方式与通过Symbol()定义的独立 Symbol值不同，Symbol注册表中的 Symbol值是共享的。与 Symbol.for() 配套有一个 API 方法是 Symbol.keyFor() ，该方法接受一个 Symbol值做参数，返回 Symbol注册表中该 Symbol值的描述。 使用标准定义的 Symbo值，例如：Symbol.iterator 。ES标准根据一些特殊用途定义了少许的几个 Symbol值。 使用 Symbol值 Symbol值不能与其他类型的值进行运算 Symbol值可以转为布尔值 Symbol值不能被自动转换为字符串，但我们可以显式地使用 toString() 方法将其转化为字符串类型的值 作为对象属性名的 Symbol 值 以 Symbol值作属性名的对象属性被称作一个以 Symbol为键的属性。 由于 Symbol 值的特殊性，当 Symbol 值作为对象的属性名时，只能使用方括号 [] 语法定义及读写，而不能使用. 语法。 对于 Symbol值属性名，我们可以使用 in 语法和 delete 关键字。 Symbol 值作为对象的属性名时，该属性名不会出现在 for..in 、for...of 循环中，也不会被 Object.keys(obj) 、Object.getOwnPropertyNames(obj) 返回。 利用新的API Object.getOwnPropertySymbols(obj) 方法可以获取指定对象的所有 Symbol键，调用该方法会返回一个的数组，其成员是当前对象属性中所有用作属性名的 Symbol值。 另一个新的API Reflect.ownKeys() 方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。 参考 《深入浅出ES6》 by InfoQ 《ECMAScript 6入门》 by 阮一峰]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6之let/const]]></title>
      <url>%2F2016%2F11%2F03%2FES6%E4%B9%8Blet-const%2F</url>
      <content type="text"><![CDATA[ES6 新引入的关键字 let 和 const，终于使得我们不再忍受 var 怪异的声明提升。 let众所周知，在 ES6 之前 JavaScript 中都是使用 var 来声明变量，而这种方式有个非常大的缺陷，那就是变量声明在代码编译阶段会提升至最近的函数边界，所以也就导致了 ES6 之前的 JavaScript 中没有块级作用域的概念。 ES6 新引进的 let 关键字完全解决了这一问题，使用 let 声明的变量与使用 var 声明的变量有以下不同： let 声明的变量会自动绑定至最近的块级作用域 let 声明的变量不会被绑定为为全局对象的属性 同一作用域内，let 声明的变量不可再被重新声明 let 声明的变量不存在声明提升 临时性死区：同一作用域之内，不可在 let 声明变量的代码之前使用同名变量 constES6 同时还引入了一个新的用于声明变量的关键字，那就是 const ，它跟 let 表现出来的行为没有什么太大差别，唯一不同点在于：const 是被设计用于声明只读常量的。const 的特性总结如下： const 声明的变量必须在声明的同时初始化而且也只能在声明时初始化 const 声明的变量一经初始化，其值就不能改变 const 声明的变量会自动绑定至最近的块级作用域 const 声明的变量不会被绑定为全局对象的属性 同一作用域内，const 声明的变量不可再被重复声明 const 声明的变量不存在声明提升 临时性死区：同一作用域之内，不可在声明变量的代码之前使用该变量 下面是示例代码： 123const a; // SyntaxError: Missing initializer in const declarationconst b = 0;b = 1; // TypeError: Assignment to constant variable 参考 《深入浅出ES6》 by InfoQ 《ECMAScript 6入门》 by 阮一峰]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3之美（十三）：3D变换]]></title>
      <url>%2F2016%2F10%2F26%2FCSS3%E4%B9%8B%E7%BE%8E%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A3D%E5%8F%98%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[CSS3 全新的 2D/3D 变换模块，浑身散发着迷人的魅力。 CSS中的3D元素CSS3 中的三维对象是基于笛卡尔坐标系统的，请移步至 维基百科：Cartesian coordinate system。 在 CSS 中，z轴 是以旁观者为参照的，一般来说我们认为 x轴 在网页二维平面中是从左到右的，而 y轴 是从上到下的，那么就可以认为 z轴 是垂直网页二维平面的直线。当我们沿着 z轴 正方向移动一个元素时，就是把元素向自己的方向移动；同样地，以负值移动的话，就是让元素向远离我们的方向移动。 注意，在网页中，一般认为，在三维空间中定位的元素其参考坐标系的原点坐标 (0, 0, 0) 位于元素的几何中心。 比较 2D模块，从形式上来说，3D 模块的元素表现只不过是多了一条 z轴 而已，所以 2D模块中的所说的属性与函数在 3D模块中多是通用的，只不过相同的函数操作多了一个与 z轴 相关的函数而已，当然了，相应的简写形式也做了变化。另外，3D模块也新增了许多函数，帮助我们更好的控制元素在三维空间中变换。 transform-style属性3D模块与 2D模块的在属性上的不同的第一个表现就是多了 transform-style 属性。如果一个元素被显式地设置了 transform-style 属性的值，那么就意味着这个 元素的子元素 在三维空间中被定位了。 其语法如下： 1E &#123; transform-style: keyword; &#125; transform-style 属性支持关键字值： flat： 默认值，子元素不会应用其三维位置坐标 preserve-3d： 子元素会应用其三维位置坐标，只有显示地设置了这个值，3D 变换才会起作用。 为 transform-style 指定的值会影响到元素的子元素，而不是元素本身。有一个需要注意的地方：如果一个元素的 overflow 属性值是 hidden，它的子元素就无法以 3D形式显示。 变换原点3D变换模块中，transform-origin 属性的语法如下： 1E &#123; transform-origin: x, y, z; &#125; 前两个属性值，x 和 y，就像 2D变换模块中 transform-origin 属性所起的作用一样，它们可接受的值可以是一个关键字值（left right center 用于 x，而 top bottom center 用于 y）、长度单位或者百分比值。默认的值是 center center，即 50% 50%。 第三个值，z，是一个长度值，设置了将发生的变换相距 z轴 的距离。 绕轴旋转在 2D 变换中，我们只有一条可以围绕旋转的轴，所以 rotate() 函数只需要一个单独的值，但是当我们在三维中处理旋转的时候，有三条轴可以围绕着旋转。因此，也就有三个属性可以进行控制： rotateX(angle)： 元素绕 x 轴旋转 angle 度 rotateY(angle)： 元素绕 y 轴旋转 angle 度 rotateZ(angle)： 元素绕 z 轴旋转 angle 度 3D 变换还有一个 2D变换不拥有的旋转函数： 1E &#123; transform: rotate3d(x, y, z, 3d); &#125; 上面代码的意思是说，将元素绕经过原点与点 (x, y, z)的直线旋转 angle 度。 沿轴平移2D 变换中关于平移的函数有 translateX() 和 translateY()，它们分别用于设定元素沿着 x轴 y轴 平移。 而在 3D变换中，由于多出了一条 z轴，所以也多了一个新函数 translateZ()，该函数用于设置元素绕 z轴 平移的距离。 另外，3D模块中支持简写函数 translate3d(translateX, translateY, translateZ)。 缩放大小同样地，3D模块中关于缩放的函数多了一个 scaleZ()。元素缩放的函数总共有三个： scaleX() scaleY() scaleZ() 上述三者的简写形式为： scale3d(scaleX, scaleY, scaleZ) ​ 元素深度3D 模块为 transform 属性提供的一个全新函数是 perspective()，它可以在我们查看 3D对象时生成一个人工观察点，提供了深度的错觉。我们先看一下它的语法： 1E &#123; transform: perspective(deepth); &#125; 什么意思呢，前面说过在三维空间中定位的元素，其 z轴 是垂直于网页二维平面，且正方向指向我们的。这个函数就是用来模拟在 z轴 上的人工观察点的，也就是说，它的属性值是用于设置我们的观察点距离元素几何中心的垂直距离，感官上就像是元素的深度。 举个例子 123div &#123; transform: rotateY(50deg) perspective(30px);&#125; 在上面的例子中，div 绕 y轴 旋转了 50度，然后函数设定了观察点是在 z轴 上坐标为 z=30px 的位置。一般来说，在一定范围内 perspective() 函数的参数值越大，我们从观察点看到的元素就显得越大，但是当超过了这一范围后，从观察点看到的元素大小就是其原始尺寸。只有将元素沿着 z轴 负方向移动，并且从较低的观察点去看，元素才可能比原始尺寸小。 perspective 和 perspective-originperspective 属性与 transfomr 属性所支持的 perspective() 函数功能及语法均相同，二者区别在于： perspective() 函数为元素设定了深度之后，在三维空间中效果会应用到所有它的子元素上 perspective 属性的效果则仅仅只是作用于元素本身。 perspective-origin 属性用于设置从我们的视线角度去观看元素时，元素的原点位置所在。其语法如下： 1E &#123; perspective-origin: x-position y-position; &#125; perspective 属性接受两个属性值，其属性值既可以取关键字值，也可以取长度值或百分比值。支持的关键字值如下： top bottom left right center 该属性默认的值为 center center（等价于 50% 50%），即元素的绝对几何中心。 显示或隐藏背面一般来说，当我们旋转元素时，一旦元素的正面远离我们，我们就会看到它的背面。但是默认情况下，元素似乎就像透明一样，所以实际上我们在元素背面会看到元素正面内容的反转图像。 3D模块的新增 backface-visibity 属性可以帮我们解决这个问题，该属性只接受两个关键字值： hidden： 元素背面什么都不会显示 visible： 默认值，元素背面会呈现其正面的反转图像]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3之美（十二）：2D变换]]></title>
      <url>%2F2016%2F10%2F26%2FCSS3%E4%B9%8B%E7%BE%8E%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A2D%E5%8F%98%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[CSS3 全新的 2D/3D 变换模块，浑身散发着迷人的魅力。 TransformCSS3 的 transform 属性允许我们移动、旋转、缩放和倾斜元素。它的基本语法如下： 1E &#123; transform: function(value); &#125; 其中有若干函数可以供我们使用，可用 function 如下： translate() rotate() scale() skewX() skewY() matrix() 1.1 transform-origin变换原点是元素进行变换动作时所依据的点，例如：旋转变换就是绕着不动的变换原点进行旋转等，注意： 一般来说，旋转原点的坐标是固定不变的（参考坐标系是元素自身，即元素左上角为坐标系原点），各种变换动作进行时，变换原点是它们的依据。 变换动作默认的原点是元素的几何中心。但我们可以使用属性 transform-origin 指定变换动作的变换原点。其语法如下： 1E &#123; transform-origin: x y; &#125; 其中 x y 分别用于设置变换原点的横坐标与纵坐标，可以使用长度值或者百分比值，也可以使用下列的关键字值： top bottom left right center 如果仅仅提供了一个参数，那么纵坐标 y 会被设置为 center。 旋转旋转就是让一个元素围绕一个固定的点进行旋转。其语法如下： 1E &#123; tranform: rotate(θ); &#125; θ 是一个表示角度的值，其值循序 CSS3 的取值与单位模块中关于角度的规范，一般来说，我们使用角度即可。 如果 θ 为正值，即是顺时针旋转，如果为负值，则代表逆时针旋转 |θ| 度。注意，旋转 θ（θ&lt;0) 度与 (360-|θ|) 度是一样的。 文档流中的位置元素一旦经过变换，看起来就像把 position: relative 应用到它身上。也就是说，该元素几乎就像是两个元素一样。原始的、转换前的元素会保持它在文档流中的位置，所以后续的元素都会受到它的 margin 和 padding 的影响。经过变换的元素并不影响页面的布局，但它会位于页面剩余部分之上的一个新层当中，意味着这个新的元素可以覆盖后续的元素。 移动控制移动的函数是 translate()，该函数将元素从它的默认位置进行平移。在 2D 变换模块它包含了下列两个独立函数： translateX() translateY() 这两个函数分别控制元素在 x轴 y轴 移动的距离，其可以简写为： 1E &#123; transform: translate(X, Y); &#125; 其中 x y 即分别表示在元素在 x轴 y轴 移动的距离。我们也可以简写，只使用一个值，如下： 1E &#123; tranform: translate(X); &#125; 如此一来，元素就是仅仅会在 x轴上进行平移。 需要注意的是，尽管 translate() 函数的表现颇像相对定位 position: relative; 中的 left top 属性，但是二者还是有区别的，经过变换的元素会保留它的位置，只是从显示上看起来向被移动过，被变换的是元素的图像，而不是元素本身。 倾斜skew() 函数允许修改元素的水平轴或垂直轴的角度，使用语法如下： 1E &#123; transform: skew(α, β); &#125; 就像 translate() 一样，上述语法其也可以拆分为下列两个单独的函数： skewX(α) skewY(β) skew() 函数使用的是角度值，也可以使用负值，而函数的简写形式可以使用一个或两个值。如果使用一个值，第二个值 skewY 会默认为 0。 如果是沿着 x轴 倾斜，那么就是元素的水平边依然保持水平，而竖直边则按照度数倾斜旋转；如果是沿着 y轴 倾斜，那么就是元素的竖直边依然保持竖直状态，但是水平边则按照度数倾斜旋转。 缩放我们可以使用 scale() 函数，来使一个元素与原来相比变得更大或者更小。其使用语法如下： 1E &#123; transform: scale(x, y); &#125; scale() 也可以拆分为下列两个独立函数： scaleX() scaleY() 与以往不同，scaleX scaleY 的值是 无单位的数字，默认尺寸是1。 如果我们使用简写属性，而且提供了一个值，那么另外一个值会被默认为是与第一个值相同的。 我们还可以使用负值，使用负值的效果就是垂直的翻转元素，创建原来元素的映射。 多重变换我们可以在一个单独元素上引用多重变换，只需要在 transform 属性中用空格隔开各个变换函数即可： 1E &#123; transform: function(value) function(value) ...; &#125; 矩阵变换关于在 transform 属性中使用矩阵变换函数的 matrix() 的详细语法，看这里详解 CSS3 矩阵变换函数 matrix()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3之美（十一）：过渡与动画]]></title>
      <url>%2F2016%2F10%2F26%2FCSS3%E4%B9%8B%E7%BE%8E%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB%2F</url>
      <content type="text"><![CDATA[除去 2D、3D变换，CSS3 中最让人兴奋的应该就是过渡与动画模块了。 过渡CSS2 没有中间状态：当一个属性的值发生改变时，这种改变是突然发生的。 CSS3 引入了过渡模块，提供了改变这种方式的选项。在 CSS 中，过渡就是让一个属性的值从初值逐渐改变至终值。 过渡是隐式的动画，意味着它们只有在 CSS 属性设置了新值的时候才会被触发。为了让过渡产生，必须满足 4个条件：一个初始条件、一个终止条件、过渡本身和触发器。 这里所说的初始条件和终止条件就是指元素的属性发生了变化，有两个状态，一个是初始的属性值，一个是后来的属性值。如果为元素定义了过渡，那么当指定的元素属性发生变化时，过渡就会显现出效果，触发器指的也是指定元素属性与初始态相比发生变化了就能触发过渡。 哪个属性transition-property 属性指定了元素的哪一个属性（或者多个属性）会有动画效果。它的语法如下： 1E &#123; transition-property: keyword; &#125; keyword 默认值是 all，其可以接受的所有值： all none 一个有效的 CSS 属性（并不是所有的 CSS 属性都会有过渡效果） 持续时间transition-duration 属性定义了过渡从开始到完成的时间长度，其语法是： 1E &#123; transition-duration: time; &#125; time 值是一个单位为 ms（毫秒）或者 s（秒）的数字。如果想要出现过渡效果，该属性是必须的，由于其默认值是 0，如果不指明的话就没有过渡效果。 控制过渡过程的速度变化要控制元素在两种状态之间过渡的方式，我们需要使用 transition-timing-function 属性。该属性能够控制过渡持续期间各个阶段的速度变化。该属性的取值有以下： ease： 默认值，缓慢开始，然后加速，最后缓慢结束 linear： 从开始到结束都是同一速度 ease-in： 缓慢开始，然后加速直到结束 ease-out： 加速开始，缓慢结束 ease-in-out： 缓慢开始，中间加速，缓慢结束 cubic-bezier(x1, y1, x2, y2)： 贝塞尔曲线函数 立方贝塞尔曲线控制过渡速度变化的属性允许我们使用一个三次贝塞尔曲线函数提供属性值。它的语法如下： 1E &#123; transition-timing-function: cubic-bezier(x1, y1, x2, y2); &#125; 一条三次贝塞尔曲线是利用四个点绘制出来的，在每条轴线上都是从 0 变化到 1.这四个点已知为 P0、P1、P2、P3，它们定义了线的曲率并使用 (x, y) 坐标进行绘制，其中第一个点 P0 总是在 (0, 0)，而最后一个点总是在 (1, 1)。另外两个点定义在函数中，分别是：(x1, y1) 和 (x2, y2)。 线性动画的变化趋势是沿着一条从（0，0）到（1，1）的直线发展的，我们的示例动画会在设置的持续时间内，跟随曲线的发展变化向终点发展。 关键字值 立方贝塞尔曲线 ease 0.25, 0.1, 0.25, 1 linear 0, 0, 1, 1 ease-in 0.42, 0, 1, 1 ease-out 0, 0, 0.58, 1 ease-in-out 0.42, 0, 0.58, 1 过渡开始的时间transition-delaty 属性设置了过渡开始的时间，其语法如下： 1E &#123; transition-delay: time; &#125; 和 transition-duration 一样，time 值是一个单位为 ms 或者 s 的数字。其默认值是 0，意味着过渡会在触发器被触发的时候发生。任何正值都会让过渡在指定的时间长度过去之后才开始，即造成延迟的效果。 我们可以在 transition-delay 上应用负值，会出现有趣的效果，过渡会立即开始，但是会提前跳过负值对应的时间量。过渡看上去就像是从定义的持续时间中间部分开始（持续时间减去延迟时间的绝对值）。 简写属性过渡的简写属性语法如下： 1E &#123; transition: transition-property transition-duration transition-timing-function transition-delay; &#125; 多重过渡我们可以为独立或简写的属性提供一列用逗号隔开的值，轻松地把多种过渡添加到一个元素身上。 12345E &#123; transition-property: border-width, height, padding; transition-duration: 4s, 500ms, 4s;&#125;E &#123; transition: border-width 4s, height 500ms, padding 4s; &#125; 值得注意的是，如果一个独立属性的值比另一个属性更少一些，那么值列表就会被破坏。 1234E &#123; transition-property: border-width, height, padding; transition-duration: 4s, 500ms;&#125; 上面代码中，transition-property 属性有三个值，而 transition-delay 属性却仅仅有两个值，这意味着前者的第三个值（padding）会匹配后者的第一个值（4s）。 动画过渡虽好，但也有本质上的局限，它们只能够在属性值发生变化时才能应用。CSS3 动画模块超越了过渡模块，它能够使用一种更加灵活的语法，让元素从一种样式逐渐变化到另一种样式，并能够进行更加精细的控制。 @keyframes 规则创建动画的第一个步骤是定义关键帧。关键帧定义了一个动画从开始到结束的不同时间点的表现。最简单的动画只有两个关键帧——一个在开头，另一个在结尾，更复杂的动画在开头和结尾之间具有多个关键帧。CSS 过渡本质上是一个只有两个关键帧的动画。 在 CSS 中，我们使用 @keyframes 规则声明关键帧，其语法如下： 12345@keyframes name &#123; keyframe &#123; property: value; &#125;&#125; 上面的代码中， name 表示动画的名称，会用与后面动画的调用 keyframe 设置了在动画持续期间关键字将要出现的位置，可以使用的值是百分比值或者是 from 或 to 的其中一个关键字（分别类似于 0% 和 100%）。我们至少需要指定两个关键帧，设置多个时保证每个关键帧在动画中有一个唯一的值就行。 小示例： 12345@keyframes example &#123; from &#123; border-width: 20px; &#125; 50% &#123; border-width: 10px; &#125; to &#123; border-width: 1px; &#125;&#125; 动画开始，元素是 10px 边框；动画中途，元素边框为 10px；动画末尾，元素边框 1px。 animation-name 属性一旦使用了 @keyframes 规则定义了动画，下一个步骤就是添加对动画元素的控制。 animation-name 属性用于指定使用 @keyframes 规则定义的动画名称，以此来调用定义好的动画。 动画持续时间amimation-duration 属性用于设定动画持续时间，它的语法规则与之前在过渡部分介绍的 transition-duration 属性一样，属性值是一个单位为 s 或者 ms 的数字，默认为 0，但是为 0 动画没有任何效果，负值同理。 注意：如果要想有动画效果，animation-duration 属性必须有，而且其属性值必须为正数。 动画速度变化animation-timing-function 属性，动画的这个属性与过渡的 transition-timing-function 属性的语法是相同的：1E &#123; animation-timing-function: keyword || cubic-bezier(x1, y1, x2, y2); &#125; 该属性可用的关键字值有： ease linear ease-in ease-out ease-in-out 动画延迟animation-delay 属性用于设置动画开始之前的延迟时间，其语法与过渡的延迟时间 transition-delay 属性相同。 属性值是一个单位为 ms 或者 s 的数值，0 意味着动画立即开始，没有延迟，负值可以使动画跳过指定时间。 动画重复CSS 过渡只能发生一次（或者说两次，如果把相反的过程也算上的话），但是动画不同，动画可以被重复任意次数。动画的重复次数由 animation-iteration 属性设置，其语法如下： 1E &#123; animation-iteration-count: number || infinite; &#125; 该属性的属性值为一个正整数用于设定动画重复的次数，可能的取值如下： 1： 默认值， infinite： 表示动画无限循环播放 0 或负值： 会阻止动画播放 正整数： 动画会按照播放指定数值的次数 动画播放方向动画的正常播放是从开始到结束，但它们也可以以相反的方向播放（像过渡那样）。我们可以设置动画是否一直以同一个方向播放，或者交替地向前或向后播放。为了实现这一效果，我们可以使用 animation-direction 属性： 1E &#123; animation-direction: keyword; &#125; 可使用的属性值关键字值有： normal： 默认值，动画总是从头开始播放到完成 reverse： 动画会以相反方向播放 alternate： 动画在第奇数次播放时，总是使用 normal 值，即向前播放；动画在第偶数次播放时，总是使用reverse 值，即反方向播放 alternate-reverse： 该属性值的作用于 alternate 值相反，奇数的圈动画会向后转，偶数的圈动画向前转。 动画的播放状态animation-play-state 属性用于指出一个动画是否是活跃的，其语法如下： 1E &#123; animation-play-state: paused | running; &#125; 该属性有两个关键字值： paused： 表示动画未在播放 running： 默认属性值，表示动画正在播放 动画未正在播放时元素的样式animation-fill-mode 属性用于设置动画没有正在播放时元素的表现，也就说，元素的动画播放前或播放完毕时，元素的表现。 该属性接受以下的关键字值： none： 默认属性值，没有任何样式 forwards： 动画开始前或结束后，元素将表现为动画结束时刻的样子 backwards： 动画开始前或结束后，元素将表现为动画开始时刻的样子 属性简写动画简写属性 animation 的语法如下： 1234567891011E &#123; animation: animation-name animation-duration animation-timing-function animation-delay animation-iteration-count animation-direction animation-fill-mode animation-play-state&#125; 我们一个例子来看一下 animation 简写属性与独立属性分开写的对应关系： 123456789101112131415161718192021222324252627@keyframes haha &#123; /* 在此处声明动画特定帧的行为 */&#125;.element &#123; animation-name: haha; animation-duration: 2s; animation-timing-function: ease-out; animation-delay: 0.5s; animation-iteration-count: infinite; animation-direction: alternate; animation-fill-mode: none; animation-play-state: running;&#125;/* 上面的独立属性等价于下面的简写属性 */.element &#123; animation: haha 2s ease-out 0.5 infinite alternate none running;&#125; 多重动画如需为一个元素添加多个动画，使用一个逗号隔开的动画简写属性值列表即可。 支持动画的元素属性注意！！！并不是所有的元素属性都支持动画特性，MDN 为我们提供了一份清单 a list of CSS properties which can be animated，这上面列出了所有支持 CSS 动画的元素属性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3之美（十）：渐变]]></title>
      <url>%2F2016%2F10%2F26%2FCSS3%E4%B9%8B%E7%BE%8E%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E6%B8%90%E5%8F%98%2F</url>
      <content type="text"><![CDATA[使用 CSS3 的渐变我们可以使背景在两种甚至更多颜色之间平滑过渡地显示。在这之前，我们只能通过图片来实现相同效果。现在，同样的效果，我们通过使用 CSS3 技术既减少了下载时间又节省了服务器带宽和用户流量。另外，使用渐变的元素在被放大时效果看起来更好，因为渐变是通过浏览器原生呈现的。 注意，使用渐变效果依据的是 background-image 属性。 CSS3 支持两种渐变： 线性渐变 径向渐变 关于渐变的浏览器兼容，绝对是个坑，下文我们就会见到。 线性渐变线性渐变是各种颜色跨过直线上两点之间的距离所产生的一种逐步的过渡。其语法如下： 1E &#123; background-image: linear-gradient(direction, color1, color2, ...); &#125; 其中： direction 表示渐变所沿的直线方向 color 表示渐变中从起始位置到结束位置经过的颜色值，这个颜色可以使用 RGBA、HSLA 等 CSS3 所支持的各种颜色表示方法。 从上到下渐变语法中的 direction 值如果不指定的话，那么渐变默认是从顶部到底部的。示例： 123div &#123; backgrouond-image: linear-gradient(red, yellow);&#125; 上面代码的效果是元素其顶部到底部之间呈现由红色逐渐平滑过渡到黄色的状态。 由于浏览器历史问题，渐变有着各种奇怪的浏览器实现，我们的跨浏览器代码如下： 1234567div &#123; background-color: red; /* 兼容不支持渐变的浏览器 */ background-image: -webkit-linear-gradient(red, yellow); background-iamge: -o-linear-gradient(red, yellow); background-image: -moz-linear-gradient(red, yellow); background-iamge: linear-gradient(red, yellow); /* 标准语法 */&#125; 从左到右默认的渐变方向是从元素顶部到底部，如果我们需要从做到右的渐变怎么办呢？这个时候，就是 direction 所提供的值在起作用了，看下面这个示例： 1234567div &#123; background-color: red; background-image: -webkit-linear-gradient(left, red, yellow); background-image: -o-linear-gradient(right, red, yellow); background-image: -moz-linear-gradient(right, red, yellow); background-image: linear-gradient(to right, red, yellow); /* 标准语法 */&#125; 上面的代码实现的便是从左到右的渐变，看到了那一串奇怪的浏览器兼容代码吧，很恶心有木有？那是由于历史原因造成的，我们不必在意，历史的车轮滚滚向前，我们应该放眼未来。 线性渐变 linear-gradient 支持一种名为 to 语法的方向控制，它允许我们使用关键字来控制渐变所沿的方向，这个关键字代表的就是渐变方向。例如，to left 表示从右向左的渐变方向。 to 语法所允许的关键字如下： right left top bottom bottom right bottom left top right top left 沿着对角线我们使用 to 语法来实现沿着对角线的渐变，跨浏览器代码如下； 1234567div &#123; background-color: red; background-image: -webkit-linear-gradient(left top, red, yellow); background-image: -o-linear-gradient(bottom right, red, yellow); background-image: -moz-linear-gradient(bottom right, red, yellow); background-image: linear-gradient(to bottom-right, red, yellow); /* 标准语法 */&#125; 沿着指定角度如果我们想更精确地控制渐变的方向，可以通过指定角度参数，而不是使用仅仅提供了几个关键词的 to 语法。指定角度控制线性渐变的语法如下： 1E &#123; backckgrounde-image: linear-gradient(angle, color-stop1, color-stop2,...); &#125; 角度可以使用几种不同的单位来声明：取值与单位模块允许使用度数、梯度、弧度与转数去指定角度。一般，我们都使用角度，比较好理解嘛。angle 值设置了渐变的角度： 0deg（360deg）： 从下到上 45deg： 从左下角到到右上角 90deg： 从左到右 -90deg： 从右到左 大于零的度数值表示以竖直轴顺时针旋转，小于零的度数值表示以竖直轴逆时针旋转。不难看处，xdeg（x&lt;0）与 （360-|x|）deg 是等效的。 示例如下，下面是一个从右到左的渐变。 1234567div &#123; background-color: red; background-image: -webkit-linear-gradient(-90deg, red, yellow); background-image: -o-linear-gradient(-90deg, red, yellow); background-image: -moz-linear-gradient(-90deg, red, yellow); background-image: linear-gradient(-90deg, red, yellow); /* 标准语法 */&#125; 使用多个 color 值使用多个 color 值，很好理解，即渐变是按照多种颜色出现的先后顺序逐渐变化过渡的。下面是一个示例： 1234567div &#123; background: red; background-iamge: -webkit-linear-gradient(red, yellow, green); background-iamge: -o-linear-gradient(red, yellow, green); background-iamge: -moz-linear-gradient(red, yellow, green); background-iamge: linear-gradient(red, yellow, green);&#125; 上面代码的结果即是呈现从上到下的红黄绿三色逐渐过渡的渐变。 重复一个线性渐变如果我们需要重复一个线性渐变，可以使用 repeating-linear-gradient 语法。其语法如下： 1E &#123; background-image: repeating-linear-gradient(direction, color1, color2, ..., to-stop); &#125; 奇怪，看起来和普通的线性渐变的语法没什么太大区别呀。二者的唯一区别在于重复线性渐变中 color 颜色值后面可以跟一个长度值或者百分比值，如果一旦出现了这样的颜色值，那么它跟它之前的颜色就会被解释为一个渐变，这个数值也被解释为这个渐变的长度。另外，重复线性渐变中所重复的单位线性渐变长度是由其表达式中最后一个 color 后面的数值决定。 下面是一个示例： 1234567div &#123; background-color: red; background-iamge: -webkit-repeating-linear-gradient(red, yellow 10%, green 20%); background-iamge: -o-repeating-linear-gradient(red, yellow 10%, green 20%); background-iamge: -moz-repeating-linear-gradient(red, yellow 10%, green 20%); background-image: repeating-linear-gradient(red, yellow 10px, green 20px);&#125; 上面代码的意思是，在 div 中所重复的单位线性渐变的长度为 20px。在这个 20px 长的单位线性渐变中，还可以分为： 先是红色到黄色的 10px 长的渐变 然后是黄色到绿色的 10px 长的线性渐变。 径向渐变径向渐变是以一个点为中心，向四周成放射状地在各种颜色之间逐步进行过渡。其语法如下： 1E &#123; background-image: radial-gradient(shape size at position, start-color, ..., last-color); &#125; 其中，属性值各个参数的意义如下： shape： 用于设定整个渐变是在圆形还是椭圆形中逐变化，值可以是： circle： 表示圆形的径向渐变 ellise： 默认值，即椭圆形的径向渐变 size： 用于设置径向渐变到何处停止，默认是 farthest-corner，可选的值有： closest-corner 渐变会在最接近起始位置的角停止 closest-side 渐变在最接近起始位置的边停止 farthest-corner 渐变会在距起始位置最远的角停止 farthest-side 渐变会在距起始位置最远的边停止 position： 用于设置渐变起始时的位置，如果提供两个参数，第一个为横坐标，第二个表示纵坐标；如果仅提供一个参数，第二个参数默认为 50% ，即 center。其默认值为 center ，即在中心处，我们可以使用 at 语法后跟关键字或者是长度值/百分比值来指定，其中可选的关键字有： center top &lt;==&gt; top center bottom &lt;==&gt; bottom center left &lt;==&gt; left center right &lt;==&gt; right center top right top left top center bottom left bottom right bottom center 下面是一个例子 123456div &#123; background-image: -webkit-radial-gradient(circle farthest-side at 60% 50%, red, yellow, blue); background-image: -o-radial-gradient(circle, farthest-side at 60% 50%, red, yellow, blue); background-image: -moz-radial-gradient(circle farthest-side at 60% 50%, red, yellow, blue); background-image: radial-gradient(circle, farthest-side at 60% 50%, red, yellow, blue);&#125; 上面代码的效果是产生一个红黄绿颜色的圆形径向渐变，以元素的左上角为参考点，该圆心坐标是(60%, 50%)，该径向渐变从圆心处开始到距圆心最远的角落处停止。 重复径向渐变重复径向渐变的语法与重复线性渐变类似，其语法如下：1E &#123; repeating-radial-gradient(shape size at position, color1, ..., to-stop); &#125; 与普通径向渐变的语法没什么太大的区别，区别主要在于最后一个 color 值后面会跟一个长度值后者百分比值用于指定重复的径向渐变中单位径向渐变的半径范围。 示例如下： 123div &#123; repeating-radial-gradient(circle, black, white 20px);&#125; 上例创建了一个黑白径向渐变，每隔 20px 重复一次。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3之美（九）：颜色与不透明度]]></title>
      <url>%2F2016%2F10%2F26%2FCSS3%E4%B9%8B%E7%BE%8E%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E9%A2%9C%E8%89%B2%E4%B8%8E%E4%B8%8D%E9%80%8F%E6%98%8E%E5%BA%A6%2F</url>
      <content type="text"><![CDATA[CSS3 新引入的颜色度量单位、与可设置的透明度都令人兴奋。 前言W3C 标准化组织定义的标准 16中颜色名称分别是： aqua 水蓝 black 黑 blue 蓝 fuchsia 紫红 gray 灰 green 绿 lime 绿黄 marron 酱紫 navy 深蓝 oblive 橄榄绿 purple 紫 red 红 silver 银 teal 青 white 白 yellow 黄 CSS2 中的颜色是基于红（Red）、绿（Green）、蓝（Blue）模型的（RGB），不论使用十六进制表示法还是RGB颜色值，都需要把这三种颜色组合起来，才能为页面添加颜色。这种模型对于开发人员来说是痛苦的，因为设计师所需要的颜色各种各样，往往还需要控制深浅度和色调，所以开发人员不得不使用第三方软件去找到精确匹配的色调。 CSS3颜色模块针对这个问题提供了解决方案。除此之外，还引入了更多的内容。 使用opacity属性设置透明度透明度，严格来讲，是估量一个对象对光线的阻力——某种东西更加不透明，表示它允许透过的光线就更少；某种东西的透明度更高，它允许通过的光线就更多。一个没有透明度的对象是完全不透光的，而一个没有不透明度的对象则是完全透明的。在 CSS 中，二者均使用 opacity 属性来度量。本质上，对于 opacity，我们设置的是背景在多大程度上可以透过指定的元素看到。 opacity 属性语法如下： 1E &#123; opacity: number; &#125; number 是一个介于 0~1 之间的小数，其中 0 表示完全透明，1 表示完全不透明。 这个属性有一点非常特殊：opacity 属性的值会被它的所有子元素继承，并且子元素所继承的 opacity 属性值的设置不能够被其他任何属性覆盖，另外子元素的 opacity 属性值只能向下覆写而不能向上覆写。也就是，我们永远不可能让子元素比它的父元素更加不透明。 Alpha通道和 opacity 属性相似，Alpha 通道（简称 Alpha）是对一种颜色透明度的度量。所以，尽管使用 Alpha 的颜色值可以像其他任何颜色值一样被子元素所继承，但元素的整体不透明度并不受影响。 CSS3 引入 Alpha 作为 RGBA 颜色模型中的一个值。RGBA 中的 RGB 即是 CSS2 中的 RGB 模型，A 就是 CSS3 新引入的 Alpha。其语法如下： 1E &#123; color: rgba(red, green, blue, alpha); &#125; alpha 参数的值和 opacity 的参数值语法是一样的，是一个 0~1 之间的小数。 rgba 和 opacity 的区别在与，前者是一个颜色值，而后者是控制元素的透明度的；另外，前者只能精确地应用到它指定的元素上，而后者所应用的元素的所有子元素都会继承其特性。 RGBA优雅降级不支持 RGBA 的浏览器会忽略其所声明的颜色值。为了优雅降级，我们应该制定两次颜色： 1234div &#123; color: #F000; color: rgba(255, 0, 0, 0.75);&#125; 但是这样做，一定要注意，确保优雅降级后不会影响到最终的设计效果。 HSLHSL 中的三个字母分别代表 Hue（色度）、Saturation（饱和度）、Lightness（亮度）。 要使用 HSL 定义一个颜色，首先必须在 0~359 的颜色环中为色调选择一个值。任何更高的值只是 0~359 的重复，例如红色的数值为 0，所以 360 和 720 也是红色。 在颜色环中，作为最基本颜色的红、绿、蓝分别被分为 120’，所以纯红、纯绿和纯蓝的数值分别为 0、120、240。处于这些数值之外的值表示构成基本颜色外不同比例的色调。 接着需要饱和度等级，它是 0~100 间的百分数值。该值用以确定色彩显示的褪色或鲜明程度。饱和度值以中灰色（0%）环中心点为起点，随着环向外延伸，色彩变得越发鲜明（饱和度最大值为100%）。 最后就是色彩的亮度，亮度的取值也是从 0~100 的百分数值。值为 50% 时色彩最饱满、亮度最高，数值越低，颜色越暗直至黑色（0%）。数值越高，颜色越亮，直至白色（100%）。可以将这种颜色想象成在颜色重混合了黑色和白色。 因此，为了选择一个完全饱和、具有标准亮度的黄色，可使用如下代码： 1color: hsl(60, 100%, 50%); HSL 就好像是所有可能的 RGB 颜色被映射到三维之中。所有可能的颜色被安排在一个带有中心轴的圆柱体中，围绕该中心轴的角度就是色度（H），与该中心轴的距离就是饱和度（S），而沿着轴线距离就是明度（L）。 色度代表主要颜色，从红色开始和结束（0或者360度），并包括了这中间所有的主要颜色。色度就是指向某个特定颜色的圆周的角度。 饱和度就是该颜色的最强度或者力度：0%就是没有强度，会让颜色变得稍微有些灰色，而 100% 就是全部强度，是该颜色的最强版。 明度就是颜色明暗程度，50%是真实色度，0%是黑色，而 100%是白色。 HSL的语法如下： 1E &#123; color: hsl(hue, saturation, lightness); &#125; hue 接受的值从 0 至 360，而 saturation 和 lightness 接受的值则是从 0% 至 100%。 下表是四种颜色值写法常见的颜色等效值： HSL RGB 十六进制数 关键字 0,0%,0% 0,0,0 #000000 black 360,0%,100% 255,255,255 #FFFFFF white 0,100%,50% 255,0,0 #FF0000 red 120,100%,25% 0,128,0 #008000 green 240,100%,50% 0,0,255 #0000FF blue 这一表格实际上没有表述全部实情，许多不同值的组合也可以创造出白色。 HSLAHSL 也可以利用 Alpha 通道实现扩展，与 RGBA 类似： 1E &#123; color: hsl(hue, saturation, lightness, alpha); &#125; 颜色变量currentColorCSS3 新引入了一个颜色值关键字 currentColor。这个关键字的作用更像是一个变量，也就是说它的值是继承的。它可以应用在文档树中的不同位置。一个元素的 currentColor 值是它自己的 color 属性值，并且像 color 一样，currentColor 可以被继承。 下面以实例说明： 1234div &#123; color: yellow; border: 1px solid currentColor;&#125; 上述代码展示了 currentColor 的用法，它就像一个变量一样，保存着继承而来的 color 值，使用这个属性的好处是如果需要修改属性，不用再对每个子元素就行修改了，可以直接修改父元素的 color 值，前提是子元素的颜色设置都是通过 currentColor 实现的。 匹配操作系统外观CSS3 中有一个属性 appearance，用于设置元素外观按照本地默认样式显示。 1E &#123; appearance: keyword; &#125; 其中，关键字值 keyword 的值来自于用户界面元素的一长串列表。在此不赘述。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3之美（八）：边框]]></title>
      <url>%2F2016%2F10%2F26%2FCSS3%E4%B9%8B%E7%BE%8E%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E8%BE%B9%E6%A1%86%2F</url>
      <content type="text"><![CDATA[CSS3 为 border 带来了许多新的特性，这酷毙了。 边框圆角CSS3 的背景与边框模块引入了一种新的方法，我们只要单独使用 CSS，就可以为元素添加圆角效果。其中，每个边角都会被当作是一个四分之一的椭圆，它通过在 x 轴和 y 轴上的两个点之间绘制一条曲线进行定义。 四分之一的椭圆可以是规则的，即两条轴线上的长度都是相同的；也可以是不规则的，即每条轴线的长度均不相等。 CSS3 使用 border-radius 属性去定义这些曲线。 1E &#123; border-v-h-radius: x y; &#125; 上述示例中的 v 是一个值为 top 或者 bottom 的关键字值，h 是一个值为 left 或者 right 的关键字值，而 x 和 y 则分别表示椭圆的水平半径和垂直半径。 下面是一个示例： 123div &#123; border-bottom-right-radius: 5px 8px;&#125; 上面的代码会使用 5px 的水平半径和 8px 的垂直半径在一个 div 元素的右下角绘制椭圆曲线，使其变成圆角。 对于规则曲线来说，border-radius 可以简化，只需留下 x 或 y 值即可。如果其中的一个值未被指定，那么这两个值就会被假定是相等的。所以如果是要在元素的每个边角上应用同样的半径，可以这样： 123456div &#123; border-top-left-radius: x; border-top-right-radius: x; border-bottom-left-radius: x; border-bottom-right-radius: x;&#125; border-radius简写上面的写法针对元素的 4个角需要分别编写 4行代码稍显复杂，我们可以使用简写属性 border-radius。 border-radius 属性和 border-width margin padding 一样，也可以指定 1个、2个、3个或者 4个值，其规则也是大同小异。注意，如果使用这种简写方式，那么 x 和 y 值必须是相同的。 下面是示例； 1234567891011121314151617181920212223242526.radius-1 &#123; border-radius: 3px; /* 边框的四个角均为半径为 3px 的弧线 */&#125;.radius-2 &#123; border-radius: 3px 2px; /* 边框的左上角、右下角是半径为 3px 的弧线，右上角、左下角是半径为 2px 的弧线 */&#125;.radius-3 &#123; border-radius: 3px 2px 1px; /* * 边框的左上角为半径为 3px 的弧线 * 边框的右上角与左下角为半径为 2px 的弧线 * 边框的右下角为半径为 1px 的弧线 */&#125;.radius-4 &#123; border-radius: 3px 2px 0 0; /* * 左上角 半径为 3px 的弧线 * 右上角 半径为 2px 的弧线 * 右下角、左下角 没有圆角效果 */&#125; 另外，我们也可以对不规则曲线使用简写语法。下面是语法规则：12E &#123; border-radius: horizontal-radius / vertical-radius; &#125;/* horizontal-radius 为水平半径，vertical-radius 为垂直半径 */ 上述语法格式中，斜线的两端均可以包含一至四个值，如同规则曲线的简写一样。下面是示例： 12345678910.radius-1 &#123; border-radius: 10px 20px 20px / 20px 10px;&#125;/* * 左上角 水平半径为 10px，垂直半径为 20px * 右上角 水平半径为 20px，垂直半径为 10px * 右下角 水平半径为 20px，垂直半径为 20px * 左下角 水平半径为 20px，垂直半径为 10px */ 边框图片CSS3 引入了 border-iamge 属性，使得我们可以使用自定义图片作为边框。其语法如下：1E &#123; border-image: source slice width outset repeat; &#125; border-image 是一个简写属性，它总共有 5个独立属性： border-iamge-source这个属性比较好理解，就是用来设定作为边框背景图像的来源。但要注意的是，我们最好选取中间区域透明或者为白色的图片，要不然，图片看起来就好像是元素的背景图了。 border-image-slice这个属性是用来设置边框背景图的分割方式，其语法如下： 1E &#123; border-image-slice: value; &#125; value 是一个长度值或百分比值（或者一系列值）。border-image-slice 属性与 border-radius 有些相似，其属性值参数可以在 1~4 个之间。 该属性指定了从上、右、下、左四个方位来切割图像，将图像分成 4个角，4条边和中间区域共 9份。其中，border-image-slice 的 4个属性值分别用于切片时控制要切割的区域（即中间区域，放置元素的区域）距顶部、右侧、底部、左侧的距离，这些值是指明了我们将要使用图片的那一部分作为上边框、右边框、下边框、左边框。 如果提供的属性值的数量少于 4个，则其按照与 border-width margin padding 相同的规则计算其余各边框的长度。 其中，中间区域是透明的（即没有图像填充），除非在属性值最后加上关键字 fill。fill 关键字指定保留裁剪后的中间区域，其铺排方式遵循 border-image-repeat 的设定。 border-image-slice 属性切割后的切片，几个角会一直保持不变，能够被缩放以填充它们的位置，但 4条边可以使用 border-image-repeat 属性中指定的值进行修改。 border-image-width该属性用于设置元素边框的宽度，它的优先级高于 border-width。（border-image-width 常用于提供回退状态。） border-image-width 和 border-image-slice 属性有着同样的语法。 border-image-outset该属性用于设置元素的边框背景图可以在元素外部扩展的长度，其使用具体数值指定了边框背景图向外扩展的长度。 border-image-outset 属性也使用和 border-image-slice 一样的语法。 border-image-repeat该属性用于设定边框背景图侧边切片的填充方式，可以定义 0~2 个参数值，分别表示水平方向和垂直方向的平铺方式，如果 2个值相同，可以合并成一个。语法如下： 1E &#123; border-image-repeat: keyword; &#125; 其中，关键字可取以下值： stretch： 拉伸方式填充，表示侧面的切片将会延伸，从而填充元素的长（高或者宽） repeat： 沿着边框的长平铺图片，图片碰到边界时，超出会被截断 round： 沿着边框的长整数次平铺图片，图片会根据边框尺寸动态调整其 大小 直至正好可以铺满整个边框 space： 沿着边框的长整数次平铺图片，图片会根据边框的尺寸动态调整其 间距 直至正好可以铺满整个边框 边框阴影CSS3 新引入的 box-shadow 属性可以为块状元素添加阴影。其语法如下： 1E &#123; box-shadow: inset horizontal vertical blur spread color; &#125; 下面详细解释每个参数的意义: inset: 可选的关键字值，用于设置对象的阴影类型为内阴影，如果不设置该值，则阴影默认为外部阴影 horizontal： 用于设置阴影相对于元素的的水平偏移距离（以元素左上角为参考原点），必须参数，可以为负值 vertical： 用于设置阴影相对于元素的垂直偏移距离（以元素左上角为参考原点），必须参数，可以为负值 blur： 用于设置阴影的模糊程度，它是一个长度值，不允许负值 spread： 表示阴影的外延长度，可以为负值 color： 用于设置阴影的颜色 注意；以上这些值中，只有水平和垂直偏移值是产生阴影效果必须的，另外，最好显式地指出阴影颜色。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3之美（七）：背景图像]]></title>
      <url>%2F2016%2F10%2F26%2FCSS3%E4%B9%8B%E7%BE%8E%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E8%83%8C%E6%99%AF%E5%9B%BE%E5%83%8F%2F</url>
      <content type="text"><![CDATA[CSS3 为背景图片引入了丰富的特性，这意味我们开发者对背景图片有了更多的掌控权。 多背景图片CSS3 对现有的 background-* 属性进行了扩展，几乎所有的 background-* 属性现在都可以接受多个值，除了 background-color 属性。 下面我们介绍使用 background-image 属性为元素添加多个背景层： 12345div &#123; background-image: url('sunny.png'), url('child.png'); background-position: 95% 85%, 50% 50%; background-repeat: no-repeat;&#125; 在示例代码中 background-image 使用了两张图片，但是在显示时，列表中的第一层图片（sunny.png）会成为最顶层，位于后面的图片将会按声明的顺序先后显示在它的下面。另外，background-position 属性值的顺序遵顼与 background-image 相同的顺序。 注意：background-repeat 属性只有一个唯一的值，如果一个属性的值的数量比其背景图片的数量少，那么这些值就会被重复。在上面的示例中，no-repeat 将会被应用到所有的背景层图片上。 我们可以对 background 简写属性使用多个值，和独立的属性一样，我们也只需要提供一个逗号隔开的列表。上面示例使用简写方式改写如下： 12345div &#123; background: url('sunny.png') no-repeat 95% 85%, url('child.png') no-repeat 50% 50%;&#125; 如果同时设置了背景图像 background-image 和 背景颜色 background-color，那么背景图像将覆盖在背景颜色之上。所以，如果我们需要背景颜色的话，那么在写属性代码时应该将其置于逗号隔开的列表的最后位置。 123456div &#123; background: url('sunny.png') no-repeat 95% 85%, url('child.png') no-repeat 50% 50%, #000;&#125; 不过，老版本的浏览器将会忽略以上语法，并引用层叠中的前一条规则。所以，我们应该在使用多值之前在元素上声明一个属性，作为一种优雅降级方案。例如： 123456div &#123; background: url('sunny.png') no-repeat 50% 50%; background: url('sunny.png') no-repeat 95% 85%, url('child.png') no-repeat 50% 50%;&#125; 在这种情况下，不支持的浏览器将会忽略使用多值的属性，然后使用在它之前的单值。不过，要注意在 IE 中，我们需要为这两者使用简写属性，因为如果我们使用 background-* 属性，它们就会优先于简写属性，不会有图片显示出来。 背景位置CSS3 并没有新增与背景位置有关的属性，不过倒是为两个已有属性了增加了新的属性值。 background-attachment第一个与背景位置相关的属性是 background-attachment，用于设置背景图是跟随对象滚动还是固定的。其原本只有两个值 fixed 和 scroll，但CSS3 为其新增了一个值 local。 fixed： 表示背景图相对于窗口固定位置。 scroll： 表示背景图相对于元素固定，也就是说当元素内容滚动时背景图不会跟随着滚动，因为背景图总要跟着元素本身，但背景图会随元素的祖先或窗口一起滚动。 local： 意味着背景图相对于元素固定，但是当元素滚动时背景图也会随之滚动，因为背景图总是要跟着内容。 background-position第二个属性是 background-position，用于设置背景图开始显示的位置。其语法如下： 1E &#123; background-position: value; &#125; 该属性默认值为 left top，即背景图从左上角开始显示。 它的属性值可以为数值、百分比值、关键字值。其中，数值和百分比值指定背景图填充的位置，可以为负值。属性值需要两个参数，第一个会被用于横坐标，第二个会被用于纵坐标，如果我们仅仅只设定了一个值，那么第二个会被默认设为 center。 可用的关键字值有以下： left &lt;==&gt; left center right &lt;==&gt; right center top &lt;==&gt; top center bottom &lt;==&gt; bottom center center &lt;==&gt; center center 以上关键字可以组合，所有合法的组合如下： left top &lt;==&gt; top left left center &lt;==&gt; center left left bottom &lt;==&gt; bottom left right top &lt;==&gt; top right right center &lt;==&gt; center right right bottom &lt;==&gt; bottom right top left top center &lt;==&gt; center top top right bottom left bottom center &lt;==&gt; center bottom bottom right center center center left center right center top center bottom 示例，背景图在容器中居中显示： 123div &#123; background: url('test.png') no-repeat 50% 50%;&#125; 而在 CSS3 中，background-position 属性允许最多提供 4 个参数值，如果提供 3 或 4 个参数值，那么每个 length 或 percentage 偏移值前都必须跟着一个关键字（不包括 center），偏移量相对于关键字所表示的位置进行偏移。 示例，假设背景图在容器中右下方，并且距离右边和底部各有 20px： 123div &#123; background: url('test.png') no-repeat right 20px bottom 20px;&#125; 背景尺寸CSS3 新增了一个属性 background-size，通过使用它我们能控制背景图片的缩放。该属性的值可以是一对长度或者百分比值、一个单独的长度或者百分比值（不允许负值），或者关键字。 该属性的默认值是 atuo，即以原图的宽高为准不变。 如果使用一对值，其语法是 1234E &#123; background-size: width height; &#125;/* width 图像宽度 * height 图像高度 */ 如果使用单个值，则该值会被认为是宽度的大小，而高度则会使用默认值 auto。 另外，还有两个可用的关键字如下： contain： 背景图等比缩放，但是其宽高不会超过容器的长或宽，整个背景图始终会被包含在容器内。 cover： 背景图片等比缩放到容器的宽度或高度（向更大的那个值看齐），会完全覆盖容器，背景图像可能会超出其容器，即在容器中无法看到整个背景图的全貌 精确控制图片位置：显示截至位置和显示原点在 CSS2 中，背景图定义的位置是相对于其包含元素的 padding 的外边界的，所有溢出都会扩展到边框之下。CSS3 引入了两个新的属性，可以对其进行更精确的控制。 background-clip第一个属性是 background-clip，它设置盒模型的哪一部分成为背景显示的截至位置。其语法如下： 1E &#123; background-clip: value; &#125; background-clip 属性的取值如下： 默认值 border-box 可用的关键字值 border-box：背景图显示到 border 外边界处为止 padding-box：背景图显示到 padding 外边界处为止 content-box：背景图显示到 content 外边界处为止 该属性当前在 Opera 中的得到了实现，在 Firefox4 和 IE9 应该也没有问题。较老的 Firefox 版本使用的是非标准的实现，使用值 border 和 padding 分别替代了 border-box 和 padding-box，在属性上使用了专用的 -moz- 前缀。 Webkit 的情况较为复杂，它最早的实现使用了 border 和 padding 值，就像早期 Firefox 一样，并且也使用了 content 关键字代替了 content-box，而且在所有属性上都具有 -webkit- 前缀。较新的版本使用 border-box padding-box content-box，但仍然使用带前缀的属性。最新的 Webkit 版本，使用 border-box padding-box 的时候没有了前缀，但在使用 content-box 时仍需要前缀。鉴于以上情况，若要编写跨浏览器代码，或许像下面这样： 12345678910111213141516171819E1[class~='bord'] &#123; -moz-background-clip: border; -webkit-background-clip: border; -webkit-background-clip: border-box; background-clip: border-box;&#125;E2[class~='padd'] &#123; -moz-background-clip: padding; -webkit-background-clip: padding; -webkit-background-clip: padding-box; background-clip: padding-box;&#125;E3[calss~='cont'] &#123; -webkit-background-clip: content; -webkit-background-clip: content-box; background-clip: content-box;&#125; background-origin第二个属性是 background-origin，它可用来设置背景开始显示的原点。该属性的取值同 background-clip 属性可用的关键字值一样，具体可用取值如下： 默认值 padding-box 可用的关键字值 content-box padding-box border-box 这个属性与之前 background-clip 属性的区别为： background-clip 用于指定元素对象的背景图显示的截至位置 background-origin 是用于指定元素对象的背景图像计算 background-position 时的参考原点，也就是说，这个属性是与 background-position 属性一起配合使用。background-position 负责设定背景图从容器的哪一块位置开始，而 background-origin 则负责更精确地控制是从容器盒模型的哪一层边界开始。 和 background-clip 一样，Opera 和最新的 Webkit 浏览器对 background-origin 的实现和规范一致，而 Firefox4 和 IE9 应该也是相同的。较老的 Firefox 和更老一些的 Webkit 版本并没有实现这个属性的标准版本，它们使用带有前缀的属性实现了三个像 border padding content 一样的可能值，而老一点的 Safari5 之前的 Webkit 版本要求使用正确的值，也是通过带前缀的属性实现。因此，跨浏览器代码看上去如下： 123456789101112131415161718192021E1[class~='bord'] &#123; -moz-background-origin: border; -webkit-background-origin: border; -webkit-background-origin: border-box; background-origin: border-box;&#125;E2[class~='padd'] &#123; -moz-background-origin: padding; -webkit-background-origin: padding; -webkit-background-origin: padding-box; background-origin: padding-box;&#125;E3[class~='cont'] &#123; -moz-background-origin: content; -webkit-background-origin: content; -webkit-background-origin: content-box; background-origin: content-box;&#125; 背景重复background-repeat 属性可以控制背景图的重复方式，其取值如下： 默认值 repeat： 水平和垂直方向都重复 可用的关键字取值 no-repeat：不重复 repeat repeat-x： 仅在水平方向重复 repeat-y： 仅在垂直方向重复 通过设置这些值中的某一个可以使背景图沿着元素的某一轴线（或者两条轴线）进行平铺，但无法实现更为精确的控制。CSS3 引入了两个新的属性值： space： 背景图以相同的间距（除了第一次和最后一次）平铺且填充在整个容器或某个方向。不会对背景图进行裁剪和缩放，容器内重复的背景图之间可以看到有明显间距 round： 会缩放背景图，尽可能多地进行重复直到适应且填充整个容器。这个属性值将计算能够水平和垂直填充包含元素的图片的最大完整数量。 background-*属性简写background-* 独立属性纷杂繁多，简写时需要按照以下规则： 1background: background-image background-position/background-size background-repeat background-attachment background-origin background-clip background-color; 下面以示例说明： 123456div &#123; background: url('test1.png') no-repeat scroll 10px 20px/50px 60px content-box padding-box, url('test2.png') no-repeat scroll 10px 20px/70px 90px content-box paddign-box, #aaa;&#125; 由于 background-color 只能设置一次，且由于写在前面的背景会叠在之后的背景上，所以背景色通常都定义在最后一组上，避免背景色将背景图遮盖。 上面示例代码等价于以下独立属性写法： 12345678910div &#123; background-image : url('test.png'), url('test2.png'); background-repeat : no-repeat, no-repeat; background-attachmnet : scroll, scroll; background-position : 10px 20px, 10px 20px; background-size : 50px 60px, 70px 90px; background-origin : content-box, content-box; background-clip : padding-box, padding-box; background-color : #aaa;&#125; 如果定义了多个背景图片，而其他属性的参数值只有一个，那么这些参数值就会被应用到所有背景图上，根据此原则，可以对上面代码进行缩写：12345678910div &#123; background-image : url('test2.png'), url('test2.png'); background-repeat : no-repeat; background-attachment : scroll; background-position : 10px 20px; background-size : 50px 60px, 70px 90px; background-origin : content-box; background-clip : padding-box; background-color : #aaa;&#125; 另外，如果定义了多个背景图片，而 background-origin 和 background-clip 设置了相同的值，还可以简写为： 123456div &#123; background: url('test1.png') no-repeat scroll 10px 20px/50px 60px padding-box, url('test2.png') no-repeat scroll 10px 20px/70px 90px padding-box, #aaa;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3之美（六）：多列]]></title>
      <url>%2F2016%2F10%2F26%2FCSS3%E4%B9%8B%E7%BE%8E%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E5%A4%9A%E5%88%97%2F</url>
      <content type="text"><![CDATA[CSS3 原生支持多列布局，这不得不说是一大亮点，尽管现在浏览器还存在兼容性问题。 分列布局方法指定分列：column-count属性 column-count 可以用于把内容划分为均等分布的几列，其语法如下： 1E &#123; column-count: columns; &#125; 其中，E 为要划分的内容的父元素，columns 为一个整数，用于设置分列的数量。 动态分列：column-width属性 column-width 用于设定分列后的每列的宽度，其语法如下： 1E &#123; column-width: length; &#125; 其中，length 用于设置分列后的每一列的宽度，其值可以是长度单位或者百分比值。 更好地可读性在使用多列布局时，要注意外边距 margin 和 padding 仍然会应用到内容上，所以可能导致在分列的顶部或底部的段落和非固定文本行之间出现不必要的空行，二者都会影响到可读性。 为了在每个段落开始的时候缩进，段落之间不要留下边距。我们可以使用以下方式辅助多列布局： 12345.columns p &#123; margin-bottom: 0; text-indent: 1em; text-align: justify;&#125; Firefox和Webkit中不同的分配方式文本在各个浏览器中被划分到各列之中会有所不同。Firefox 的方法是让大多数的列有相同数量的行，最后一列比其他部分稍长或稍短一些。与此相反，Webkit会让所有列的高度尽可能均等。 之所以会出现这种情况，是因为以前的规范版本（从2001年到2005年）从来没有明确过排印材料应该如何在各分列之间进行平衡，所以浏览器厂商就会提出自己的解决方案。W3C 在后来的规范版本中通过使用 column-fill 属性解决了这个问题： 1E &#123; column-fill: value; &#125; 其中，column-fill 的属性值取值如下： auto： 各列高度自适应，像 Firefox 那样 balance： 默认值，所有列的高度以其中最高的一列统一，像 Webkit 那样 column-count和column-width的结合我们可以在同一个元素上同时设置 column-count 和 column-width 属性，但是这样会有些冲突：如果两个属性应用到同一个元素上，并且将 column-count 属性写在前面的话，那么 column-count 值的作用就像是设置了最大值。 1234.columns &#123; column-count: 5; column-width: 100px;&#125; 这段代码本质上的逻辑是：把文本划分为 100px 的列，如果会产生 5 个或 5 个以上的列，就生成有 5 个最小的宽度是 100px 的列。然而，Webkit 错误地实现了这一规则，它创建了 5 个 100px 的列，留下毫无意义的白色空间。 如果要同时使用这两个属性，我们可以像下面这样使用简写属性 columns： 1E &#123; columns: column-width column-count; &#125; 列间隔与分界线在使用动态布局的时候，浏览器应该会在每一列之间放入默认的 1em 的间隔（在使用动态布局的时候，1em是最小的宽度）。不过，我们可以使用两个新的属性 column-gap 和 column-rule 去修改默认的值并指定自己的间隔距离。 column-gap： 用于设置各个列之间的缝隙空间，语法如下： 1E &#123; column-gap: length; &#125; 其中，length 值可以是带有标准 CSS 长度单位的任何数字。 column-rule： 使用这个属性相当于画了一条线，类似于一条边界，等距离地位于各列之间。column-rule 实际上是以下三个独立属性的简写形式： column-rule-width column-rule-style column-rule-color 这三个属性使用的值与 CSS2 中 border-* 属性是一样的。其语法如下： 12345678E &#123; column-rule-width: length; column-rule-style: border-style; column-rule-color: color; /* 简写方式 */ column-rule: length border-style color;&#125; 跨越多列的元素为了处理那些需要横跨不止一列进行显示的元素，模块引入了 column-span 属性，它的语法是： 1E &#123; column-span: value; &#125; 在这里，value 只能是以下两个可能值之一： 1： 默认值，让元素保持在分列流中 all： 将在流中出现中断——所有在元素（E）之前的内容将会分配在各列当中，所有在元素之后的内容也会被分配到各列之中，但元素本身则不会。 打破多列的元素对于其他的非文本元素，比如子标题或者列表，它们不应该出现在各列之中被拆分，这些又该如何处理呢？一列结束而下一列开始的点被称为断行，我们可以使用 break-after break-before break-inside 属性来处理断行产生新列的方式。 12345678E &#123; break-after: keyword; &#125;/* 设置元素之前的断行方式 */E &#123; break-before: keyword; &#125;/* 设置元素之后的断行方式 */E &#123; break-inside: keyword; &#125;/* 设置元素内部的断行方式 */ 上面每个属性都接受一系列的关键字值，三个属性全部都接受 auto，avoid 值，而 break-after 与 break-before 属性允许使用额外的值 column 和 always。always 值可以保证总是断行并产生新列。 avoid 值可以保证没有中断紧挨在指定元素之前或之后发生（不论应用了哪个属性），而 column 值的作用则是相反的，它强制中断发生在元素之后或之前。所有这些属性的默认值都是 auto，它既不强制也不禁止中断的发生，让浏览器去决定中断是否应该发生在元素之前、之后或内部。 这些属性可以被应用到不突破一列的元素上，它们会命令浏览器在列的哪个地方应用中断。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3之美（五）：网页文本]]></title>
      <url>%2F2016%2F10%2F26%2FCSS3%E4%B9%8B%E7%BE%8E%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%96%87%E6%9C%AC%E9%98%B4%E5%BD%B1%2F</url>
      <content type="text"><![CDATA[CSS3 全新引入的文本阴影特性值得让人兴奋，现在，我们只需简单的几句语句既可以让文本拥有阴影效果了，赞b(￣▽￣)d！ 文本阴影text-shadowtext-shadow 属性是用于设置文本阴影的，其总共可接受 4 个参数，语法如下：1E &#123; text-shadow: left top blur color &#125; 其中： left 为阴影相对于元素左上角的水平偏移值（向右为正，允许负值） top 为阴影相对于元素左上角的垂直偏移值（向下为正，允许负值） blur 为阴影的模糊程度（不允许负值），其值越大阴影越模糊，该值可以省略，如果省略，默认为0 color 为阴影的颜色 当然了，我们可以为同一元素使用多个阴影，这样就能有多重阴影的效果了： 12345678910111213141516.one &#123; text-shadow: 0 -2px 3px #FFF, 0 -4px 3px #AAA, 0 -6px 6px #666, 0 -8px 9px #000;&#125;.two &#123; color: #FFF; text-shadow: 0 2px rgba(0, 0, 0, 0, 4), 0 4px rgba(0, 0, 0, 0, 4), 0 6px rgba(0, 0, 0, 0, 4), 0 8px 0 rgba(0, 0, 0, 0, 4);&#125; 活版印刷效果See the Pen 活版印刷效果 by lfkid (@lfkid) on CodePen. text-fill-color该属性是 Webkit 浏览器的专有属性，主要用于设置元素中的文字的填充颜色。使用示例如下： 123h1 &#123; text-fill-color: transparent;&#125; 注意：如果该属性不设置，则会继承 color 属性的值，如果设置了该属性，则会覆盖掉 color 属性的值。 利用这个属性，可以很轻松地做出镂空文字： See the Pen 文字镂空效果 by lfkid (@lfkid) on CodePen. text-outline和text-strokeCSSS3 的文本模块提供了一种更好的控制轮廓的方式，即 text-outline 属性，这个属性可以接受三个值：1E &#123; text-outline: thickness blur color &#125; 其中： thickness： 描边厚度，必需要有 blur： 模糊程度，可选 color： 描边颜色，必需要有 注意：text-outline 属性当前未得到任何主流浏览器的支持实现。 庆幸的是，Webkit 引擎的浏览器实现了另一个与之类似的专有属性 text-stroke。text-stroke 属性用法如下： 1234567E &#123; text-stroke-width: value; text-stroke-color: value;&#125;/* 简写属性 */E &#123; text-stroke: width color &#125; 以其简写方式为例，其中： width： 描边宽度 color： 描边颜色 值得注意的是 text-stroke-width 的属性值不可过大，因为太高的宽度值，会让文本变得难以辨认，不好看。个人建议最佳实践是大小保持在 3px 以内。 限制文本溢出text-overflow 属性用于控制文本在容器中溢出时的表现，其属性值有两个 clip 默认值，将溢出元素容器的文本内容截断 ellipsis 在溢出之前使用省略号（…）替换掉最后的字符 注意：要使得 text-overflow 属性生效，块容器必须显示定义 overflow 为非 visible 值，同时显示或者隐式地定义 width 为非 auto 值，white-space 为 nowrap 值。 改变元素大小resize 属性可以设置是否允许用户缩放，调节元素尺寸大小。 注意：若要使此属性生效，必须设置元素的 overflow 属性，值可以是 atuo，hidden 或 scroll。 resize 属性值可取的关键字值有： none 不允许用户调整大小 horizontal 可以调整宽度 vertical 可以调整高度 both 用户可以调节元素的宽度和高度 文本对齐属性 text-align 已经存在一段时间了，但 CSS3 为它添加了两个新的属性值： start end 这两个属性对于习惯从左到右阅读的人来说，分别相当于值 left 和 right。不过，对于那些可能会使用从右至左文本的国际化网站，它们的作用是显而易见的。 CSS3 新引入了一个名为 text-align-last 的属性，它允许我们单独控制文本的最后一行的对其方式。这个属性接受和 text-align 属性一样的值。 文本换行word-wrapword-wrap 属性指定浏览器是否可以把长单词折断，使其容纳在父元素中。其属性值可以取如下值： normal 默认值，允许内容顶开或溢出指定的容器边界 break-word 内容将在边界内换行。如果需要，单词内部允许换行 设置文本渲染选项Firefox 和 Webkit 浏览器支持一个名为 text-rendering 的属性，允许开发者控制文本渲染速度或者对文本可识别性的优化。这个新特性意味着开发者可以选择浏览器如何渲染页面上的文本。其语法如下: 1E &#123; text-rendering: keyword; &#125; 该属性值有四个指定的关键字值： auto： 默认值，允许浏览器做出渲染的选择 optimizeSpeed： 速度优先于可识别性，禁用高级字体特性以得到更快的渲染 optimizel： 可识别性优先于速度 optimizeLegibility geometric-Precision]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3之美（四）：网页字体]]></title>
      <url>%2F2016%2F10%2F26%2FCSS3%E4%B9%8B%E7%BE%8E%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BD%91%E9%A1%B5%E5%AD%97%E4%BD%93%2F</url>
      <content type="text"><![CDATA[CSS 新引入了 @font-face，我们终于可以在 Web 世界里也随心所欲地使用字体了。 @font-face规则CSS3 字体模块最令人兴奋的事儿就是我们可以在网页中使用自定义字体了，它的核心语法就是 @font-face。其基本语法如下： 1234@font-face &#123; font-family: nmae; src: local('font-name'), url('/path/filename.otf') format('opentype');&#125; 下面具体解释上面代码的含义： font-family： 用于给自定义字体起个名字，当然，我们也可以使用多个用空格隔开的单词，只要把它们放入引号即可。 src： 即所引用字体的位置。该属性接受几个不同的值： local()： 所引用字体本来的名字，它主要是用于检查用户计算机上是否已经安装了同名字体； url： 所引用字体的网络位置，用于当字体在本地不可用时； foramt： 用于指定字体类型，毕竟不同的设备可能使用不同类型的字体文件。 注意： src 属性的 local() 值后面有个逗号。 定义不同的风格font-face 语法是非常简单的，但它只定义了一种字体风格。如果我们要使用同一字体的不同风格，就需要单独地定义每种字体的风格。为此，我们可以使用两种方法来实现： 重用相同的名称并把额外的描述符添加到 font-face 规则上： 12345678910@font-face &#123; font-family: 'Museo Sans'; src: local('Museo Sans'), url('MuseoSans.otf') format('opentype');&#125;@font-face &#123; font-family: 'Museo Sans'; font-style: italic; src: local('Museo Sans'), url('MuseoSans_Italic.otf') format('opentype');&#125; 为每种字体样式提供独一无二的名称，并且在字体栈中单独去调用它们： 12345678@font-face &#123; font-family: 'Museo Sans'; src: local('Museo Sans'), url('MuseoSans.otf') format('opentype');&#125;@font-face &#123; font-family: 'Museo Sans Italic'; src: local('Museo Sans'), url('MuseoSans_Italic.otf') format('opentype'); 上面这两种方式，个人更为推荐第二种，清晰易懂，简洁明了。 真实字体风格VS人造字体风格真实字体风格即字体源文件就是那种风格的，而人造字体风格指的是通过修改 font-style 属性让正常字体变为想要的风格。下面是代码对比： 12345678910111213141516171819@font-face &#123; font-family: normal font; src: local('normal font'), url('normal font.otf') format('opentype');&#125;* &#123; font-family: "normal font"; font-style: italic;&#125;/* 以上为真实字体风格 *//* 以下为人造字体风格 */@font-face &#123; font-family: italic font; src: local('italic font'), url('italic font.otf') format('opentype');&#125;* &#123; font-family: "italic font";&#125; 上述两种方式的差别还是有一定程度的： 第一种方式源文件是普通字体，通过在使用时改变 font-style 属性值从而到达仿造的斜体效果 而第二种方式源文件就是斜体风格的相应字体，使用时无需额外改变字体风格样式，是真实的斜体。 万无一失的@font-face语法使用本地字体src 属性的 local 值用于检查用户是否已经把定义的字体安装在了计算机上，如果用户做了，那么就可以直接应用本地拷贝，而不用再下载字体文件了。唯一遗憾的是，local 不受 IE9 以下版本的所有浏览器支持。 解决这个缺点的变通方案依赖于 IE8 及其以下版本只允许使用可嵌入开放型字体格式（Embeddable Open Type，EOT）。由于使用了 EOT，我们可以声明两次 src 属性： 12345@font-face &#123; font-family: name; src: url('filenmae.eot'); /* 兼容 IE8 及以下版本 */ src: local('fontname'), url('filename.otf') format('opentype');&#125; 下一个缺点就是 Safari 浏览器使用不同的字体名称参数作为 local() 的值。字体通常有两个名称：一个完整的名称和一个 PostScript 名称。MAC 上的 Safari 需要使用 PostScript 名称，反之其他浏览器接受的是完整名称。解决这个问题是很简单的，只需指定两个 local() 值： 1234@font-face &#123; font-family: name; src: local('fontname'), local('altfontname') url('filename.otf') format('opentype');&#125; 对于第一个 local()值，我们可以使用 PostScript 名称，而对于第二个 local() 值，可以使用其系列名称。 然而，使用字体管理程序可能会导致出现第三个缺点。在某些情况下，字体管理软件会显示不正确的字符或者打开一个对话框，询问用户使用字体的许可。解决这一缺点的唯一方式就是添加一个”空“值给 local，强制下载所定义的字体。这个空值只要是个单独字体就行啦。 所以，将这一节的所有解决方案综合在一起，我们会得到如下代码： 12345@font-face &#123; font-family: name; src: url('filename.eot'); src: local('☺'), url('filename.otf') format('opentype');&#125; 字体格式IE8 及其以下版本只支持专用的 EOT 格式，而现代浏览器允许使用更加通用的 TrueType 和 OpenType 格式。但是许多商用的字体开发商并不允许他们的字体以这种方式使用，因为这样会使得很容易地获得字体的非法拷贝。处于这个原因，Mozilla 跟一些字体开发商进行了协商，从而创建了网页开放字体格式 WOFF。另外，还有一些浏览器也接受可伸缩矢量图形（SVG）字体格式。 最终的万无一失语法为了让选择的字体在每个平台上的所有浏览器上都具有相同的显示，我们需要使用的代码看上去应该像这样： 12345678@font-face &#123; font-family: name; src: url('filename.eot'); src: local('☺'), url('filename.woff') format('woff'), url('filename.ttf') format('truetype'), url('filename.svg') format('svg');&#125; 下面介绍另一种可靠的新方法，是由一个大神提出来的 1234567@font-face &#123; font-family: name; src: url('filename.eot?') format(eot), url('filename.woff') format('woff'), url('filename.otf') format('otf'), url('filename.svg') format('svg');&#125; 更多的字体属性CSS3 网页字体模块并不仅仅重新引入了 @font-face 规则，它也重新定义唤醒了最先由 CSS2 提议的另外两个字体属性。 font-size-adjust在 CSS 中使用字体栈的唯一缺点就是字体在尺寸上可能会发生变化。当首选字体不可用时，下一备用字体的高度不是我们所能预料的。为了解决这一问题，我们可以使用 font-size-adjust 属性。 1E &#123; font-size-adjust: number &#125; 语法规则中的 number 是指小写字母 x 占所用字体的高度比例。font-size-adjust 属性值接受一个小数值。 font-stretch一些字体系列包含了紧缩和加宽的变体，而 font-stretch 属性被提出用于访问这些变体，其语法如下： 12E &#123; font-stretch: keyword &#125;/* 设置对象中的字体是否横向拉伸变形 */ 其中，font-stretch 属性值可取的关键字 keyword 有以下： normal： （默认值）正常文字宽度 semi-condensed： 比正常文字宽度窄1个基数 condensed： 比正常文字宽度窄2个基数 extra-condensed： 比正常文字宽度窄3个基数 ultra-condensed： 比正常文字宽度窄4个基数 semi-expanded： 比正常文字宽度宽1个基数 expanded： 比正常文字宽度宽2个基数 extra-expanded： 比正常文字宽度宽3个基数 ultra-expanded： 比正常文字宽度宽4个基数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3之美（三）：伪类和伪元素]]></title>
      <url>%2F2016%2F10%2F26%2FCSS3%E4%B9%8B%E7%BE%8E%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%2F</url>
      <content type="text"><![CDATA[伪类和伪元素极大地简化了我们的工作，例如，伪元素，一般网页布局中最脏最累的活儿都是交给它去干的。CSS3 新的伪类和伪元素模块不仅在结构上清晰明了，更丰富了选择器等。 结构伪类CSS2 引入 first-child 之后，它一直都是唯一一个属于这种类型的伪类。但 CSS3 引入了 11 个新的结构伪类，极大地扩展了这一范围。 nth-*伪类基本语法nth-（这里使用 去替代若干不同的值）伪类的用法如下： 1nth-*(n) 默认情况下，n 代表一个从 0 开始的数字，并以 1 递增（1，2，3，等等）。另一个整数可以作为乘数传递给它。例如，2n 就是代表 2 的倍数（2，4，6，等等），3n 就是 3 的倍数（3，6，9，等等），依次类推。下面是个示例： 12345678E:nth-*(n) &#123;&#125;/* 选择器 E 匹配的所有元素都会被选中 */E:nth-*(2n) &#123;&#125;/* 间隔选中 E 选择器匹配的元素 */E:nth-*(3n) &#123;&#125;/* E 选择器匹配的元素集中每隔三个就选中一个 */ 除此之外，我们还可以使用数学运算符 + 和 -，所以 2n+1 就是间隔奇数（1，3，5，等等）选中匹配的元素，3n-1 就是间隔 2，5，8… 选择匹配元素。 该选择符有两个特殊的关键字值可以使用，分别是 odd： 等同于 2n+1，用于选中匹配元素的奇数项 even： 等同于 2n，用于选中匹配元素的偶数项 nth-child和nth-of-typenth-child 在选择元素的时候，是以父元素中子元素的总数为基准，按照计数的位置进行选择；而 nth-of-type 则是仅仅只针对那些特定类型的子元素进行计数。下面是个示例： See the Pen nth-child和nth-of-type伪类选择器示例 by lfkid (@lfkid) on CodePen. nth-last-child和nth-last-of-typenth-last-child 与 nth-last-of-type 伪类接受和 nth-child 与 nth-of-type 没什么大的区别，唯一的区别在于它们是从最后一个位置开始计数的。但是有一点儿需要注意，如果我们使用它们希望从后往前开始计数，那么我们就应该使用 -n 去替代 n。 12345E:nth-last-child(-n) &#123;&#125;/* 选中父元素中指定位置的元素，从最后一个位置向前开始计数 */E:nth-last-of-type(-n) &#123;&#125;/* 选中父元素中某种指定类型的特定位置的元素，从最后一个位置向前计数 */ first-of-type、first-child和last-child、last-of-typefirst-child 和 last-child 比较好理解，即将样式规则应用到父元素的第一个子元素、最后一个子元素上。 而 first-of-type 与 last-of-type 像 nth-of-type 一样，它们所应用的元素，必须是其父元素的某种指定类型的第一个子元素。 1234567891011E:first-child/* 被选择的元素有一个父元素，且其是该父元素的第一个子元素 */E:last-child/* 被选择的元素有一个父元素，且其是该父元素的最后一个子元素 */E:first-of-type/* 被选择的元素有一个父元素，其是该父元素的同类型子元素中第一个元素 */E:last-of-type/* 被选择的元素有一个父元素，其是该父元素的同类型子元素中最后一个元素 */ only-child和only-of-type这两种伪类常用于在文档树中选择这样的元素：该元素有一个父元素，但没有任何的兄弟元素（only-child）或者没有相同类型的兄弟元素（only-of-type）。 12345:only-child/* 被选择元素的父元素有且只有一个子元素，就是当前要选的元素 */:only-of-type/* 被选择元素的父元素中某种指定类型有且只有一个元素，就是当前要选的元素。 */ 其他伪类 target 伪类能够在涉及的 URL 被使用的时候，把样式应用到指定元素上。如果要在 URL 被单击时把样式应用到元素上，可以使用 1#my_id:target &#123;&#125; empty 伪类选择没有子元素（包括文本节点）的元素。 root 伪类选择文档树中的第一个元素，它的唯一真正作用就是发生在为 XML 文档添加样式表的时候——在 HTML 中，root 永远是 html 元素。在 HTML 中使用 root 也有一个小优点，就是可以用它为 html 元素赋予更高的特殊度，这在需要覆盖简单类型选择器的时候是很有用的。 not 伪类在选择元素时，选择的是除了作为参数值给出的元素之外的所有元素。传入 not 伪类的参数必须是一个简单的选择器——所以连接符（比如 + 和 -）以及伪类元素都不是有效的值。 UI元素状态伪类UI元素状态伪类根据用户界面（UI）元素的状态进行选择。尽管 HTML5 提出了一系列的 UI 元素，但在 HTML 中，只有 form 元素能够拥有状态： 12345678E:checked &#123;&#125;/* 匹配用户界面上处于选中状态的 E 元素（用于input type为radio与checkbox时） */E:disabled &#123;&#125;/* 匹配用户界面上处于禁用状态的 E 元素 */E:enabled &#123;&#125;/* 匹配用户界面上处于可用状态的 E 元素 */ 伪元素CSS2 中共有四个伪元素，分别是 :first-line：仅作用于块级元素，设置对象内的第一行的样式 :first-letter：仅作用于块级元素，设置对象内的第一个字符的样式 :before：在选中元素的子元素位置之前插入，必须设置 content 属性值 :after：在选中元素的子元素位置之后插入，层叠顺序在 E::before 之下，必须设置 content 属性值 CSS3 仅仅引入了两个新的伪元素： ::placeholder： 用于设置对象文字占位符的样式（placeholder 是HTML5的表单新属性之一） ::selection：设置对象被选中时的样式，该伪元素只能定义被选择时的background-color，color 和 text-shadow 但是 CSS3 对原有伪元素的定义进行了优化， 像伪类一样，伪元素提供的也是在文档树中没有具体指明信息。但是在文档树中，伪类利用的是一些虚幻的条件，比如元素在文档树中的位置或元素的状态，而伪元素就更远了，它可以把样式应用到文档树中根本就不存在的元素上。 CSS3 引入了新的语法用于区分伪元素和伪类。在 CSS3 中，伪元素的前缀使用的是双冒号（::），不过为了保证向后兼容，浏览器依然支持单冒号的写法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3之美（二）：选择器]]></title>
      <url>%2F2016%2F10%2F17%2FCSS3%E4%B9%8B%E7%BE%8E%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
      <content type="text"><![CDATA[CSS3 选择器模块新引入的各种选择器让人目不暇接，这么多丰富的选择器我们一起来认识一下吧 属性选择器属性选择器是在 CSS2 中引入的，它能根据元素的属性以及这些属性的值对元素进行匹配。CSS2 定义的4个属性选择器如下： 1234567891011E[attr] &#123;&#125;/* 选择具有 attr 属性的 E 元素 */E[attr="value"] &#123;&#125;/* 选择属性 attr 值为 value 的 E 元素 */E[attr~="value"] &#123;&#125;/* 选择具有 attr 属性且属性值是一用空格分隔的单词列表，其中一个等于 value 的 E 元素（包含只有一个值且该值等于value的情况） */E[attr|="value"] &#123;&#125;/* 选择具有 attr 属性且属性值是以 value 开头并用连接符"-"分隔的字符串的 E 元素，如果属性值仅为 value，也将被选择 */ CSS3 中新增了如下属性选择器： 12345678E[attr^="value"] &#123;&#125;/* 选择具有 attr 属性且属性为以 value 开头的字符串的 E 元素 */E[attr$="value"] &#123;&#125;/* 选择具有 attr 属性且属性值为以 value 结尾的字符串的 E 元素 */E[attr*="value"] &#123;&#125;/* 选择具有 attr 属性且属性值为包含 value 的字符串的 E元素 */ 多属性选择器当然了，我们可以把多个属性选择器串拼接在一起，这样在选择目标的时候能够做到非常的具体。使用多属性选择器，可以通过定义在开始、结束以及中间任意位置的值创建应用到属性上的规则。下面是个例子： See the Pen 多属性选择器示例 by lfkid (@lfkid) on CodePen. 上面的示例将 CSS3 新增的 3个属性选择器串接在一起使用，从而选中了第二个 &lt;a&gt; 元素，并将样式应用到了其上。 关系选择器CSS2 中定义了 3 个关系选择器，如下： 12345678E F /* 后代选择器 *//* 选择所有被 E 元素包含的后代 F 元素 */E&gt;F /* 子选择器 *//* 选择所有作为 E 元素的子元素 F */E+F /* 相邻兄弟选择器 *//* 选择紧邻在 E 元素之后的且与其位于文档树同一层级的兄弟元素 F */ CSS3 对于关系选择器，仅仅引入了一个新的选择器： 1E~F /* 普通兄弟选择器 */ 这个选择器与 CSS2 中的兄弟选择器 E+F 有些相似，二者的异同点在于： 二者均选择的均为与 E 位于 DOM 同一层级并位于 E 之后的兄弟元素 后者选择的仅仅是 DOM 同一层级中与 E 相邻的兄弟元素 前者选择的是 DOM 同一层级中 E 之后的所有兄弟元素]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[纯CSS实现加载动画效果]]></title>
      <url>%2F2016%2F10%2F17%2F%E7%BA%AFCSS%E5%AE%9E%E7%8E%B0%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%2F</url>
      <content type="text"><![CDATA[CSS3 的动画模块真是让人无限期待，能做的事儿太多了。 今天我们将使用纯 CSS3 实现一个简单的加载动画效果。 分析先上最终效果，如下： See the Pen sample loading by lfkid (@lfkid) on CodePen. 要想实现上面这个简单的动画效果，我们有两个问题需要解决： 如何让盒模型的元素显式为圆形 如何让元素动起来 下文分别对这两个问题进行解释 显示圆形为了实现上面这个最基础的的 CSS3 加载动画效果，我们首先必需得让盒模型的元素显示为圆形。 在解决这个问题之前，我们先看一下 CSS 盒模型中 border 的本质： See the Pen BzwQPr by lfkid (@lfkid) on CodePen. 从上面，我们应该可以看到元素盒模型中 border 的本质：元素每个方向上的 border 是梯形而并非矩形。 明白了这一点，我们再思考如何让元素显示为圆形。要么让边框称为弧形，要么让四个角为弧形，只要这个弧形的半径足够大就可以使元素看起来为圆形。所以，我们可以使用 border-radius 属性，为了让最终效果呈现为圆形，我们将 border-rasius 的属性值设置为元素几何中心到顶点的距离，即 border-radius: 50%。 See the Pen circle by lfkid (@lfkid) on CodePen. 这样一来，我们就解决了第一个问题，接下来，就是如何动画的问题了。 让元素动起来为了让元素动起来，我们需要使用 CSS3 中的动画模块。 这里，我就不再详述 CSS3 动画的原理了，只说一下实现上面最终效果图的原理。 将 div 的背景色设为与页面相同颜色 div 三个方向的 border 颜色设为另一种相同颜色，而剩余一个方向的 border 单独设为一种颜色 将整个圆形化的 div 绕中心旋转一周的变化设置为动画 本质上，整个元素都在运动，只不过由于颜色的原因，我们肉眼观看感觉到的是一段弧在圆环里转动。 以上，一个简单的 CSS 加载动画效果便完成了。 See the Pen sample loading by lfkid (@lfkid) on CodePen. 参考 Single Element CSS Spinners How TO - CSS Loader]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3之美（一）：媒体查询]]></title>
      <url>%2F2016%2F10%2F16%2FCSS3%E4%B9%8B%E7%BE%8E%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%2F</url>
      <content type="text"><![CDATA[长期以来，在CSS中有一种方法可以为不同的媒体类型提供不同的样式，这种方法就是使用 link 元素的 media 属性： 1&lt;link rel="stylesheet" href="style.css" media="screen"&gt; 但是，如果屏幕尺寸有可能在 3.5 英寸到 32 英寸之间时，使用这种方式就没什么用了。对于这个问题，CSS3 通过媒体查询模块 Media Queries Module 提供了解决方案。 媒体查询提供了一种查询语法去扩展媒体类型，这种查询语法可以更加具体地为用户的设备提供样式。它解决了许多问题，使用它的好处如下： 媒体查询会基于设备的属性来检测设备，这样就不需要使用浏览器检测脚本了 允许直接按照设备的功能去设定样式表 对于小屏幕的设备，CSS规则会自调整以适应屏幕尺寸 媒体查询的基础知识引入CSS样式为一个 HTML 元素应用 CSS 样式有三种方式。同样地，当然首先也是为相应的媒体查询条件引入 CSS 样式也有三种方式： 使用 link 元素去调用一个外部样式表： 1&lt;link rel="stylesheet" href="style.css" media="logic media and (expression)"&gt; 使用 @import 指令调用外部的样式表： 1@import url('file') logic media and (expression); 在一个嵌入 style 属性的 HTML 元素中或在样式表本身利用扩展的 @media 规则使用媒体查询：1@media logic media and (expression) &#123; rules &#125;; 如果针对媒体查询的CSS代码量大，推荐使用第1种方式，将其单独组织为一个样式表文件并通过特定语法引入到HTML文件中。如果针对媒体查询的CSS代码量较少，则推荐使用第3种方式，在主要样式表中使用特定语法写出即可。 基本语法下文以上文的第三种方式为例，详析一下媒体查询的基本语法：1@media logic media and (expression) &#123; rules &#125; media 属性主要用来声明样式要应用的媒体类型，就像 HTML 的 link 标签一样：1&lt;link href="style.css" rel="stylesheet" media="screen, projection"&gt; 和当前语法一样，在使用 media 属性时我们可以使用逗号隔开的列表去选择多种媒体类型，不过我们最长用的媒体类型还是 screen，即用于计算机显示器。 @media的规则的第一个属性是logic，可选，值可以为only或not。123@media only media and (expression) &#123; rules &#125;/* ----- or ----- */@media not media and (expression) &#123; rules &#125; 如果要对不支持该语法的浏览器隐藏规则，可以使用 only 值；对支持该语法的浏览器而言，only 可以被有效地忽略。 not 值有点儿补集的思想，即否定此次特定的媒体查询。如果浏览器不满足设置的参数，就可以使用 not 来应用这些样式。 expression 属性用于接受参数并根据这些参数选择 CSS 样式响应何种设备。我们可以使用 and 操作符去声明 expression，并用它设置媒体类型以外的参数。这些参数被称为媒体特征。例如： 12@media screen and (min-width: 480px) &#123; rules &#125;/* CSS 规则将会被应用到浏览器窗口宽度大于等于 480px 的设备 */ 详解媒体特征媒体特征前面说到 expression 属性是根据媒体特征参数选择响应何种设备的，那么什么是媒体特征呢？ 媒体特征就是与显示网页的设备有关的信息，它包括了设备的大小、分辨率等。这些信息被用于匹配一条 expression，若匹配成功则相应的样式规则就会被应用到相应设备上。 在媒体查询中，需要为大多数的媒体特征表达式提供一个值： 1@media media and (feature: value) &#123; rules &#125; 不过在某些情况下，该值也可以被忽略，只对媒体特征本身进行检测： 1@media media and (feature) &#123; rules &#125; width与heightwidth 媒体特征描述了特定媒体类型的渲染视区的宽度，实际上，对于桌面的操作系统来说，通常就是浏览器的当前宽度（包括滚动条）。其基本语法需要一个长度值： 1@media media and (width: 600px) &#123; rules &#125; 看，就是这样，很好理解吧。像读文章一样，上面代码的意思是在宽度为 600px 的浏览器上应用此样式。CSS 还为我们提供了 最小宽度 min-width 和 最大宽度 max-width，方便我们进行更精确地控制，小示例： 12@media screen and (max-width: 480px) and (min-width: 600px) &#123; rules &#125;/* 在浏览器窗口宽度不小于 480px 且不大于 600px 的设备上应用此样式 */ height 也是同样的呀，只不过用得比较少了，毕竟大家在浏览器里都是垂直滚动嘛，很少有人是水平滚动吧。所以不废话了，小结一下吧：123456@media media and (width: value) &#123; rules &#125;@media media and (min-width: value) &#123; rules &#125;@media media and (max-width: value) &#123; rules &#125;@media media and (height: value) &#123; rules &#125;@media media and (min-height: value) &#123; rules &#125;@media media and (max-height: value) &#123; rules &#125; device-width与device-height刚刚的 width 与 height 都是针对浏览器窗口的宽高而言的（包括滚动条），而现在要说的 device-width 与 device-height 则是针对设备本身的宽度和高度。device-width 和 device-height 同 width 和 height 的语法没什么大区别，所以也不废话了，小结一下： 123456@media media and (device-width: value) &#123; rules &#125;@media media and (min-device-width: value) &#123; rules &#125;@media media and (max-device-width: value) &#123; rules &#125;@media media and (device-height: value) &#123; rules &#125;@media media and (min-device-height: value) &#123; rules &#125;@media media and (max-divice-height: value) &#123; rules &#125; 注意： IOS（iPhone、iPad，等等）和 Android 设备会通过四个屏幕侧边中较短的一对去测量 device-width。也就是说，给定尺寸为 480x600 的设备，无论它是纵向显示还是横向显示，其 device-width 都会是 480px。 orientation如果我们需要对水平方向（如网页浏览器）或者垂直方向（如电子书阅读器）两种网页浏览方式进行优化，则需要使用媒体特征 orientation。它的语法如下： 1@media media and (orientation: value) &#123; rules &#125; 其中，value 只允许两个关键字值： landscape： landscape 值会在浏览器宽度大于高度的时候被应用 portrait： 应用场景与 landscape 相反，会在浏览器宽度小于高度的时候被应用 由于媒体特征 orientation 只有两个值，所以如果我们只使用了其中一个值，那么另外一个自然就是相反的。 aspect-ratio/device-aspect-ratio媒体特征 aspect-ratio 用于检测浏览器的宽高比，而 device-aspect-ratio 特征则用于检测设备的宽高比。它们的语法如下： 12@media media and (aspect-ratio: horizontal/vertical) &#123; rules &#125;@media media and (device-aspect-ratio: horizontal/vertical) &#123; rules &#125; 其中，horizontal 表示宽度，而 vertical 表示高度，二者的值都是正整数，最终媒体特征的值代表查看浏览器（或设备）的屏幕宽度与高度对应的比值。例如：16:9、16:10。 DPR(设备像素比)一般而言，CSS像素单位（px）是指计算机屏幕上一个单独像素的大小——如果屏幕的分辨率是 1024px X 768px，我们把一个元素的宽度设置为 1024px 时，可以预期它在水平方向上将填满整个屏幕。不过，对于智能手机和移动设备来说情况并不总是这样。在它们的小屏幕上访问网站，通常需要放大显示，这样会导致屏幕像素大于 CSS 像素。例如，以 100% 的比例缩放页面，意味着 1 个 CSS 像素会以 4 个设备像素（2x2）的大小在屏幕上显示。对于可缩放的内容，比如文本和矢量图形，放大不会导致什么问题；但对于位图格式的图片，放大可能会导致严重失真。 DPR(device pixel ratio)，设备像素比，即设备像素与 CSS 像素的比值。 媒体特征 device-pixel-ratio 可以根据设备的像素比去判断设备，它在 Mobile Webkit 中的实现带有 -webkit- 前缀。 1@media media and (-webkit-device-pixel-ratio: value) &#123; rules &#125; 其中，value 是一个小数，表示设备的像素密度。当然了，和其他媒体特征一样，我们还是会有最小像素密度 min-device-pixel-ratio 和最大像素密度 max-device-pixel-ratio 的： 12@media media and (-webkit-min-device-pixel-ratio: value) &#123; rules &#125;@media media and (-webkit-max-device-pixel-ratio: value) &#123; rules &#125; 多种媒体特征一起用还记得 @media media 后面的那个 and 么，我们可以使用 and 操作符添加表达式，从而把多个媒体特征查询链接在同一个媒体类型上：1@media logic media and (expression) and (expression) &#123; rules &#125; 这种语法在应用选定规则之前，先测试两个表达式是否匹配。 我们也可以在多种媒体类型上设置不同的表达式： 1@media logic media and (expression), media and (expression) &#123; rules &#125; 媒体查询的实际使用以上代码中反复出现的 media 表示媒体类型，这是 CSS2 的语法规范。不过我们最常用的还是 screen 即用于计算机显示器。 下面是个小例子： 123456789@media screen and (min-width: 400px) &#123; h1 &#123; background: block url('bc.jpg') no-repeat 50% 50%; color: white; height: 190px; margin-bottom: 0; padding: 20px; &#125;&#125; 上面的 CSS 规则只会被应用到浏览器窗口大于等于 400px 的设备。 一般来说，我们可能倾向于先创建一个为较大的浏览器或设备而优化的样式，再使用媒体查询为较小的设备提供不同的样式。但是在现实中，我们却可能不会这样做，由于某些浏览器加载页面资源（比如样式表中包含的图片）的方法所致。 一般媒体查询的早期使用者，先使用大的背景图片，之后在移动设备设置 disaply: none，将图片隐藏起来。不过，尽管这些背景图片不会显示，但仍然可能被下载并存放在缓存中。这种方式增加了页面的加载时间，也可能会消耗带宽流量——这对于没有无线连接的设备用户来说确实很糟糕。 所以，创建页面的更好方法是先为移动用户制作一个基本的样式表，然后再为桌面用户制作一个带较大资源的样式表，最后使用像 device-width 这样的媒体特征进行查询来加载。 12&lt;link href="mobile.css" rel="stylesheet" media="screen"&gt;&lt;link href="desktop.css" rel="stylesheet" media="screen" and (min-device-width: 480px)"&gt; 如上，采用这种方式把样式表分开后，对于屏幕宽度小于 480px 的设备，将不会加载 desktop.css 文件，那些大资源自然也不会在后台下载了。 这种方式最大的例外就是 IE。IE9 以下的版本都不支持媒体查询，为了解决这个问题，我们需要 CSS Hack： 12345&lt;link href="mobile.css" rel="stylesheet" media="screen"&gt;&lt;link href="descktop.css" rel="stylesheet" media="screen and (min-device-width: 480px)"&gt;&lt;!--[if It IE 9]&gt; &lt;link href="desktop.css" rel="stylesheet" media="screen"&gt;&lt;![endif]--&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[详解CSS的矩阵变换函数matrix()]]></title>
      <url>%2F2016%2F05%2F03%2F%E8%AF%A6%E8%A7%A3CSS%E7%9A%84%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E5%87%BD%E6%95%B0matrix%2F</url>
      <content type="text"><![CDATA[本文并不会讲解矩阵运算，也不会讲解矩阵变换的几何意义，那将是一个数学展开，颇为无味枯燥。话说大学修过线性代数的人应该都已经学过了，如果忘了，找本线性代数教科书看看就行。下文仅仅给出 CSS 矩阵变换函数的语法，以及其与对应的变换矩阵、变换函数间的联系。 矩阵变换的原理在 2D变换 中，矩阵变换函数 matrix() 接受 6个值，语法形式如下： 1E &#123; transform: matrix(a, b, c, d, e, f); &#125; 这相当于，对元素应用一个如下的变换矩阵： $$ \begin{bmatrix} a &amp; c &amp; e \ b &amp; d &amp; f \ 0 &amp; 0 &amp; 1 \ \end{bmatrix}$$ 那么这个变换矩阵是如何被用来对元素进行几何变换的呢？ 假设变换原点 transform-origin 的坐标是 $(0, 0)$，元素所呈现出来的几何图形中任意一点的坐标是 $(x_i, y_i)$，那么所谓的根据变换矩阵进行变换就是使用这个点的坐标 $(x_i, y_i)$ 的向量矩阵： $$ \begin{bmatrix} x_i \ y_i \ 1 \ \end{bmatrix}$$ 与变换矩阵相乘： $$ \begin{bmatrix} a &amp; c &amp; e \ b &amp; d &amp; f \ 0 &amp; 0 &amp; 1 \ \end{bmatrix} \begin{bmatrix} x_i \ y_i \ 1 \ \end{bmatrix} = \begin{bmatrix} ax_i + cy_i + e \ bx_i + dy_i + f \ 1 \ \end{bmatrix}$$ 相乘所得到的矩阵向量就是点 $(x_i, y_i)$ 进行变换之后的新坐标： $$ \begin{bmatrix} ax_i + cy_i + e \ bx_i + dy_i + f \ 1 \ \end{bmatrix}$$ 即根据变换矩阵进行变换之后点 $(x_i, y_i)$ 的坐标是 $(ax_i+cy_i+e, bx_i+dy_i+f)$。 在 2D变换中，变换总共有以下几种操作： 平移：transform: translate(X, Y) 旋转：transform: rotate(θ) 倾斜：transform: skew(α, β) 缩放：transform: scale(scaleX, scaleY) 这些对应的变换矩阵分别如下： 平移对某一元素应用旋转变换 translate(X, Y)，相当于对其应用如下变换矩阵： $$ \begin{bmatrix} 1 &amp; 0 &amp; X \ 0 &amp; 1 &amp; Y \ 0 &amp; 0 &amp; 1 \ \end{bmatrix}$$ 即等价于使用矩阵变换函数 matrix(1, 0, 0, 1, X, Y)。 旋转对某一元素应用旋转变换 rotate(θ)，相当于对其应用如下变换矩阵： $$ \begin{bmatrix} \cos\theta &amp; -\sin\theta &amp; 0 \ \sin\theta &amp; \cos\theta &amp; 0 \ 0 &amp; 0 &amp; 1\ \end{bmatrix}$$ 即等价于矩阵变换函数 matrix(cosθ, sinθ, -sinθ, cosθ, 0, 0)。 倾斜对某一元素应用倾斜变换 skew(α, β)，相当于对其应用如下变换矩阵： $$ \begin{bmatrix} 1 &amp; \tan\alpha &amp; 0 \ \tan\beta &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 1 \ \end{bmatrix}$$ 即等价于使用矩阵变换函数 matrix(1, tanβ, tanα, 0, 0)。 缩放对某一元素应用缩放变换 scale(scaleX, scaleY)，相当于对其应用如下变换矩阵： $$ \begin{bmatrix} scaleX &amp; 0 &amp; 0 \ 0 &amp; scaleY &amp; 0 \ 0 &amp; 0 &amp; 1 \ \end{bmatrix}$$ 即等价于使用矩阵变换函数 matrix(scaleX, 0, 0, scaleY, 0, 0)。 实际应用为什么有直接诸如 rotate(θ) 这些简单可用的变换函数，我们还需要 matrix() 这么复杂的东西呢？ 这里实际上有两个原因： 用 CSS 组合实现各种变换，在配合 JavaSCript 使用时，最经常遇到的是使用 JavaScript 改变部分属性值，会覆盖所有的原始变换的问题 在浏览器中获取 CSS 样式时，我们获取 transform 的属性值时实际上返回的是矩阵变换函数 matrix(a, b, c, d, e, f)，并不是单一的变换函数。（！！！注意）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[style currentStyle getComputedStyle]]></title>
      <url>%2F2016%2F05%2F02%2Fstyle-currentStyle-getComputedStyle%2F</url>
      <content type="text"><![CDATA[style currentStyle getComputedStyle 傻傻分不清楚，本文试图对三者做一个详细区分对比，帮助理解记忆。 还得从引入样式说起为一个 HTML 元素引入 CSS 样式有如下三种方式： 内嵌样式： 即样式直接写在 HTML 元素的标签内的 style 属性中 内部样式： 即样式写在 HTML 文件中的 &lt;style&gt; &lt;/style&gt; 标签内 外部样式表： 即样式写在外部的 .css 文件中，然后通过一定方式引入到相应的 HTML 文件中 获取内嵌样式对应三种样式引入方式，我们获取样式时也有三种方式：我们通常所使用的 document.getElementById(&apos;#id&apos;).style 是用来直接获取元素标签内 style 属性的内容的。 虽然 style 对象能够提供支持 style 特性的任何元素的样式信息，但它不包括那些从其他样式表层叠而来并影响到当前元素的样式信息。 获取计算样式：getComputedStyle要说起这个方法还得从 DOM2级 说起： “DOM2级视图”模块增加了一个名为 defaultView 的属性，其中保存着一个指针，指向拥有给定文档的窗口或框架。除此之外，“视图”规范并没有提供什么时候其他视图可用的信息。因而这是唯一一个新增的属性，除 IE 之外的所有浏览器都支持 defaultView 属性。在 IE 中有一个等价的属性名叫 parentWindow（Opera也支持这个属性）。因此，要确定文档窗口，可使用以下代码： 1var parentWindow = document.defaultView || document.parentWindow; “DOM2级样式” 增强了 document.defaultView，提供了 getComputedStyle 方法，这个方法接受两个参数： 要取得计算样式的元素 一个伪元素字符串 如果不需要伪元素信息，那么第二个参数可以是 null。getComputedStyle 方法返回一个 CSSStyleDeclaration 对象（与 style 属性的类型相似），其中包含当前元素的所有计算样式。 下面解释一下什么叫做计算样式。 前面说过，某个元素的 CSS 样式可以有三种方式指定，而 CSS 样式的规则是层叠的，也就是说，对于通过各种途径为元素指定的 CSS 样式（包括浏览器默认样式），浏览器会在渲染显示元素之前计算它们得出一个 CSS 属性值集合，这个浏览器用于显示该元素的 CSS 属性值集合就被称为 计算样式。 注意： 无论在哪个浏览器中，“计算样式” 都是只读的，不能修改计算后样式对象中 CSS 属性。也就是说 getComputedStyle 方法只能用来获取元素的样式，并不能用于修改元素的样式。 那么，currentStyle什么鬼？说之前，我们先诅咒一下啊万恶的 IE。IE 是不支持 ”DOM2级样式“ 中的 getComputedStyle 方法的，但它有一种类似的概念。 在 IE 中，每个具有 style 属性的元素还有一个 currentStyle 属性。这个属性是 CSSStyleDeclaration 的实例，包含当前元素全部都计算后的样式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[document.compatMode?CSS1Compat?BackCompat?]]></title>
      <url>%2F2016%2F04%2F17%2Fdocument-compatMode-CSS1Compat-BackCompat%2F</url>
      <content type="text"><![CDATA[万恶的兼容性，万恶的 IE，document.compatMode? CSS1Compat? BackCompat? WTF？ IE对盒模型的渲染在 Standards Mode 和 Quirks Mode 是有很大差别的，在 Standards Mode 下对于盒模型的解释和其他的标准浏览器是一样，但在 Quirks Mode 模式下则有很大差别，而在不声明 Doctype 的情况下，IE默认又是 Quirks Mode 。所以为兼容性考虑，我们可能需要获取当前的文档渲染方式。 document.compatMode 属性就是用来判断当前浏览器采用的渲染方式，它有两个可能的值：BackCompat 和 CSS1Compat。 CSS1Compat：标准兼容模式开启。 浏览器客户区宽度是 document.documentElement.clientWidth。 BackCompat：标准兼容模式关闭。浏览器客户区宽度是 document.body.clientWidth。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浏览器中的各种width/height]]></title>
      <url>%2F2016%2F04%2F17%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8Dwidth-height%2F</url>
      <content type="text"><![CDATA[由于浏览器的兼容性问题，在求一个元素的长宽或者是其距离视口边缘的距离时，往往不知所措。本文总结了在浏览器中获取元素长宽时，所用到的各种浏览器兼容方法。 window对象screenLeft/screenTop用来确定和修改 window 对象的属性和方法有很多。IE、Safari、Opera 和 Chrome 都提供了以下属性： screenLeft ==&gt; 窗口相对于屏幕左左边的位置 scrennTop ==&gt; 窗口相对于屏幕上边的位置 Firefos 则在以下属性中提供相同信息： screenX ==&gt; 窗口相对于屏幕左边的位置（Firefox） screenY ==&gt; 窗口相对于屏幕上边的位置（Firefox） Safari 和 Chrome 也同时支持 screenX 和 screenY 这两个属性。Opera 虽然也支持 screenX 和 screenY，但与 screenLeft 和 screenTop 属性不对应。因此，不建议在 Opera 中使用。 浏览器 window.screenLeft window.screenTop window.screenX window.screenY IE 浏览器窗口相对于屏幕左边的位置 浏览器窗口相对于屏幕上边的位置 —— —— Opera 浏览器窗口相对于屏幕左边的位置 浏览器窗口相对于屏幕上边的位置 !== screenLeft !== screenTop IE/Opera 这个距离包括浏览器中实际页面上方的工具栏 这个距离包括浏览器中实际页面左边的浏览器栏 Safari 浏览器窗口相对于屏幕左边的位置 浏览器窗口相对于屏幕上边的位置 浏览器窗口相对于屏幕左边的位置 浏览器窗口相对于屏幕上边的位置 Chrome 浏览器窗口相对于屏幕左边的位置 浏览器窗口相对于屏幕上边的位置 浏览器窗口相对于屏幕上边边的位置 Firefox —— —— 浏览器窗口相对于屏幕左边的位置 浏览器窗口相对于屏幕上边的位置 Safari/Chrome/Firefox —— —— 这个距离不包括浏览器工具栏 这个距离不包括浏览器工具栏 由上表，我们可以得出如下的跨浏览器代码： 12var leftPos = (typeof window.screenLeft === 'number') ? window.screenLeft : window.screenX, topPos = (typeof window.screenTop === 'number') ? window.screenTop : window.screenY; 除去上表关于各个浏览器对属性所表示的位置距离的内涵差异之外，更让人琢磨不透的是，Firefox、Safari 和 Chrome 始终返回页面中每个框架的 top。screenY 或 screenTop 中值。即使在页面中由于被设置了外边距而发生偏移的情况下，相对于 window 对象使用 screenX 和 screenY 每次也都会返回相同的值。而 IE 和 Opera 则会给出框架相对于屏幕边界的精确坐标值。 最终结果，就是无法在跨浏览器情况下取得窗口左边和上边的精确坐标值。 innerWidth&amp;innerHeight 与 outerWidth&amp;outerHeightwindow.innerWidth 和 window.innerHeight 用于获取页面视图区域的宽度和高度。（不包括工具栏和滚动条） window.outerWidth 和 window.outerHeight 用于获取浏览器窗口的宽度和高度。（包括工具栏和滚动条） 浏览器对 window 的这 4 个属性的支持情况如下： 属性 innerWidth innerHeight outerWidth outerHeight IE9 9+ 9+ 9+ 9+ Firefox/Chrome 1.0 1.0 1.0 1.0 Safari 3.0 3.0 3.0 3.0 Opera 9.0 9.0 9.0 9.0 注意，这 4 个属性的返回值均为一个以 px 为单位的 number 类型的数值。 当然，如果要编写跨浏览器代码，仅仅靠以上 4 个属性是不够的，老版本浏览器不会支持它们，另外早期 IE 还有标准模式与混杂模式之分。这里以 window.innerWidth 属性为例，展示跨浏览器代码的编写： 1234567891011// 获取浏览器可见视口的宽度// 跨浏览器代码if (typeof window.innerWidth === 'number') &#123; // 如果浏览器的此属性符合预期，就直接返回其值 return window.innerWidth;&#125; else if (document.compatMode === 'CSS1Compat') &#123; // 页面处于标准模式 return document.documentElement.clientWidth;&#125; elst &#123; // 页面处于混杂模式 return document.body.clientWidth;&#125; 上面仅是以 window.innerWidth 为例的获取可见视口宽度的跨浏览器代码，其他四个属性求值的跨浏览器代码类似。 移动设备的可见视口与布局视口大小如图所示： 移动设备 可见视口 布局视口 移动IE documeng.documentElement.clientWidth/document.documentElement.clientHeight document.body.clientWidth/document.body.clientHeight 其他浏览器 window.innerWidth/window.innerHeight document.documentElement.clientWidth/document.documentElement.clientHeight 对于移动设备，window.innerWidth 和 window.innerHeight 保存着可见视口，也就是屏幕上可见页面区域的大小。移动 IE浏览器不支持这些属性，但通过 document.documentElement.clientWidth 和 docuemnt.documentElement.clientHeight 提供了相同的信息。随着页面的缩放，这些值也会相应发生变化。 在其他移动浏览器中，document.documentElement 度量的是布局视口，即渲染后页面的实际大小（与可见视口不同，可见视口只是整个页面中的一小部分）。移动 IE 浏览器把布局视口的信息保存在 document.body.clientWidth 和 document.body.clientHeight中。这些值不会随着页面缩放变化。 另外，使用 resizeTo() 和 resizeBy() 方法可以调整整个浏览器窗口的大小。这两个方法都接收两个参数，其中 resizeTo() 接收浏览器窗口的新宽度和新高度，而 resizeBy() 接收新窗口与原窗口的宽度和高度之差。 pageXOffset&amp;pageYOffsetwindow.pageXoffset 和 window.pageYOffset 用于获取当前文档相对于浏览器视口左上角已经被滚动过的水平、垂直距离。 二者的返回值均为一个以 px 为单位的 number 类型的值。 注意： IE8 及更早版本不支持这两个属性。其余主流现代浏览器（Firefox/Chrome/Safari）均支持此属性。 跨浏览器代码如下（这里仅以 window.pageXOffset 为例）： 123456789if (typeof window.pageXOffset === 'number') &#123; // 所有浏览器，除了 IE9 及更早 return window.pageXOffset;&#125; else if (document.compatMode === 'CSS1Compat') &#123; // 标准模式 return document.documentElement.scrollLeft;&#125; else &#123; // 混杂模式 return document.body.scrollLeft;&#125; 普通元素可见大小元素的可见大小由其高度、宽度决定，包括所有内边距、滚动条和边框大小（注意：不包括外边距）。 本部分所说的四个与偏移量相关的属性均是只读的。 offsetWidth/offsetHeight——元素在水平/垂直方向上占用的空间大小，以像素计算 offsetWidth ==&gt; 内容的宽度 + 左内边距 + 右内边距 + （可见的）垂直滚动条的宽度 + 左边框的宽度 + 右边框的宽度 offsetHeight ==&gt; 内容的高度 + 上内边距 + 下内边距 + （可见的）水平滚动条的高度 + 上边框的高度 + 下边框的高度 offsetLeft/offsetTop——元素的外边框至包含元素的内边距之间的像素距离 offsetLeft ==&gt; 元素的左外边框到包含元素的元素的左内边距之间的像素距离 offsetTop ==&gt; 元素的上外边框到包含元素的元素的上内边距之间的像素距离 offsetLeft 和 offsetTop 属性与包含元素有关，包含元素的引用保存在 offsetParent 属性中。offsetParent 不一定与 parentNode 的值相等。例如，&lt;td&gt; 元素的 offsetParent 是 作为其祖先元素的 &lt;table&gt; 元素，因为 &lt;table&gt; 是在 DOM 层次中距 &lt;td&gt; 元素最近的一个具有大小的元素。 要想知道某个元素在页面上的偏移量，将这个元素的 offsetWidth 和 offsetTop 与 offsetParent 的相同属性相加，如此循环直至根元素，就可以得到一个基本准确的值。下面两个函数分别用于取得一个元素的左偏移和上偏移量： 12345678910111213141516171819202122232425// 计算元素的相对于整个页面的左偏移function getElementLeft(element) &#123; var actualLeft = element.offsetLeft, current = element.offsetParent; while (current !== null) &#123; actualLeft += current.offsetLeft; current = current.offsetParent; &#125; return actualLeft;&#125;// 计算元素相对于整个元素的上偏移function getElementTop(element) &#123; var actualTop = element.offsetTop, current = element.offsetParent; while (current !== null) &#123; actualTop += current.offsetTop; current = current.offsetParent; &#125; return actualTop;&#125; 客户区大小元素的客户区大小指的是元素内容及其内边距所占据的空间大小。有关客户区大小的属性有两个：clientWidth 和 clientHeight。这两个属性是只读的。 clientWidth ==&gt; 内容宽度 + 左内边距宽度 + 右内边距宽度 clientHeight ==&gt; 内容宽度 + 上内边距高度 + 下内边距高度 从字面上看，客户区大小就是元素内部的空间大小，因此滚动条所占用的空间不计算在内。 下面是一段获取浏览器视口大小的跨浏览器代码：12345678910111213function getViewport() &#123; if (document.compactMoce === 'BackCompact') &#123; // 非标准模式 return &#123; width: document.body.clientWidth; height: document.body.clientHeight; &#125;; &#125; else &#123; return &#123; width: document.documentElement.clientWidth; height: document.documentElement.clientHeight; &#125;; &#125;&#125; 滚动大小滚动大小，指的是包含滚动内容的元素的大小。有些元素（例如&lt;html&gt;元素），即使没有执行任何代码也能自动地添加滚动条；但另外一些元素，则需要通过 CSS 的 overflow 属性进行设置才能滚动。以下是 4 个与滚动大小相关的属性： scrollHeight ==&gt; 在没有滚动条的情况下，元素内容的总高度 scrollWidth ==&gt; 在没有滚动条的情况下，元素内容的总高度 scrollLeft ==&gt; 被隐藏在内容区域左侧的像素数。设置这个属性可以改变元素的滚动位置 scrollTop ==&gt; 被隐藏在内容区域上方的像素数。设置这个属性可以改变元素的滚动位置 scrollWidth 和 scrollHeight 主要用于确定元素内容的实际大小。例如，通常认为 &lt;html&gt; 元素是在Web浏览器中的视口中滚动的元素（IE6及之前的版本运行在混杂模式下时是&lt;&lt;body&gt;元素）。因此，带有垂直滚动条的页面总高度就是 documeng.documengElement.scrollHeight。 对于不包含滚动条的页面而言，scrollWidth 和 scrollHeight 与 clientWidth 和 clientHeight 之间的关系并不十分明确。在这种情况下，基于 document.documentElement 查看这些属性会在不同浏览器间发现一些不一致性问题，如下： 浏览器 scrollWidth/scrollHeight clientWidth/clientHeight Firefox 同clientWidth/clientHeight，表示文档内容区域大小 同scrollWidth/scrollHeight，表示文档内容区域大小 Opera/Safari3.1+ /Chrome 视口大小 文档内容区域大小 IE（标准模式） 文档内容区域大小 视口大小 在确定文档的总高度时（包括基于视口的最小高度时），必须取得 scrollWidth/clientWidth 和 scrollHeight/clientHeight 中的最大值，才能保证在跨浏览器的环境下得到精确结果。 123var docHeight = Math.max(document.documentElement.scrollHeight, document.documentElement.clientHeight);var docWidth = Math.max(document.documentElement.scrollWidth, document.documentElement.clientWidth); 注意：对于运行在混杂模式下的 IE，需要使用 document.body 代替 document.documentElement。 通过 scrollLeft 和 scrollTop 属性可以确定元素当前滚动的状态，也可以设置元素的滚动位置。在元素尚未滚动时，这两个属性的值都等于 0。如果元素被垂直滚动了，那么 scrollTop 的值会大于 0，且表示元素上方左侧不可见内容的像素高度。如果元素被水平滚动了，那么 scrollLeft 的值会大于 0，且表示元素左侧不可见内容的像素高度。这两个属性都是可以设置的，因此将元素的 scrollLeft 和 scrollTop 设置为 0，就可以重置元素的滚动位置。 12345function scrollToTop(element) &#123; if (element.scrollTop !==0) &#123; element.scrollTop = 0; &#125;&#125; 确定元素大小IE 最先提出，而后被 W3C 标准采纳的一个方法 getBoundingClientRect()，可用来获取元素的位置信息。该方法的返回结果在每个浏览器中的具体输出不完全一样，但是都返回一个对象，这个对象有以下 6 个属性（各大浏览器均支持）： width ==&gt; 元素的可视宽度：width + padding-left + padding-right + border-left + border-right height ==&gt; 元素的可视高度：height + padding-top + padding-bottom + border=top + border-bottom left ==&gt; 元素 border 的左外边界到浏览器视口左边界的距离 top ==&gt; 元素 border 的上外边界到浏览器视口上边界的距离 right ==&gt; 元素 border 的右外边界到浏览器视口的左边界的距离 bottom ==&gt; 元素 border 的下外边界到浏览器视口的上边界的距离 但是，关于此方法的实现，IE8 及早期版本略有不同。IE8 及早期版本认为文档的左上角左边是 (2,2)，而其他浏览器包括 IE9 还算正常，认为 (0,0) 是浏览器的左上角起点坐标。因此，跨浏览器代码需要在一开始检查一下位于 (0,0) 位置的元素的位置信息，在 IE8 及早期版本会返回 (2,2），而在其他浏览器则会返回 (0,0)。 123456789101112131415161718192021222324function getBoundingClientRect(element) &#123; if (typeof arguments.callee.offset !== 'number') &#123; var scrollTop = document.documentElement.scrollTop, temp = documen.createElement('div'); temp.style.cssText = 'position: absolute; left: 0; top: 0;'; document.body.appendChild(temp); // 减去视口的 scrollTop，防止调用函数时，窗口滚动了 arguments.callee.offset = -temp.getBoundingClientRect().top - scrollTop; document.body.removeChild(temp); temp = null; &#125; var rect = element.getBoundingClientRect(), offset = arguments.callee.offset; return &#123; left: rect.left + offset, right: rect.right + offset, top: rect.top + offset, bottom: rect.bottom + offset &#125;;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML图像]]></title>
      <url>%2F2016%2F03%2F18%2FHTML%E5%9B%BE%E5%83%8F%2F</url>
      <content type="text"><![CDATA[图像永远是页面上必不可少的，本文就总结一些关于 HTML 的图象知识。 常见图像格式 格式 用法 颜色 索引色（基本）透明 alpha 透明 JPEG 适用于大多数照片，以及其他颜色较多且可接受一些质量损失的图像 1600万以上 —— —— PNG-8 适用于标识、重复的图案以及其他颜色较少的图像或具有连续颜色的图像 256 支持 支持 PNG-24 与 PNG-8 相似，不过支持颜色更多的图像。适用于颜色丰富且质量要求高的照片 1600万以上 支持 —— PNG-32 与 PNG-24 相似，不过支持具有 alpha 透明的图像 1600万以上 —— 支持 GIF 用法与 PNG-8 相似，在大多数情况下应使用 PNG-8 256 支持 —— JPEG 适用于彩色照片，它包含了大量的颜色并进行了合理的压缩，采用这种格式保存的文件相对较小。JPEG 是一种有损的格式，因此在将图像保存为 JPEG 时会丢失一部分原始信息。注意，对 JPEG 进行解压缩无法还原图像先前丢失的细节，所以只有在确保不再对图像进行修改的情况下才能只保存 JPEG 格式的图像而不保留副本。 PNG 和 GIF 是无损的格式，因此采用这两种格式对图像进行压缩时不会造成品质的损失。与 JPEG 不同 PNG 和 GIF 均支持透明，它们更适用于保存非照片类的图像。通常拥有大片纯色的图像，如标识、重复的图案、插图以及图像文字等都适合这两种格式。一般来说，对于 PNG 和 GIF，应优先选择 PNG，因为它对透明度的支持更好，压缩算法也更好，产生的文件更小。 PNG-8 只有256色，所以常用于保存标识和其他颜色较少的图像（有时也保存为 GIF，不过 PNG-8 更好一些）。JPEG、PNG-24、PNG-32 均支持超过1600万色，但大多数情况下照片和复杂的插图应首先使用 JPEG 格式。也可以使用 PNG 保存照片，但由于无损图像质量，文件大小会比 JPEG 大得多。因此，只有在压缩造成的质量损失不可忽略的情况下才使用 PNG 保存照片。 可以利用透明度为图像创建非矩形的边缘，在图像的下面设置背景色或图案。PNG 和 GIF 都支持透明度，JPEG 不支持。在 GIF 格式中，一个像素要么是透明的，要么是不透明的，这称为索引色透明（index transparency）。而 PNG 既支持索引色透明，又支持 alpha 透明（alpha transparency）。alpha 透明可以控制一个像素的透明程度。这意味着使用 PNG 的效果要好于 使用 GIF 的效果，因为使用 PNG 可以让边缘变得平滑，避免产生锯齿。 Photoshop不支持 alpha 透明的 PNG-8，但支持 alpha 透明的 PNG-32，这也是万维网上大多数透明 PNG 都是 PNG-32 的原因。PNG-24 与 PNG-32 几乎是一样的，而Photoshop将 PNG-24 和 PNG-32 都称为 PNG-24，因此“PNG-24”也常常用于指代带有 alpha 透明的图像，不过从技术上看这种说法并不准确。总之，对于透明图像，应使用 PNG-8 或 PNG-32。 谷歌建立了另一种图像格式，名为 WebP。这种格式既支持有损压缩也支持无损压缩，它产生的文件大小也远小于 JPEG 和 PNG。跟 PNG 一样，它还支持 alpha 透明。目前，WebP 还在发展之中。要了解 WebP 的详细信息，参见 http://developers.google.com/speed/webp/。最新的浏览器支持情况参见 http://caniuse.com/#search=webp。 SVG（可缩放矢量图形）对于使用 SVG 图像语言创建的图像，无论放大还是缩小都不会影响其质量（以及其他的一些参数）。而且，对于某个 SVG 图像来说，无论它在页面中显示的尺寸是多大，其文件大小总是恒定的。目前，几乎所有的现代浏览器都提供基本的 SVG 支持，不过 IE8 还不支持 SVG。可以使用 SVG Web（http://code.google.com/p/svgweb/）或 Raphael（http://raphaeljs.com/）等 JavaScript 库在 IE8 中实现类似的效果。 数字图像以像素为单位进行度量，对于网站上的图像，通常应控制在几百个像素宽。打印机出来的图片通常比显示器上看到的要小一些。打印机的每英寸点数（dpi）通常比显示器的每英寸像素数（ppi）要多。屏幕分辨率变大加剧了这一情形。这就是问什么相同的图像在显示器或笔记本上看要比在纸上看要大得多。 图像编辑器常见图像编辑软件：PhotoshopFireworksGimpAcorn（仅支持OS X）Pixelmator（仅支持OS X）Paint.NET（仅支持Windows）PaintShop Pro 使用软件创建图像的两种方式：(1) RGB模式，R、G、Bi分别表示 Red、Green、Blue。又称为三原色光模式(2) CMYK模式，C、M、Y、K 分别表示表示 Cyan（青）、Magenta（品红）、Yellow（黄）、Black（黑）。又称为印刷四分色模式。所以，我们应该使用 RGB 模式创建图像，而不是 CMYK 模式。 在HTML页面中插入图像1&lt;img src=images/image.url alt="图像未能正常加载时现实的替代文本" /&gt; 如果图像对内容的价值较小，对视障用户来说不太重要，则可以提供空的替代文本，即alt=&quot;&quot;。若图像与邻近文本表达的信息相似，也可以将 alt 属性留空。 不要使用 alt 文本代替图像的 caption。在这种情况下，应考虑将 img 放入一个 figure 元素，并添加一个 figcaption 元素。 如果图像是页面设计的一部分，而不是内容的一部分，则应使用 CSS background-image 属性引入该图像，而不是使用 img 标记。 还可通过给 img 元素添加 width 和 height 属性来改变图像在浏览器中显示的大小。事实上，除了为 Retina 显示屏准备的图像，使用 width 和 height 属性改变图像大小是一种快捷但有些丑陋的做法。由于图像文件本身并未改变，因此访问者容易有受骗的感觉——通常这种做法缩小的图片总是比实际这个尺寸的图形加载得更慢，较好的做法是使用图像编辑器改变图像文件的尺寸。 为Retina屏准备图像Retina 屏是什么呢？设想你仅使用点来作画，然后再设想在同样大小的画布上描绘相同的画，只是每一个点都是用四个点来代替。第二张画能呈现更多的细节，同时也更难看清单独的点。 苹果的 Retina 显示屏就像第二张画。在相同的空间里，它拥有的像素数量是普通显示屏的像素数量的四倍（如下图所示），因此图像会更锐利。专业的说法是，她的每英寸点数（PPI）更多，或者说像素密度更大。除了苹果，还有其他一些公司的设备也使用了高像素密度显示屏。 上面这张图有助于从视觉上理解 Retina 显示屏（右）是如何使用四个像素取代大多数显示屏（左）的一个像素的。这并非缩放，实际的像素要小得多。 需要说明的是，有时需要考虑 Retina 显示屏或类似的其他显示屏，否则图像在浏览器里看起来就会显得模糊。如果不关心其中的意图，至少应记住，让图像的尺寸扩大为原先的两倍，但仅以一半的尺寸显示它们。例如，如果想让图像在所有的显示屏（并非只是 Retina 显示屏）上都是 40x30 的尺寸，就应该创建 80x60 大小的图像，而代码写作 1&lt;img src="photo.jpg" width="40" height="30" alt="" /&gt; 浏览器会将 80x60 的图像缩小，以 40x30 的尺寸显示。 其中的原理是这样的，在 80x60 的图像中，像素总数为 4800，是原先的四倍。这样，Retina 显示屏就可以显示这些额外的像素，让图像看起来更锐利。若使用 40x30 图像，Retina 显示屏就会拉伸这些像素以填充其对应的空间，导致锐利程度降低。每个图像的情况都不一样。 如果图像特别重要，清冽推荐这种做法。这样图像的大小可能会变大，而且双倍分辨率的图像会消耗设备更多的内存（这主要是移动设备的问题）。建议至少在一个移动设备上做好测试。 有一种方法可以创建为 Retina 显示屏准备的图像，同时保持文件大小控制在一个合理的范围之内。其具体做法为：让图像尺寸变为两倍，但使用高压缩设置（在Photoshop中，就是选择低的图像质量）。当以一半大小显示图像时，不容易察觉到高压缩产生的失真效果的影响。实际的效果取决于图像的内容。 图标字体与 SVG 再缩放时都不会导致失真。对于单色的图标，建议尽可能地使用图标字体，而非使用图像。对标识和其他非照片类图像，可以考虑使用 SVG。 网站图标我们在浏览器选项卡、历史纪录、书签、收藏夹和地址栏中看到的（与网站相关的）小图标称为 favicon，这个词是 favorites icon（收藏夹图标）的简称。我们创建的图标至少应该为 16x16。相较于浏览器的其他位置，favicon 更多地显示在标签页上。 由于浏览器通常将该图标显示在灰色或其他颜色的背景上，因此有必要将图标的背景设置为透明的。 创建一个或多个触屏图标，即在苹果设备及其他触屏设备上将网站添加到主屏幕上时要显示的图标。苹果规定，iPhone 和 iPod touch 的图标大小为 57x57 或 114x114（对于 Retina 显示屏），iPad 的图标大小为 72x72 或 114x114（对于Retina显示屏）。Android 也支持这些图标。 创建要在浏览器中显示的网站小图标，保存格式为 icon。推荐为触屏设备至少创建一个图像，并保存为 PNG 格式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[网页文字与字体]]></title>
      <url>%2F2016%2F03%2F04%2F%E7%BD%91%E9%A1%B5%E6%96%87%E5%AD%97%E4%B8%8E%E5%AD%97%E4%BD%93%2F</url>
      <content type="text"><![CDATA[网页文字效果多种多样，丰富多彩，本文记述了常见的特效实现方式。 文本缩进和首字符下沉文本缩进利用 text-indent 来实现，该属性规定文本块中首行文本的缩进大小，其值可能有以下几种情况： 确切数值：定义固定的缩进 百分数：定义基于父元素宽度的百分比的缩进 注意，数值可以为负，若为负值，首行将会向左缩进。 首字符下沉的效果可通过 :first-letter 伪类选择器和向左浮动 float: left; 来实现。 下面是 CSS 代码示例，期中 a 为一块文本的 id。 123456789#a &#123; text-indent: 20px; font-size: 25px;&#125;#a:first-letter &#123; float: left; text-transform: uppercase; /* 将首字母转换为大写 */&#125; 上例中出现的属性 text-transform 用于控制文本的大小写。其值列表如下： none：默认，定义带有小写字母和大写字母的标准的文本 capitalize：文本中的每个单词以大写字母开头 uppercase：大写 lowercase：小写 inherit：规定应该从父元素继承 text-transform 属性的值 自定义文本被选中时的样式当鼠标选中网页上的文本时，默认的样式问蓝底白字，在 CSS3 中，这种样式是可以自定义的。CSS 3 中有 UI 元素状态伪类 ::selection，该属性可以设置文本选中的效果。 示范 CSS 代码如下：123456789::-moz-selection &#123; color: red; background-color: yellow;&#125;::selection &#123; color: red; background-color: yellow;&#125; 注意：Firefox 通过其私有属性 ::-moz-selection 支持此属性。 文本对齐文本（强调一下，注意是文本！！！）的对齐非常简单，使用 text-align 属性即可，该属性最常见的三个值为 left、center、right ，分别表示左、中间、右对齐。另外，CSS3 引进了值 justify 表示两端对齐，不过现在浏览器的支持情况并不好。 有一点需要注意，如果要让文字居于一个块的中央部位，需使用以下代码：1234&#123; text-align: center; line-height: 20px;&#125; 期中，属性 line-height 的值需要设置为与包容此文字的块的 height 值相同。 文字、字符间距控制汉字、英文单词内部字符的间距使用 letter-spacing 属性，该属性值允许为负。 控制英文单词之间的距离使用 word-spacing 属性。 控制一段文字的行间距使用 line-height 属性，其值可以为纯数字（但是不能为负），此数字会与当前的字体尺寸相乘来设置行间距。 属性 white-space 用于控制文字中的空格与回车。其可能的值与作用如下表： 值 作用 pre 原文本格式化输出 nowrap 连续多个空格合并为一个，不换行直到遇到 br 标签 pre-line 合并连续多个空格，保留换行 pre-wrap 保留空格，保留换行 注意：浏览器对 Tab 的处理方式与空格符相同 ##文本装饰与字体粗斜 1234567891011121314/* 文本装饰 */text-decoration: overline; /* 下划线 */text-decoration: line-though; /* 穿过线 */text-decoration: overline; /* 上划线 *//* 字体正斜 */font-style: italic; /* 斜体 */font-style: oblique; /* 倾斜样式的字体 *//* 字体粗细 */font-weight: bold; /* 粗体 */font-weight: bolder; /* 更粗的字体 */font-weight: lighter; /* 更细的字体 */font-weight: 具体数值; /* 定义由粗到细的字符 */ 注意：font-style 属性值有两个，italic（斜体） 和 oblique（倾斜），二者的区别在于：italic（斜体）是一种简单的字体风格，对每个字母的结构有一些小改动，来反映变化的外观；而 oblique（倾斜）则是将正常竖直的文本按一定角度倾斜得到的。通常情况下，二者所表现出来的外观在浏览器中看上去完全一样。 文字阴影属性 text-shadow 是 CSS3 新增属性，利用它可以创造出文字阴影的效果。该属性同时接受 4 个参数：依次是：阴影相对于原对象的水平偏移值（正数为向右，允许负值）、阴影相对于原对象的垂直偏移值（正数为向下，允许负值）、阴影的模糊程度（0时与原对象一样，数值越大越模糊）、阴影颜色。例如：text-shadow: 10px 8px 5px red 表示阴影为红色，位于原对象右下方 (10, 8) 处，模糊程度为 5px。 文字毛玻璃效果使用文字阴影和字体透明颜色可以合成毛玻璃效果，其主要代码为123box-shadow: 1px 1px 2px 2px #ccc;color: rgba(0,0,0,0,);text-shadow: 0 0 10px black; 上面代码中第1行为边框阴影，第3行为文字阴影，第2行通过透明度的设置使得文字变为不可见状态，只留下文本阴影的模糊效果。 注意：使用完全透明的效果并不等同于使用白色，本示例若使用白色，可以清晰地看到白色字体，而不是模糊的效果。 文本溢出处理网页设计经常发生文本内容超出容器范围的问题，在内容较多时采用分页效果，在内容较少时则采用一些普通的文本溢出处理。常用的文本溢出处理方式有： 简单裁切 简单隐藏 隐藏并显示省略号 使用滚动条 与文本溢出处理相关的属性有 2 个，overflow 和 text-overflow。前者的处理主要是针对包含文本的容器而言，比如 div 啦；而后者的处理主要是针对文本本身而言。下面是代码示例： 123456789101112131415161718192021/* 简单隐藏 */div.hidden &#123; overflow: hidden;&#125;/* 使用滚动条 */div.scroll &#123; overflow: scroll;&#125;/* 简单裁切 */div.clip &#123; border: 1px solid; overflow: hidden; white-space: nowrap; text-overflow: clip;&#125;/* 超出部分显示省略号 */div.ellipsis &#123; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;&#125; 金属质感文字文字的金属质感效果直接实现较为困难，本节效果的实现原理为在文本上方添加一个使用半透明和渐变效果的遮罩层。代码如下： 12345678910111213p &#123; color: white; background: black; font-weight: bold; font-size: 30px; position: relative;&#125;span.cover &#123; width: 100%; height: 100%; position: absolute; background: linear-gradient(to bottom, black 0%, transparent 50%, black); opacity: 0.5; /* 设置透明度 */ 上述代码在 p 标签中使用一个 span，该 span 的大小与父元素相同。为了实现金属质感，在第 2 行设置文字为黑底白字。span 上使用渐变，从顶部渐变到底部，从黑色渐变到透明再渐变到黑色（第8行渐变部分只使用了W3C标准）在第9行对span的整体透明度进行了设置，这不是必要的，但可以效果更好。 注意：span 部分也可以使用半透明的背景图片实现，只是不如渐变灵活。 隐藏文本隐藏网页元素的方法有很多种，比如使用 display: none;，或是使用全透明（opacity）。有时并不希望文本丢失，而通常是把文字转移到屏幕的外面，换句话说，文字在屏幕之外，用户看不见，但它依然是存在的。下面是两种隐藏文本的方式： 使用 text-indent 隐藏，图片替换文本、搜索引擎优化 使用定位隐藏——利于屏幕讲述工具的阅读 text-indent 属性本来是用于文本缩进的，当文本缩进使用负参数缩进到屏幕之外时，文本就变得不可见了。此方法可以用图片代替文本，之前很多网站使用 h1 标签，把文本用此方法隐藏，在 h1 上设置 logo 为背景并设置居中来做搜索引擎优化（目前用此方法做搜索引擎优化效果已经过时）。 1234567h1 &#123; text-indent: -9999px; margin: 0 auto ; width: 490px; height: 200px; background: url("img/baidu.jpg") norepeat; /* 背景图 */&#125; 使用绝对定位使文本脱离文档流，然后把文本设置在屏幕的不可见区域即可。很多网页就使用此方法隐藏图标下的字体，但同时有利于“屏幕讲述者”阅读文本对视觉障碍者提供便利。其本质为绝对定位使得文字不可见。 12345.screen-reader-text &#123; position: absolute; top: -9999px; left: -9999px;&#125; 文字旋转利用 CSS3 变形可以方便地实现文字旋转： 12345-webkit-transform:rotate(-90deg);-moz-transform: rotate(-90deg);-o-transform: rotate(-90deg);-ms-transform: rotate(-90deg);transform: rotate(-90deg); 现代字体栈CSS 字体栈是一系列的字体，它包含了能在不同操作系统和平台上展示的字体，以尽可能地使排版保持一致性。浏览器会在 font-family 规定的所有字体中从前往后依次查找，如果找不到当前字体就查找下一个字体。网页设计的一个大目标是向大范围用户提供漂亮的排版，而且要考虑字体对所有的用户都有效，所以创建字体栈的原则是使用多个操作系统或终端所共有的或者交叉范围大的一系列字体，需要大量备用字体。]]></content>
    </entry>

    
  
  
</search>
