<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[使用notepad++编写Git commit信息]]></title>
      <url>%2F2017%2F03%2F08%2F%E4%BD%BF%E7%94%A8notepad-%E7%BC%96%E5%86%99Git-commit%E4%BF%A1%E6%81%AF%2F</url>
      <content type="text"><![CDATA[Windows平台下 Git Bash commit 时默认使用的是 Vi 编辑器，这让很多没有用惯 Vi 的小伙伴很不习惯啊。但好在这个编辑器是可以定制的，所以我们可以将其改为 Notepad++。 前言其实一般来说，Git Bash 修改默认编辑器还是挺容易的，只需要运行以下命令即可： 1git config --global core.editor xxxxxxxx 上面命令中省略的部分即是编辑器的位置。 但是 Notepad++ 有点特殊（不要问我，我也不知道为什么），所以要将其作为 Git Bash 的默认编辑器还是要费一些功夫的，这也是为什么 Stack Overflow 上会有那么多相关提问，也是为什么我要单开一篇博文记录的原因。 如果不是改为 Notepad++，而是改为 Sublime 就没这么多问题了(●ˇ∀ˇ●)。 配置Google 了很多，也看了不少资料，尽管网上说的很复杂，但是经过思考，我将其浓缩为了一条命令，经过实践检验，完美可行。 打开 Git Bash，键入以下命令即可： 1git config --global core.editor "'c:\Program Files\Notepad++\notepad++.exe' -multiInst -notabbar -nosession -noPlugin '$*'" 上述命令中的 c:\Program Files\Notepad++\notepad++.exe 是 Notepad++ 路径。 参考 Using Notepad++ to Write Git Commit Messages]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Windows下配置Git中ssh-agent自动启动]]></title>
      <url>%2F2017%2F03%2F08%2FWindows%E4%B8%8B%E9%85%8D%E7%BD%AEGit%E4%B8%ADssh-agent%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8%2F</url>
      <content type="text"><![CDATA[默认情况下，如果我们要经常在 Git Bash 中运行命令以推送更新到远程仓库，则在每次推送时 SSH 客户端每次都会让我们输入密钥的密码，这很是让人不爽啊。解决方法就是让 ssh-agent 自动启动，常驻内存，直至我们注销当前用户或者关闭计算机。 创建.profile文件打开 Git Bash，键入 1pwd 确认当前是在 /c/Users/username 路径下 然后，输入 1touch ~/.profile 在路径下 /c/Users/username 路径下创建一个 .profile 文件 如果此路径下已经有这个文件，则无需新建。 设置.profile使用文本编辑器打开 .profile，将以下内容粘贴到其中保存。 123456789101112131415161718192021env=~/.ssh/agent.envagent_load_env () &#123; test -f "$env" &amp;&amp; . "$env" &gt;| /dev/null ; &#125;agent_start () &#123; (umask 077; ssh-agent &gt;| "$env") . "$env" &gt;| /dev/null ; &#125;agent_load_env# agent_run_state: 0=agent running w/ key; 1=agent w/o key; 2= agent not runningagent_run_state=$(ssh-add -l &gt;| /dev/null 2&gt;&amp;1; echo $?)if [ ! "$SSH_AUTH_SOCK" ] || [ $agent_run_state = 2 ]; then agent_start ssh-addelif [ "$SSH_AUTH_SOCK" ] &amp;&amp; [ $agent_run_state = 1 ]; then ssh-addfiunset env 完事儿之后重启 Git Bash 即可。 如此以来，以后即使 Git Bash 被关闭，ssh-agent 也将一直常驻内存，除非我们结束其进程、注销当前用户或者关闭计算机。 小问题默认情况下，SSH 的私钥是被保存在 ~/.ssh/ 路径下。如果你的私钥不是在这个路径，那么你需要告诉 SSH 客户端在哪儿找到它。 在 Git Bash 中运行以下命令即可 1ssh-add ~/path/to/my_key 参考 Auto-launching ssh-agent on Git for Windows]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[响应式Web之图像]]></title>
      <url>%2F2017%2F03%2F02%2F%E5%93%8D%E5%BA%94%E5%BC%8FWeb%E4%B9%8B%E5%9B%BE%E5%83%8F%2F</url>
      <content type="text"><![CDATA[响应式设计中，图像一直是个难点。一方面，我们想尽可能地使用美丽的图像来展示内容；另一方面，考虑到移动设备的网络速率与处理能力，我们需要单独准备图片，并让其与已有的图片针对不同大小的视口（屏幕分辨率、设备像素比等）做出恰当地响应。有的时候，基于美术设计，我们还会手动裁剪出各种不成比例的图片。 像素/分辨率/设备像素密度/设备像素比像素是什么？ 在计算机屏幕上，像素是一个彩色（或灰度）的物理点（屏幕可以显示的最小的点）。 注意： 严格来说，我们应该称其为设备像素（Device Pixel）或物理像素（Physical Pixel），因为还有设备无关像素。 通常而言，屏幕像素的数量决定了其分辨率的大小。例如，1920x1080 分辨率的显示器是 1920像素宽乘以 1080像素高。 所谓设备像素密度，跟我们常见的手机参数 PPI(Pixel Per Inch) 是一回事儿，其直译过来是“像素每英寸”，但考虑到它的含义，我们可以称呼它为像素密度（Pixel Density）。像素密度的计算方式，就是用屏幕对角线上的像素值除以屏幕对角线的长度（单位：英寸）。例如，iPhone5 的屏幕对角线的像素值为 1303，其对角线长度为 4 英寸，所以其像素密度为 1303/4=326PPI。 设备像素密度(PPI)，即设备每英寸所含有的像素数量。 截至到目前为止，我们所说的“像素”均指的是设备像素，也就物理设备自身实际所拥有的像素。 而通常我们在 CSS 中书写的单位 px，跟设备像素并没有多大关系。这种像素通常被称为“设备无关像素”，Web 开发中常用的 CSS 像素就是设备无关像素的一种。设备无关像素与设备像素之间的存在一种“设备像素比”的关系。 设备像素比（DPR）就是设备像素与设备无关像素（在Web中，通常就是 CSS 像素）的比值。 如果想知道当前设备的 DPR 大小，我们可以在浏览器控制台打印 window.devicePixelRatio。一般来说，window.devicePixelRatio 值默认都是 1，除非网页被强行进行缩放。 最简单的响应式图像对于已有工程中图像的处理，我们所能想到的最简单的响应式开发方案就是对其宽度作自适应，而考虑到图像自身宽度可能大于容器的情况下，我们应该使用 max-width 属性： 1234.img &#123; max-width: 100%; height: auto;&#125; 以上，可以称得上是最简单的响应图片处理方案了。 srcset属性和sizes属性]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[强制开启firefox多进程]]></title>
      <url>%2F2017%2F03%2F01%2F%E5%BC%BA%E5%88%B6%E5%BC%80%E5%90%AFfirefox%E5%A4%9A%E8%BF%9B%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[Firefox 现在已经支持多进程特性，但这项新特性截至目前为止都并不是很成熟，以至于有的 Firefox 版本中并没有默认开启。如果想体验 Firefox 多进程新特性，我们完全可以自行强制开启。 有些 Firefox 虽然出厂默认启用了多进程特性，但会因为 Accessibility Tools 而在重启后自动关闭多进程特性，这时我们也需要手动强制开启多进程特性。 强制开启 Firefox 多进程特性的步骤如下: 浏览器地址栏键入 about:config，进入高级设置 找到 browser.tabs.remote.autostart preference，将其值修改为 true。如果其值已经为 true，则无需改变。 在列表空白区域，右键新建一个 Boolean preference，命名为 browser.tabs.remote.force-enable，并将其值设定为 true 如果是因为 Accessibility Tools 导致 Firefox 自动关闭了出厂的多进程特性，我们还需将 accessibility.force_disabled 的值修改为 1（默认值应该是0） 成功完成上述操作，重启 Firefox 即可享受多进程。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[响应式Web之视口(viewport)]]></title>
      <url>%2F2017%2F02%2F28%2F%E5%93%8D%E5%BA%94%E5%BC%8FWeb%E4%B9%8B%E8%A7%86%E5%8F%A3-viewport%2F</url>
      <content type="text"><![CDATA[视口(viewport) 这一特性在非响应式 Web 设计编码中通常是用不到的，然而它却是我们设计响应式 Web 的关键。 众所周知的媒体查询就是基于视口宽度的。 视口是什么不同领域，视口 的含义自然有所不同。在前端领域中，由于主要是针对浏览器编程，视口自然是指计算机或设备屏幕上用户浏览网页的那块区域。 对于桌面平台的设备而言，视口指的是整个当前浏览器窗口，去掉菜单栏、工具栏、滚动条及浏览器自身的其他部件，真正用来显示网页的那块区域。 对于移动平台的手持设备而言，视口指的就是设备的屏幕显示区域。 那viewport呢对于没有真正接触过响应式 Web 的开发者而言，viewprot 一次可能稍显陌生。因为，在传统 Web 编程中，即非响应式 Web 中，我们通常不会用到 viewprot。 事实上，viewport 同 charset 一样，仅仅是 &lt;meta&gt; 元素的一个元数据属性。 charset 主要用于设置页面字符集，而 viewport 则是用于配置浏览器如何在视口内渲染整个页面。 12&lt;meta charset="utf-8"&gt;&lt;meta name="viewport" content=""&gt; 值得注意的是，一般一个 &lt;meta&gt; 元素只接受一个元数据属性值，所以我们不能简单地将 charset 和 viewport 这种元数据属性一起放至在一个 &lt;meta&gt; 元素里。 默认情况下，手机浏览器在渲染一个没有 viewport 属性的网页时，会先像桌面浏览器那样渲染页面，然后按照比例缩小它来以适配手机视口。如果页面有媒体查询是基于视口宽度的，那么它们不会生效，因为浏览器是按照桌面平台显示器尺寸来计算视口宽度的。 响应式Web开发宽度当为&lt;meta&gt; 元素提供的是 viewport 元数据属性时，我们可以在 content 属性中设置 width 参数。 width 参数用于告诉浏览器如何以多大的宽度来渲染页面。 响应式 Web 中，大部分情况下我们都希望以系统分辨率的宽度来渲染页面，以尽可能地避免缩放，以及正确地响应设备。问题是不同设备的系统分辨率是不一致的，即使在同一设备上，横竖两种手持设备方向也会让渲染方式不同。 解决这个问题的方法是，将 width 的值设置为 device-width， 1&lt;meata name="viewport" content="width=device-width"&gt; 这样一来，浏览器就会自动以设备自身的实际宽度来渲染页面。 如果没有做上述指定，设备将使用它自己默认的视口设置来渲染页面。 初始缩放比当为&lt;meta&gt; 元素提供的是 viewport 元数据属性时，我们可以在 content 属性中设置 initial-scale 参数。 参数 initial-scale 会告诉浏览器在屏幕上首次加载网页时如何缩放它。 响应式 Web 编程中，通常我们会设置 1&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; 这意味着页面将按照 width 参数设定的宽度值来渲染页面，不放大也不缩小实际页面。 如果用的是大于或小于 1 的数值，则页面将缩放至对应的比例。直接后果就是，我们在视口内只能看见页面的一部分或者页面还没有占满整个屏幕。 viewport支持的其他content特性除了最常用的 width 和 initial-scale 参数，viewport 还支持其它许多可配置的参数。但这些参数，一般来说，在响应式 Web 开发中，开发人员应该避免显式地使用。 高度height 可以用于配置浏览器渲染页面的高度，但响应式 Web 中，我们应该极力避免手动配置这个值。 用户可缩放有时，在移动端浏览网页时，我们会发现某些网页是可以进行手动缩放的。这得益于 viewport 的另一个可配置参数 user-scalable，它提供了用户放大或缩小内容的能力。 user-scalable 参数默认值为 yes，即允许用户对页面进行缩放。 对于大多数网站，我们应该避免修改这个参数的默认值，以让用户在需要时可以自行缩放页面。 最大缩放比maxium-scale 用于设置页面最大缩放比，响应式 Web 中，我们应避免配置这个参数。 最小缩放比minium-scale 用于设置页面最小缩放比，响应式 Web 中，我们应该避免配置这个参数。 小结响应式 Web 开发，我们应该为页面配置一个 name 值为 viewport 的 &lt;meta&gt; 标签，一般来说，它应该被配置成如下这个样子： 1&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; 参考 Configure the viewport Responsive Meat Tag]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript性能优化：（七）Ajax]]></title>
      <url>%2F2016%2F12%2F23%2FJavaScript%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%EF%BC%88%E4%B8%83%EF%BC%89Ajax%2F</url>
      <content type="text"><![CDATA[AJAX stands for Asynchronous JavaScript and XML. In a nutshell, it is the use of the XMLHttpRequest object to communicate with server-side scripts. It can send as well as receive information in a variety of formats, including JSON, XML, HTML, and even text files. AJAX’s most appealing characteristic, however, is its “asynchronous” nature, which means it can do all of this without having to refresh the page. This lets you update portions of a page based upon user events. 请求数据XMLHttpRequest常见的使用 XMLHttpRequest 技术请求数据的方式如下： 1234567891011let req = new XMLHttpRequest();req.onload = function() &#123;&#125;;req.onerror = function() &#123;&#125;;req.open('GET', url, true);req.send(); 尽管 XHR 提供了高级的控制，但还是有一些缺点：无法使用 XHR 技术从不同源获取数据。 动态脚本注入这种技术克服了 XHR 的最大限制：能跨域请求数据。本质上，这种技术是个 Hack。 123let scriptElement = document.createElement('script');scriptElement = 'http://';document.head.appendChild(scriptElement); 但是与 XHR 相比，动态脚本注入提供的控制是有限的： 不能设置请求的头部信息 参数传递只能使用 GET 方式，而不是 POST 方式 不能设置请求的超时处理或重试 失败了也不一定知道 必须等待所有数据都已返回，才可以访问它们 不能访问请求的头信息，也不能把整个响应消息作为字符串来处理 特别重要的一点是，响应消息作为脚本标签的源代码，它必须是可执行的 JavaScript 代码。我们不能使用纯 XML、纯 JSON 或其他任何格式的数据，无论哪种格式，都必须封装在一个回调函数中。 尽管限制很多，但是这项技术的速度却非常快。 使用这种技术时，必须注意我们所请求的 JavaScript 代码内容是否完全在自己控制之中。JavaScript 没有任何权限和访问控制的概念，使用动态脚本注入技术添加到页面中的任何代码都可以完全控制整个页面，既是是引自外部的代码也不例外。 Multipart XHRMXHR 允许客户端只用一个 HTTP 请求就可以从服务器端向客户端传送多个资源。它通过在服务器端将资源（CSS 文件、HTML 片段、JavaScript 代码或 base64 编码的图片）打包成一个由双方约定的字符串分割的长字符串送到客户端。然后使用 JavaScript 处理这个长字符串，并根据它的 mime-type 类型和传入的其他“头信息”解析出每个资源。 例如，客户端请求图片资源，服务器使用 base64 将图片编码为字符串然后传递给客户端，当客户端收到后可以使用如下 JavaScript 代码进行处理： 123456789101112function splitImages(imageString) &#123; // 假设服务器端编码的图片之间只用一个简单的 Unicode 编码的字符 1 连接 let imageData = imageString.split('\u0001'); let imageElement = document.createElement('img'); let imageNode = null; for (let i = 0, len = imageData.length; i &lt; len; i++) &#123; imageNode = imageElement.cloneNode(true); imageNode.src = `data:image/jpeg;base64,$&#123;imageData[i]&#125;`; document.body.appendChild(imageNode); &#125;&#125; 以上代码中函数将连接后的字符串按一定格式分解为几段。每一段用来创建一个图片元素，然后将图片元素插入到页面中。图片不是由 base64 字符串转换为二进制，而是使用 data:URL 的方式创建，并指定 mime-types 为 images/jpeg。 这种方式也可以扩展到其他资源类型。JavaScript 文件、CSS 文件、HTML 片段以及多种类型的图片都能合并成一次响应。任何数据类型都可以被 JavaScript 作为字符串发送。 123456789101112131415161718function handleImageData(data, mimeType) &#123; const img = document.createElement('img'); img.src = `data:$&#123;mimeType&#125;;base64$&#123;data&#125;`; return img;&#125;function handleCSS(data) &#123; const style = document.createElement('style'); const node = document.createTextNode(data); style.appendChild(node); document.head.appendChild(style);&#125;function handleJavaScript(data) &#123; // 不建议 eval(data);&#125; 由于 MXHR 响应消息的体积越来越大，因此我们有必要在每个资源收到时就立刻处理，而不是等到整个响应消息全部接收完成再进行处理。这可以通过监听 readyState === 3 的状态，使用定时器按一定时间间隔检查响应来实现。 MXHR 技术有个最大的缺点，以这种方式获得的资源不能被浏览器缓存。 发送数据XMLHttpRequestXHR 技术同样可用于把数据传回服务器· Beacons(信标)这项技术非常类似动态脚本注入。使用 JavaScript 创建一个新的 Image 对象，并把 src 属性设置为服务器上脚本的 URL。该 URL 包含了我们要通过 GET 传回的键值对数据。注意，我们并不会创建 img 元素或把它插入 DOM 树中。 1234567const url = '/status_tracker.php';const params = [ 'step=2', 'time=134152526190'];(new Image()).src = `$&#123;url&#125;?$&#123;params.join('&amp;')&#125;`; 服务器会接收数据并保存下来，它无须向客户端发送任何回馈信息，因此没有图片会实际显示出来。这是给服务器回传信息最有效的方式。它的性能开销开销很小，而且服务器的错误完全不会影响到客户端。 图片信标很简单，但也意味着它能做的事情是有限的。我们无法发送 POST 数据，而使用 GET 方法 URL 的长度有最大上限，所以我们可以发送的数据长度被限制得相当小。 我们可以接收服务器返回的数据，但仅限于非常少得几种方式： 监听 Image 对象的 load 事件 检查返回图片的宽高，利用这些数字通知服务器的状态 信标是向服务器回传数据最快且最有效的方式，服务器根本不需要发送任何响应正文，因此我们也无需担心客户端下载数据。唯一的缺点就是能接收到的响应内心是有限的。 数据格式常见的用于数据传输的数据格式有 XML、XPath、JSON、JSONP、HTML 和自定义格式等，通常来说数据格式越轻量级越好，JSON 和字符串分隔的自定义格式是最好的。如果数据集很大并对解析时间有要求，那么将从以下两种格式中做出选择： JSONP数据：使用动态脚本注入获取。它把数据当作可执行 JavaScript 而不是字符串，解析速度极快。能够跨域使用，但涉及敏感数据时不应使用它 字符分隔的自定义数据格式：使用 XHR 或者动态脚本注入获取，使用 split() 解析。这项技术解析大数据集比 JSONP 略快，而且通常文件尺寸更小 缓存数据最快的 Ajax 请求就是没有请求。有两种主要方法可避免发送不必要的请求： 服务端，设置 HTTP 头信息以确保响应数据被浏览器缓存 客户端，把获取到的信息存储到本地，从而避免再次请求 第一种技术使用最简单而且好维护，而第二种则给予开发人员最大的控制权。 设置 HTTP 头信息如果希望 Ajax 响应能够被浏览器缓存，那么必须使用 GET 方式发出请求。但这还不够，还必须在响应中发送正确的 HTTP 头信息。Expires 头信息会告诉浏览器应该缓存响应多久。它的值是一个日期，过期之后，对该 URL 的任何请求都不再从缓存中获取，而是会重新访问服务器。一个典型的 Expires 头信息如下： Expires: Mon, 28 Jul 2014 23:30:00 GMT 这种特殊的 Expires 头信息告诉浏览器缓存此响应到 2014 年 7 月。 本地数据存储直接把从服务器接收到的数据储存起来。我们可以把响应文本保存到一个对象中，以 URL 为键值作为索引。 总的来说，设置一个 Expires 头信息是更好的方案。它实现起来比较容易，而且其缓存内容能够跨页面和跨会话。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Web Worker]]></title>
      <url>%2F2016%2F12%2F22%2FWebWorker%2F</url>
      <content type="text"><![CDATA[通常一个浏览器会至少存在三个线程：JavaScript 引擎线程，GUI渲染线程以及用于控制交互的浏览器时间触发线程。其中，JavaScript 引擎线程是处理 JavaScript 代码的单线程。 多少年以来，我们都没有办法在浏览器的 UI 线程之外运行 JavaScript 代码。JavaScript 和 UI 共享同一进程的部分原因是它们之间互相访问频繁，但这些任务一旦失控会导致糟糕的用户体验。 Web Workers API 改变了这种状况，它引入了一个接口，能使代码运行且不占用浏览器 UI 线程的时间。它允许加速一个运行特定密集代码的新进程，使得原来的线程不会锁定浏览器，其实就是在后台运行。 本质上来说，由 Web Worker 创建的线程实际是在操作系统中开启了一个全新的线程，意味着该线程与原来的线程是完全不同的。 Web Worker 运行环境Web Worker 没有绑定 UI 线程，这意味着它们不能访问浏览器的许多资源。它不能访问 DOM 中的页面元素，也不能访问页面上所有的全局变量。 但是每个 Web Worker 都有自己的全局运行环境，其功能只是 JavaScript 特性的一个子集。Web Worker 运行环境由如下部分组成： 一个 navigator 对象：只包括四个属性：appName、appVersion、user Agent 和 platform 一个 location 对象（与 window.location 对象相同，不过所有属性都是只读的） 所有的 ECMAScript 对象，诸如：Object、Array、Date 等 XMLHttpRequest 构造器 setTimeout() 和 setInterval() 方法 一个 self 对象，指向全局 worker 对象 一个 importScripts() 方法，用来加载 Worker 所用到的外部 JavaScript 文件 self.close() 方法，worker线程自身调用，停止 worker 代码运行并终止它的线程 terminate() 方法，在主页面中作为 Web Worker 对象的方法调用，使 worker 线程立即被终止，无论它当时处于何种状态，该方法不会给 workder 留下任何完成其他操作的机会 创建一个 Web Worker 线程由于 Web Worker 有着不同的全局环境，因此我们无法从 JavaScript 代码中创建它。为了在现有页面中使用 Web Worker，我们首先需要创建一个完全独立的 JavaScript 文件，并在其中放置需要在 Worker 中运行的代码。然后，我们将这个 JavaScript 文件的 URL 作为参数传给 Worker 构造器即可： 1let workerThread = new Worker('filename.js'); 上述代码一经执行，就会为这个 JavaScript 文件创建一个新的线程和一个新的 Worker 运行环境。该文件会被异步下载，直到文件下载完毕才会启动此 Worker 线程并执行其脚本。 与 Web worker 通信wordker 与页面通过事件接口进行通信。 事件监听器此外，Web Worker 规范为 worker 对象定义了两种 EventListener 类型的属性： onmessage：在 worker 线程传输消息时触发，事件对象的 data 属性中存储着消息内容 onerror：在 worker 线程出错时触发 我们可以通过以下两种方式为 worker 对象绑定时间处理器： worker.onmessage = function(event) {}; worker.addEventListener(&#39;message&#39;, function(event) {}, false); postMessage()方法postMessage() 方法用于向 worker 的内部作用域内传递消息。该方法接收一个单独的参数，即要传递给 worker 的数据。数据可以是任何值或者是经过结构化拷贝算法处理过的 JavaScript 对象，换句话说，可以包含循环引用。 1void postMessage( Object aMessage [, sequence&lt;Transferable&gt; transferList]); aMessage：传输给 worker 的对象；它将包含于传递给 onmessage 处理函数的事件对象中的 data 字段内。你可以传递任意值或是经过结构化拷贝算法处理过的 JavaScript 对象，即可以包含循环引用。 transferList：一个可选的对象数组，用于转让它们的所有权。如果一个对象的所有权被转让，那么它在原来的上下文内将不可使用，而只能在转让到的 worker 内可用。由规范可知， 只有 MessagePort 与 ArrayBuffers 对象能被转让。 通过转让所有权(可转让对象)来传递数据使用 postMessage() 方法的第二个参数可以将特定类型的对象(可转让对象) 传递给一个 worker/从 worker 传回 。可转让对象从一个上下文转移到另一个上下文而不会经过任何拷贝操作。这意味着当传递大数据时会获得极大的性能提升。 与传统的按引用传递不同，一旦对象转让，那么它在原来上下文的那个版本将不复存在。该对象的所有权被转让到新的上下文内。例如，当你将一个 ArrayBuffer 对象从主应用转让到 Worker 中，原始的 ArrayBuffer 被清除并且无法使用。它包含的内容会(完整无差的)传递给 Worker 上下文。 1234567// Create a 32MB "file" and fill it.var uInt8Array = new Uint8Array(1024*1024*32); // 32MBfor (var i = 0; i &lt; uInt8Array .length; ++i) &#123; uInt8Array[i] = i;&#125;worker.postMessage(uInt8Array.buffer, [uInt8Array.buffer]); 注意： 在主页面与 worker 之间传递的数据是通过拷贝，而不是共享来完成的。传递给 worker 的对象需要经过序列化，接下来在另一端还需要反序列化。页面与 worker 不会共享同一个实例，最终的结果就是在每次通信结束时生成了数据的一个副本。大部分浏览器使用结构化拷贝来实现该特性。 加载外部脚本worker 可以通过 importScripts() 方法加载外部 JavaScript 文件，该方法接受一个或多个 JavaScript 文件 URL 作为参数。importScripts() 的调用过程是阻塞式的，直到所有文件加载并执行完毕之后，脚本才会继续运行。 由 importScripts() 导入的每个脚本中的全局对象都能够被 worker 使用。如果脚本无法加载，将抛出 NETWORK_ERROR 异常，接下来的代码也无法执行。而之前执行的代码(包括使用 window.setTimeout() 延迟执行的代码)却依然能够使用。importScripts() 之后的函数声明依然能够使用，因为它们始终会在其他代码之前运行。 注意： 脚本的下载顺序不固定，但执行时会按照你将文件名传入到 importScripts() 中的顺序。这是同步完成的；直到所有脚本都下载并运行完毕， importScripts() 才会返回。 示例下面，我们来写一段简短的代码，演示主页面与 worker 线程 通信的过程。首先是主页面的脚本代码： 12345678// 创建 worker 线程let workerThread = new Worker('code.js');// 开始监听从该线程发出的消息workerThread.onmessage = function (event) &#123; alert(event.data);&#125;;// 向 worker 线程传递消息workerThread.postMessage('lfkid'); 然后是 code.js 文件中的代码： 123456// 在主页面创建 work 线程之后// URL 参数指定的脚本文件self.onmessage = function (event) &#123; self.postMessage(`Hi $&#123;event.data&#125;, I am a Web Worker`); self.close();&#125;; ！！！注意： 无论是在主页面还是 worker 线程内部，我们始终都应该先为 worker 对象的 onmessage（或者 onerror）事件绑定函数处理器，然后再调用 postMessage() 方法传递数据。 图解下面这张图片展示了主页面与 worker 线程通信间的关系： 参考 Worker 使用Web Workers]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[三种方式理解Promise]]></title>
      <url>%2F2016%2F12%2F20%2F%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%90%86%E8%A7%A3Promise%2F</url>
      <content type="text"><![CDATA[Promise 的出现为一直以来饱受“回调地狱”噩梦困扰的异步编程带来了希望，但一开始接触这个概念，理解起来难免有些困难。本文讲述了三种帮助理解 Promise 的方式。 引子下面是一个调用基于 Promise 的函数 asyncFunc() 的例子： 12345678910111213function asyncFunc() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve('DONE'), 100); &#125;);&#125;asyncFunc().then(x =&gt; console.log(`Result: $&#123;x&#125;`));console.log('&gt;_&lt;');// Output:// &gt;_&lt;// Result: DONE 所以呢，什么是 Promise？ 概念上，调用 asyncFunc() 是一个阻塞式函数调用 Promise 既是一个值的容器也是一个事件触发器 概念上：调用基于 Promise 的函数是阻塞的12345678910111213141516function asyncFunc() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve('DONE'), 100); &#125;);&#125;async function main() &#123; const x = await asyncFunc(); // (A) console.log(`Result: $&#123;x&#125;`); // (B) // Same as: // asyncFunc().then(x =&gt; console.log(`Result: $&#123;x&#125;`));&#125;main(); main() 是一个异步函数。其函数体很好地从概念上表明发生了什么——也是我们通常如何看待异步运算： 行(A)：等待，直到 asyncFunc() 执行完毕 行(B)：打印 x 的结果值到控制台日志 在 ES6 和 Generator 之前，你不能暂停并重新恢复代码执行。这就是为什么，对于 Promise，要将恢复代码执行后所发生的一切都置于回调函数中。调用回调与恢复代码是相同的。 Promise 是异步传递的值的容器如果一个函数返回一个 Promise，那么这个 Promise 就像一个空的容器，函数一旦运算完毕，最后就会向其中填充它的结果。你可以通过数组模拟此过程的简单版本： 123456789101112function asyncFunc() &#123; const blank = []; setTimeout(() =&gt; blank.push('DONE'), 100); return blank;&#125;const blank = asyncFunc();// 等待，直到值被填充setTimeout(() =&gt; &#123; const x = blank[0]; // (A) console.log(`Result: $&#123;x&#125;`);&#125;, 200); 使用 Promise，你不必通过 [0]（像在行(A)中那样）访问最终值，你可以使用方法 then() 和回调函数。 Promise 是一个事件触发器另一种看待 Promise 的方式是将其作为一个触发事件的对象。 1234567891011function asyncFunc() &#123; const eventEmitter = &#123; success: [] &#125;; setTimeout(() =&gt; &#123; // (A) for (const handler of eventEmitter.success) &#123; handler('DONE'); &#125; &#125;, 100); return eventEmitter;&#125;asyncFunc().success.push(x =&gt; console.log(`Result: $&#123;x&#125;`)); // (B) 注册事件监听器（行(B)）可以在调用 asyncFunc() 之后完成，因为在这段代码完成后，交给 setTimeout()（行(A)）的回调是异步执行的。 典型的事件触发器专门用于传递多个事件，从你注册时开始。 相比之下，Promise 专门提供一个确定值，并提供内置保护以防止注册太晚：Promise 的结果被缓存并传递到在 Promise 状态确定后注册的事件侦听器。 参考 Three ways of understanding Promises]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript性能优化：（六）加快页面响应速度]]></title>
      <url>%2F2016%2F12%2F19%2FJavaScript%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%EF%BC%88%E5%85%AD%EF%BC%89%E5%8A%A0%E5%BF%AB%E9%A1%B5%E9%9D%A2%E5%93%8D%E5%BA%94%E9%80%9F%E5%BA%A6%2F</url>
      <content type="text"><![CDATA[大多数现代浏览器都是让一个线程共用于执行 JavaScript 代码和更新页面，也就是说，每一时刻浏览器只能执行其中一种操作，这意味着当 JavaScript 代码正在执行时页面就会无法响应，反之亦然。 浏览器 UI 线程用于执行 JavaScript 和更新页面的进程通常被称为“浏览器 UI 线程”（尽管对所有浏览器来说，称为“线程”可能不准确）。、 UI线程的工作基于一个简单的队列系统，任务会被保存到队列中直到进程空闲。一旦空闲，队列中的下一个任务就被重新提取出来并运行。这些任务要么是待执行的 JavaScript 代码，要么是待执行的 UI 更新，包括重绘和回流。 当所有 UI 线程任务都执行完毕，进程进入空闲状态，并等待更多任务加入队列。空闲状态是理想的，因为用户所有的交互都会立刻触发 UI 更新。如果用户试图在任务运行期间于页面交互，不仅没有即时的 UI 更新，甚至可能新的 UI 更新任务都不会创建并加入队列。事实上，大多数浏览器在 JavaScript 运行时都会停止把新任务加入到 UI 线程的队列中，也就是说 JavaScript 任务必须尽快结束，以避免对用途体验造成不良影响。 浏览器限制一般来说，浏览器会限制 JavaScript 任务的运行时间。 有两种方法可以度量脚本运行了多长时间。第一种是记录脚本开始以来执行的语句的数量。这种方法意味着脚本在不同的机器上可能会有不同的运行时间，因为可用内存和 CPU 速度会影响单个语句的执行时间。第二种方法是记录脚本执行的总时长，在指定时间内可运行的脚本数量也因用户的机器性能而有所差异，但是到达执行时间后，脚本会停止运行。毫无疑问的是，不同浏览器检测长时间运行脚本的方法会略有不同。 多久才算“久” Nielsen 指出如果界面在 100 毫秒内响应用户输入，用户会任务自己在“直接操纵界面中的对象”。超过 100 毫秒意味着用户会感到自己与界面失去联系。由于 JavaScript 运行时无法更新 UJI，所以如果 JavaScript 运行时间超过 100 毫秒，用户就会感觉失去了对界面的控制。 最佳实践是限制所有的 JavaScript 任务在 100 毫秒或更短的时间内完成，以避免类似情况出现。 使用定时器理解定时器定时器并不是 ECMAScript 提供的 API，而是由宿主环境浏览器提供的。有一点需要注意的是，当定时器启动之后，只是将其绑定的任务加入到当前线程队列中进行排队，并不会马上执行它。 使用定时器处理数组典型的数组循环模式如下： 123for (let i = 0, len = arr.length; i &lt; len; i++) &#123; process(arr[i]);&#125; 这类循环运行时间过长的原因主要是 process() 的复杂度或 arr 的大小，或两者兼有。 对于这种情况，假如数组无需严格按照顺序处理，且整个处理过程也不要求同步进行，那么我们可以使用定时器来分解此任务。 一种使用定时器帮助处理大数组的方式如下： 1234567891011let todo = arr.concat(); // 克隆原数组setTimeout(function handler(callback) &#123; process(todo.shift()); if (todo.length) &#123; setTimeout(handler, 25); &#125; else &#123; callback(); &#125;&#125;, 25); 每个定时器的真实延时时间在很大程度上取决于具体情况。普遍来讲，最好使用 25 毫秒，因为再小的延时，对大多数 UI 更新来说普遍不够用。——《高性能JavaScript》 使用定时分解任务根据前面使用定时器帮助处理大型数组的经验，对于繁杂的众多一般性任务，我们也可以使用定时器将它们分解为原子任务再处理。 例如，如果要在同一时间段内执行大量函数，我们可以将这些函数放到数组中，然后遍历数组，每隔一定间隔执行下一个函数，这样就可以减轻 JavaScript 线程的压力。 123456789101112131415161718function multistep(steps, args, callback) &#123; // steps：待执行函数组成的数组 // args：Array 类型的实例包裹的传递给待执行函数的参数， // callback：处理结束式执行的回调函数 let tasks = steps.concat(); setTimeout(function handler() &#123; let tasks = tasks.shift(); task.apply(null, args || []); if (tasks.length) &#123; setTimeout(handler, 25); &#125; else &#123; callback(); &#125; &#125;);&#125; 定时器性能同一时间只有一个定时器存在，只有当这个定时器结束时才创建一个新的，通过这种方法使用定时器不会导致性能问题。当多个重发的定时器同时创建往往会出现性能问题。因为只有一个 UI 线程，而所有的定时器都在抢占运行时间。 间隔在 1 秒或 1 秒以上的低频率重复定时器几乎不会影响 Web 应用的响应速度。 当多个重复定时器使用较高的频率（100 ~ 200ms）时，Web 应用就会明显变慢，响应也不及时。 总结：在 Web 应用中限制高频率重复定时器的数量。建议是创建一个独立的重复定时器，每次执行多个操作。 Web Worker本部分参见 Web Worker 参考 《高性能JavaSript》，[美]Nicbolas C.Zakas 著，丁琛 译，电子工业出版社 2015]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript性能优化：（八）编程实践]]></title>
      <url>%2F2016%2F12%2F18%2FJavaScript%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%EF%BC%88%E5%85%AB%EF%BC%89%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%2F</url>
      <content type="text"><![CDATA[每个语言都有它的“痛点”，并且随着时间的推移，它存在的低效模式也不断发展。在精华与糟粕并存的世界中，最佳实践的地位不言而喻。 避免双重求值 避免使用 eval() 和 Function() 对于 setTimeout() 和 setInterval()，建议传入函数而不是字符串作为第一个参数 使用字面量方式创建对象和数组使用对象/数组字面量是创建对象/数组的最快方式，运行速度更快，而且代码量也少。 避免重复工作如同字面意思，在实际编写代码时，我们应该尽可能地避免重复做已经做过的工作。 下面是用于浏览器探测的函数： 1234567function addHandler(target, eventType, handler) &#123; if (target.addEventListener) &#123; target.addEventListener(eventType, handler, false); &#125; else &#123; target.attachEvent('on' + eventType, handler); &#125;&#125; 这个函数隐藏的性能问题在于每次函数调用时都做了重复工作，因为每次调用时其都会经过检查指定方法是否存在。理想状态下，在第一次调用之后就已经知道了当前浏览器所使用的方法，那么后续函数调用就不需要再次检查方法是否存在了。但是，这个函数没能做到这一点，所以每次调用它都是在重复相同的工作，这是极大的资源浪费。 下面以这个函数为例，看一下避免重复工作的几种解决方案。 延迟加载延迟加载意味着信息被使用前不会做任何操作。以之前的浏览器探测代码为例，在函数被调用前，没有必要判断该调用哪个方法去绑定事件处理器。使用了延迟加载技术的函数版本如下： 12345678910111213function addHandler(target, eventType, handler) &#123; if (target.addEventListener) &#123; addHandler = function(target, eventType, handler) &#123; target.addEventListener(eventType, handler, false); &#125; &#125; else &#123; addHandler = function(target, eventType, handler) &#123; target.attachEvent('on' + eventType, handler); &#125; &#125; addHandler(target, eventType, handler);&#125; 上面这个函数实现了延迟加载模式。函数在第一次被调用时，会先检查并决定使用哪种方法去绑定事件处理器。然后原始函数被包含正确操作的新函数覆盖。这样一来，随后每次调用都不会再做检测，因为检测代码已经被新的函数覆盖。 调用延迟加载函数时，第一次总是会消耗较长时间，因为它必须运行检测接着再调用另一个函数完成任务。但是在第一次之后的每次调用，速度将大大加快，因为它不需要再执行检测逻辑。 条件预加载条件预加载技术，会在脚本加载期间提前检测，而不会等到函数被调用。条件检测的操作依然只有一次，只是它在过程中来得更早。 1234567const addHandler = document.body.addEventListener ? function(target, eventType, handler) &#123; target.addEventListener(eventType, handler, false); &#125; : function(target, eventType, handler) &#123; target.attachEvent('on' + eventType, handler); &#125;; 上面这段代码会先检查 addEventListener() 是否存在，然后根据结果指定选择最佳的函数。提前发生的检测 条件预加载确保所有函数调用消耗的时间相同。其代价是需要在脚本加载时就检测，而不是加载后。预加载适用于一个函数马上就要被使用，并并且在整个页面的生命周期中频繁出现的场合。 使用速度快的部分位操作JavaScript 位操作符作用在最基本的层次上，即按内存中表示数值的二进制比特来操作数值。JavaScript 中的数字都依照 IEEE-754 标准以 64 位格式存储。在位操作中，64 位的数字值会被转换位有符号 32 位格式。位操作符会直接操作该 32 位数以得到结果，尽管需要转换，但这个过程与 JavaScript 中其他数学运算和布尔操作相比较要快很多。 科班出身的开发者，应该都知道二进制数、原码、补码、反码、按位操作和左移、右移这些概念吧，在此不再赘述。 ECMAScript 中用于位操作的运算符有： &amp;：按位与 |：按位或 ^：按位异或 !：按位取反 &lt;&lt;：左移 &gt;&gt;：有符号的右移，将数值向右移动，但会保留符号 &gt;&gt;&gt;：无符号的右移，将数值的所有 32 位都向右移动 原生方法无论 JavaScript 代码如何优化，永远都不会比 JavaScript 引擎提供的原生方法更快。 所以开发中，可能地话，应该尽量使用 ECMAScript 规定的标准方法和宿主环境提供的原生 API 解决问题，而不是自己重复造轮子或者滥用类库的接口。特别是数学运算和 DOM 操作，我们应该尽量使用原生方法。 参考 《高性能JavaSript》，[美]Nicbolas C.Zakas 著，丁琛 译，电子工业出版社 2015]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript性能优化：（五）优化字符串操作和正则表达式]]></title>
      <url>%2F2016%2F12%2F18%2FJavaScript%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%EF%BC%88%E4%BA%94%EF%BC%89%E4%BC%98%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[几乎所有的 JavaScript 程序都与字符串操作密切相关。一个典型的应用程序通常需要大量类似合并、分隔、重新排序、搜索、遍历等字符串操作。 对于复杂的文本匹配，正则表达式是必不可少的，我们有必要学习如何编写高性能的正则表达式。 合并字符串拼接字符串是编程中最常见的操作了，我们先来总结一下 JavaScript 中连接字符串的方法： + += Array.prototype.join() String.prototype.concat() ES6 新增的模板字符串 当拼接少量较短字符串，以上这些方法速度都差不多。但随着需要连接的字符串的长度和数量的增加，一些方法开始展现出优势。 待连接字符串是变量如果要拼接的字符串中有以变量形式存在的字符串，优先使用 ES6 中的模板字符串。 将变量名包裹在 ${} 中，然后使用反引号（` ）包裹变量和普通字符串： 1`$&#123;username&#125; is from $&#123;country&#125; .` + 和 +=我们首先必需弄明白一点，在 JavaScript 中字符串一经初始化值便是不可改变的。 下面是一个拼接字符串的常见操作： 1str += 'one' + 'two'; 上面代码在运行时，会历经以下四个步骤： 在内存中创建一个临时字符串 拼接后的字符串 onetwo 被赋值给该临时字符串 临时字符串与 str 当前的值进行连接 将上一步的拼接结构赋值给 str 为了避免产生临时字符串造成额外的性能开销，我们可以这样做： 12str += 'one';str += 'two'; 如果使用下面这种方式，我们能获得更显著的性能提升： 12str = str + 'one' + 'two';// 等价于 str = ((str + 'one') + 'two'); 注意，上面代码中如果赋值号右侧表达式中的 str 不是处在最左侧，那么将得不到优化效果，这与浏览器合并字符串时分配内存的方法有关。大多数浏览器都会尝试为表达式左侧的字符串分配更多的内存，然后简单地将第二个字符串拷贝至它的末尾。如果在一个循环中，基础字符串位于最左侧的位置，就可以避免重复拷贝一个逐渐变大的基础字符串。 合并数组项Array.prototype.join() 方法将数组中地所有元素合并成一个字符串，它接收一个参数作为每项之间的分隔符。如果传入参数为空字符，那么我们就可以使该方法将所有数组项连接为一个字符串。 然而，现实情况是，在大多数浏览器中，数组项合并比其他字符串连接方法更慢。 String.prototype.concat()包装类型 String 的原生方法 String.prototype.concat() 能够接受任意数量的参数，并将每一个参数附加到所调用的字符串上，这是最灵活的字符串合并方法。 遗憾的是，在多数情况下，使用 cancat() 方法比使用简单的 + 和 += 稍慢。 总结：如果要合并的字符串中存在变量，那么使用模板字符串；否则，仅使用简单的 + 操作符合并字符串，并将基础字符串置于表达式最左侧。 正则表达式优化回溯失控回溯失控的正则表达式可能会导致浏览器假死数秒甚至更长时间，为了避免出现回溯失控，编写正则表达式时可以考虑如下方案： 尽可能具体化分隔符之间的字符串匹配模式 使用预查和反向引用的模拟原子组 保证正则表达式的两个部分不能对字符串的相同部分进行匹配 尽可能保持正则表达式简洁易懂 提高正则表达式效率 关注如何让匹配更快：正则表达式慢的原因是匹配失败的过程慢而不是匹配成功的过程慢 以简短、必需的元字符开头：尽可能地避免以分组或分支或选择性元字符开头，这样会造成性能损失 使用量词模式，使它们后面的元字符互斥：具体化匹配模式，避免出现字符与元字符相邻或子表达式能够重叠匹配的情况 减少分支数量，缩小分支范围：字符集比分支更快；如果不可避免地使用分支，应将概率最大的分支放在靠前的位置 尽量避免使用捕获分组：捕获组消耗时间和内存来记录反向引用，并使它保持最新 只捕获需要的文本以减少处理：如果需要引用匹配，应该采取一切手段捕获那些片段，再使用反向引用来处理 暴露必需的元字符：尽可能地让引擎判断那些元字符是必需的 使用合适的量词：贪婪和惰性量词的匹配过程有较大区别，使用更合适的量词类似可以显著提升性能，尤其是在处理长字符时 使用局部变量缓存正则表达式并重用 拆分复杂的正则表达式为简单片段： 避免在一个正则表达式中处理太多任务 不使用正则表达式当仅仅是搜索某个字符串特定位置上的值时，我们没必要动用正则表达式，因为那样不但性能低下，反而可能会弄巧成拙。 包装类型 String 拥有的 charAt()、slice()、substr()、substring()、indexOf() 和 lastIndexOf() 等原生方法都非常适合查找特定字符串的位置，或者判断它们是否存在。 对字符串进行操作，在使用正则表达式之前，先考虑一下这些原生的 String 方法，它们有助于避免正则表达式带来的性能开销。 参考 《高性能JavaSript》，[美]Nicbolas C.Zakas 著，丁琛 译，电子工业出版社 2015 《精通JavaSript开发》，[英]Den Odell 著，邝健威 厉海洋 译，人民邮电出版社 2015]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript性能优化：（四）程序流程控制]]></title>
      <url>%2F2016%2F12%2F15%2FJavaScript%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%EF%BC%88%E5%9B%9B%EF%BC%89%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
      <content type="text"><![CDATA[代码数量多少并不是程序运行速度的决定性因素，代码的组织结构和解决问题的思路才是影响代码性能的主要因素。而代码结构中最重要的就是流程控制：循环、条件分支、函数调用… 循环ES5 及之前版本中有以下四种循环类型： for( ; ; ) {} while() {} do{} while() for...in 上面列表中的所列的前三个循环，一般说来，在性能方面没有差距特别显著的高下之分，大多数人最常用的应该是 for 循环了。 更快的 for 循环对于最常用的 for 循环了，我们唯一可做的性能优化措施就是缓存待遍历数据集的相关属性值。例如进行数组循环时，我们应该缓存数组的 length 属性值，这样就可以避免每次遍历一个元素都会重新访问其 length 属性，从而避免了不必要的性能损失。 123456const arr = [0, 1, 2, 3, 4, 5];const len = arr.length;for (let i = 0; i &lt; len; i++) &#123; console.log(arr[i]);&#125; 反向 while 循环对于大量数据而言最快速的迭代方式是反向 while 循环。这项技术之所以没有使用 for 循环，是因为 for 循环每遍历一项还需要进行终止条件的判断这一步骤（在上面代码中就是 i &lt; len）。 得益于 JavaScript 的隐式类型转换，在反向 while 循环中我们不用写 index &gt;=0 这种表达式，因为 0 值会被自动转换为 false。 123456const arr = [0, 1, 2, 3, 4, 5];let index = arr.length;while (index--) &#123; console.log(arr[index]);&#125; 观察上面的代码，与之前的 for 循环相比，可以看出，反向 while 循环省去了以下步骤： 数值比较：i &lt; len 计算数值比较结果的真假性：(i &lt; len) == true 需要强调的是，虽然反向 while 循环是最快速的迭代方法，但对于超大型数组来说也只是快了几百毫秒而言。因此，这种技术更像是理论应用而不实际的性能优化技巧。注意，由于 JavaScript 是单线程的、事件驱动的、异步的，所以性能开销也依赖于实际执行环境具体而异。 使用 break 或 continue 缩短循环次数如果我们遍历某个数据集的目的是找到某个符合要求的值，那么当已经找出了所要寻找的值时，就应该立马跳出当前这一轮遍历，或结束整个循环。 break 和 continue 关键字可以帮助我们进行这种操作： break 使当前整个循环停止执行，然后程序会转而继续执行循环语句之后的代码 continue 使当前遍历的迭代停止，并开始进行下一次迭代 避免在循环中创建函数为了更快地进行循环，我们应该永远避免在循环中创建函数。每一次创建函数时，都会为该函数分配一定的物理内存，并填充到表示该函数的对象数据。 为了避免在每一次迭代中创建一个函数，可以先在循环语句之前创建并声明一个单独的函数，然后在循环体内引用该函数。 基于函数的迭代ES5 引入为 Array 类型引入了一个名为 forEach() 的原生方法，该方法接受一个函数做参数。执行此方法会遍历一个数组的所有成员，并对每个成员执行传入的函数。这个作为 forEach() 参数的函数接受三个指定的参数：当前数组项的值、当前值的索引、数组本身。 12345const arr = [0, 1, 2, 3, 4, 5];arr.forEach((value, index, arr) =&gt; &#123; process(value); // process() 为一个已经定义的函数&#125;); 但就性能角度考量，不建议使用 forEach() 方法遍历数组。因为现代浏览器引擎内部已经为最常用的 for 循环进行了优化，就遍历时间而言，forEach() 用时多于 for 循环。 另外，这种遍历数组的方式有个缺陷：既不能使用 break 语句中断循环，也不能使用 return 语句返回到外层函数。 减少迭代次数：Duff’s Device如果迭代超过 1e3 数量级了，无论如何循环多会变得慢很多。对于这种情况，我们应该设法减少迭代次数以提高循环性能。 “Duff’s Device” 是一个循环体展开技术，它使得一次迭代中实际上执行了多次迭代的操作。Jeff Greenberg 被认为是将 “Duff’s Device” 代码从原始的 C 实现移植到 JavaScript 中的第一个人。 ——《高性能JavaScript》 下面是该算法的一个较好实现，其基本理念是：每次循环最多可调用 8 次 process()。循环的迭代次数为总数除以 8。由于不是所有数字都能被 8 整除，变量 i 用于存放余数，表示第一次循环应该调用多少次 process()。然后剩余的每次循环都调用 8次 process()。 123456789101112131415161718let i = items.length % 8;while (i) &#123; process(items[i--]);&#125;i = Math.floor(items.length / 8);while (i) &#123; process(items[i--]); process(items[i--]); process(items[i--]); process(items[i--]); process(items[i--]); process(items[i--]); process(items[i--]); process(items[i--]);&#125; 是否应该使用 “Duff’s Device”，很大程度上依赖于迭代次数。当循环迭代次数超过 1000时，使用了 “Duff’s Device” 技术的迭代性能提升显著。 for…of 循环（ES6+）这四种循环类型中，for(...in...) 循环效率低下，究其原因是其本身实际是被用于遍历对象属性的“键”而非“值”，但很多人都误用其去遍历对象属性的 “值”。 考虑到 Web 世界的向下兼容，不能直接修改 fo...in 循环的内部原理以及行为表现，所以 ES6 新引入了 for...of 循环，我们可以用其专门遍历键值对中的“值”。 当执行 for..of 循环时，会首先调用对象的 [Symbol.iterator]() 方法（这是 for...of 循环必需的东西），然后返回一个新的迭代器对象。迭代器对象可以是任意具有 .next() 方法的对象；for...of 循环将重复调用这个方法，每循环一次调用一次。 123456789const arr = ['a', 'b', 'c', 'd', 'e'];for(let i in arr) &#123; console.log(i); // '0' '1' '2' '3' '4'&#125;for(let i of arr)&#123; console.log(i); // 'a' 'b' 'c' 'd' 'e'&#125; 条件分支受 C 语言的影响，JavaScript 中的条件分支语句也有两种：if-else 和 switch。由于不同的浏览器针对流程控制进行了不同的优化，因此使用哪种技术性能开销更小没有绝对定论。 if-else VS switch使用 if-else 还是 switch，最流行的方法是基于测试条件的数量来判断：条件数量越多，越倾向于使用 switch 而不是 if-else。 事实证明，大多数情况下 switch 比 if-else 运行得要快，但只有当条件数量很大时才快得明显。这两种分支语句主要性能区别是：当条件增加时，if-else 性能负担增加得程度比 switch 要多。因此，我们自然倾向于在条件数量较少时使用 if-else，而在条件数量较大时使用 switch，这从性能方面考虑也是合理的。 通常来说，if-else 用于判断两个离散值或几个不同的值域。当判断多于两个离散值时，switch 语句是更加选择。 注意，JavaScript 中 switch 操作符使用的是 “===” 操作符进行比较，所以不会产生类型转换的损失。 if-else 的优化优化 if-else 的目标是，最小化到达正确分支前所需判断的条件数量。 最简单的优化方法就是将概率最大的条件放在第一个分支 if()。 1234567if (x &lt; 3) &#123;&#125; else if (x &gt; 3 &amp;&amp; x &lt; 10) &#123;&#125; else &#123;&#125; 上面这段条件语句，只有当变量 x 的值大于 3时，if-else 语句的性能才是最优的。 另一种减少条件判断次数的方法是把多个并列的 if-else 分支语句组织成一系列嵌套的 if-else 语句。使用单个庞大的 if-else 通常会导致运行缓慢，因为每个条件都需要判断。例如： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546if (x === 0) &#123; return result0;&#125; else if (x === 1) &#123; return result1;&#125; else if (x === 2) &#123; return result2;&#125; else if (x === 3) &#123; return result3;&#125; else if (x === 4) &#123; return result4;&#125; else if (x === 5) &#123; return result5;&#125; else &#123; return undefined;&#125;// 优化之后if (x &lt; 3) &#123; if (x &lt; 1) &#123; if (x === 0) &#123; return result0; &#125; else &#123; return undefined; &#125; &#125; else &#123; if (x === 1) &#123; return result1; &#125; else &#123; return resul2; &#125; &#125;&#125; else &#123; if (x &lt; 5) &#123; if (x === 3) &#123; return result3; &#125; else &#123; return result4; &#125; &#125; else &#123; if (x === 5) &#123; return result5; &#125; else &#123; return undefined; &#125; &#125;&#125; 查找表 在计算机科学中，查找表 是用简单的查询操作替换运行时计算的数组或者关联数组这样的数据结构。由于从内存中提取数值经常要比复杂的计算速度快的多，所以这样得到的速度提升是很显著的。——维基百科 当有大量离散值需要测试时，我们可以使用查找表，将要判断真假的条件表达式可能的值及其对应的表达式操作构建为键值对，然后将这些键值对填充到数组或者普通对象（ES6+之后可以使用 Map 结构）中。 当使用查找表时，我们必需抛弃条件判断语句。这个过程演变为数组项查询或者对象成员查询。查找表的一个主要优点是：不用书写任何条件判断语句，即便候选值数量增加时，也不会产生额外的性能开销。 下面是一个使用查找表改写 switch 分支结构的例子： 123456789101112131415161718192021switch (value) &#123; case 0: return result0; case 1: return result1; case 2: return result2; case 3: return result3; case 4: return result4; case 5: return result5; default: return result6;&#125;// 使用查找表改写const results = [result0, result1, result2, result3, result4, result5, result6];return results[value]; 单个键和单个值之间存在逻辑映射时，查找表的优势就能体现出来。switch 语句更适合于每个键都需要对应一个独特的动作或者一系列动作的场合。 递归最大调用栈限制JavaScript 引擎支持的递归上限于 JavaScript 调用栈大小直接相关，大多数现代浏览器都有固定数量的调用栈限制。 当在程序中使用了太多递归，或者程序递归流程本身有问题时，就有可能会超过 JavaScript 引擎的最大调用栈限制，从而导致栈溢出错误。 递归模式有两种递归模式可能引起栈溢出错误。 第一种模式如下： 12345process();function process() &#123; process();&#125; 另一种模式如下： 123456789first();function first() &#123; second();&#125;function second() &#123; first();&#125; 在这种模式中，两个函数相互调用，形成一个无限循环。 大多数调用栈错误都与这两种模式有关。最常见的的导致栈溢出的原因是不正确的终止条件，因此定位模式错误的第一步是验证终止条件。如果终止条件没有问题，那么可能是算法中包含了太多层递归，为了能在浏览中安全地工作，建议改用迭代、Memoization，或者结合两者使用。 迭代任何递归能实现的算法同样可以使用迭代来实现。迭代算法通常包含几个不同的循环，分别对应计算过程的不同方面，这也会引入它们自身的性能问题。然而，使用优化后的循环替代长时间运行的递归函数可以提升性能，因为运行一个循环比反复调用一个函数的开销要少得多。 提升函数性能MemoizationMemoization 是一种可以缓存之前的结算结果以供后续计算使用的技术。 下面这段代码是常见的计算阶乘的递归函数： 1234567function factorial(n) &#123; if (n === 0) &#123; return 1; &#125; else &#123; return n * factorial(n - 1); &#125;&#125; 现在，我们使用 Meomization 技术改写上面这段代码，以缓存每一次的计算结果： 1234567891011function memFactorial(n) &#123; if (!memFactorial.cache) &#123; memFactorial.cache = new Map([[0, 1], [1, 1]]); &#125; if (!memFactorial.cache.has(n)) &#123; memFactorial.cache.set(n, n * memFactorial(n - 1)); &#125; return memFactorial.cache.get(n);&#125; 我们还可以将 Memoization 技术抽象为一个一般性函数，以将任何普通函数转换带缓存记忆功能的函数。下面是一个简单的封装了 Memoization 技术的函数实现： 1234567891011//function memoize(fn) &#123; fn.cache = fn.cache || new Map(); return function(arg) &#123; if (!fn.cache.has(arg)) &#123; fn.cache.set(arg, fn(arg)); &#125; return fn.cache.get(arg); &#125;&#125; ！！！注意： 上面这种通用的 Memoization 技术与手动针对某个特定函数编写的 memoization 版本相比，优化效果较差。究其本质，memoize() 函数只会缓存特定参数的函数调用结果。例如： 123456789101112131415function factorial(n) &#123; if (n === 0) &#123; return 1; &#125; else &#123; return n * factorial(n - 1); &#125;&#125;const memoizefactorial = memoize(factorial);memoizefactorial(6);console.log(factorial.cache); // Map &#123; 6 =&gt; 720 &#125;memFactorial(6);console.log(memFactorial.cache); // Map &#123; 0 =&gt; 1, 1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 6, 4 =&gt; 24, 5 =&gt; 120, 6 =&gt; 720 &#125; 由此可见，上面那种对于所有函数适用的通用 Memoization 技术存在显著性能问题，所以，如果要适用 Memoization 技术，强烈建为特定函数有针对性地实现，而不是采用通用 Memoization 技术方案。 参考 《高性能JavaSript》，[美]Nicbolas C.Zakas 著，丁琛 译，电子工业出版社 2015 《精通JavaSript开发》，[英]Den Odell 著，邝健威 厉海洋 译，人民邮电出版社 2015]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript性能优化：（三）优化DOM操作]]></title>
      <url>%2F2016%2F12%2F12%2FJavaScript%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%EF%BC%88%E4%B8%89%EF%BC%89%E4%BC%98%E5%8C%96DOM%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[导致大多数网站和应用程序出现性能问题的一个最大因素是低效率的 DOM 操作。浏览器的 JavaScript 引擎独立于其渲染引擎，通过浏览器获取对页面 DOM 元素的引用要涉及从一个引擎跳转到另一个引擎，浏览器则充当了二者之间的媒介。为了提高性能，我们需要减少这种跳转出现的次数。本文记述了一些常用的技巧，以帮助提升 DOM 操作性能。 使用新的选择器API大多数最新版本的现代浏览器都实现了 Selectors API 标准，该标准的核心是两个方法：querySelector() 和 querySelectorAll()。 二者均接受一个 String 类型的 CSS 选择器，不同的是，前者返回与之匹配的第一个元素，而后者则返回一个包含了所有匹配节点的 NodeList 实例。 12const elem1 = document.querySelector('#idName');const elem2 = document.querySelector('.className'); 减少对 DOM 的访问使用局部变量缓存 DOM 元素下面是一段示范代码： 12const header = document.querySelector('header');const nav = document.querySelector('nav'); 引用共同的祖先元素如果需要访问的一些元素均位于同一父元素之下，那么我们可以只获取对该父元素的引用，并从该引用中获取它的各项子元素的引用。 需要注意的是，我们不能贪心，不要通过获取某一公共祖先元素的引用从而实现对多个 DOM 元素的访问，因为祖先元素与这些实际要访问的元素间的层级越多，那么所需的内存占用也越多，而且也会增加 JavaScript 深入 DOM 树查找实际需要访问元素的时间，这势必会对应用程序产生负面的性能影响。所以最佳实践，是综合考量需要处理的 DOM 元素数目以及最近的共同祖先元素离它们自身之间有多少层。 下面是一个简单示范： 123const header = document.querySelector('header');const h1 = header.querySelector('h1');const div = header.querySelector('div'); 如果只是通过共同父元素来获取对各个子元素的引用，我们还可以使用 DOM 元素的 children 属性。当然了，这种方法只适用于需要处理的 DOM 元素有一个共同的父元素的情况。 1234const header = document.querySelector('header').children;const h1 = header[0];const div = header[1]; 利用相邻元素如果需要访问的一些元素正好是同一元素的相邻元素，那么我们可以只获取对该元素的引用，然后使用 previousElementSibling 和 nextElementSibling 来获取其相邻元素。 12345const div = document.querySelector('div');// 我们没有使用 Node.previousSibling，是因为我们只需要 HTML 元素节点，而不需要文本节点和注释节点// 使用 Node.previousSibling 还需要我们手动过滤文本节点和注释节点，没有此种方式效率高const previousElem = div.previousElementSibling;const nextElem = div.nextElementSibling; 克隆已有节点使用 createElement() 方法创建 DOM 元素会带来性能上的损失。为了提高性能，在创建 DOM 元素时，我们应该首先考虑尽可能地利用已有元素来创建新元素。 DOM 节点具有一个名为 cloneNode() 的方法，该方法具有一个可选参数，其接受一个布尔类型的值，用于决定是深克隆还是浅克隆。如果省略，默认值为 false，即浅克隆，仅仅克隆当前节点及其相关对象属性。如果值为 true，即深克隆，也就是当前节点及其相关对象属性和其所有后代节点均会被克隆。尽管参数可以省略，最佳实践是永远传入一个布尔值。 ！！！注意： 如果被克隆的 DOM 元素设置了 id 属性，那么克隆的副本也会带有相同的 id 属性值，所以克隆具有 id 属性的元素后应该重写副本的 id 属性值。 1234567const div = document.querySelector('#test');const copyDiv = div.cloneNode(false);copyDiv.id = 'copyDiv';const list1 = document.createElement('ul');const list2 = list1.cloneNode(false); innerHTML VS 原生 DOM 方法 基于 WebKit 内核的新浏览器中，原生 DOM 方法性能更好 旧版本浏览器中，innerHTML 优势更明显 如果在一个对性能有着苛刻要求的操作中更新一大段 HTML，推荐使用 innerHTML，因为他在绝大部分浏览器中都运行得更快。但对于大多数日常操作而言，二者并没有太大区别。 减少重绘和回流页面的重绘与回流使得实时页面性能开销巨大，当需要对 DOM 元素进行一系列操作时，我们可以通过以下方法来减少重绘和回流的次数： 通过改变元素的类名修改其样式我们应该尽量避免使用 DOM 元素的 style 属性来修改元素的样式，因为那样会额外增加重绘和回流的次数，降低性能。最佳实践是永远通过元素的类来制其获取的 CSS 样式，进而达到改变元素样式的目的。 HTML5 新增了一种操纵元素 class 特性值的方式，现在所有的元素都具有了 classList 这一属性。并配套提供了 add()、remove()、toggle() 和 contains() 方法。 123const header = document.querySelector('header');header.classList.toggle('selected'); 隐藏元素-&gt;应用修改-&gt;重新显示123456789const p = document.createElement('p');const div = document.querySelector('div');div.style.display = 'none';p.text = 'I am a paragraph';div.appendChild(p);div.style.display = 'block'; 使用文档片段 DocumnetFragment(Document Fragment)文档片段是一种轻量级的 DOM 文档，表示没有父节点的最小文档对象。它独立于实时渲染的页面文档而存在，所以它不像实时页面的 DOM 那样会占用额外资源，也称(offline DOM)离线文档。 Document Fragment 继承了 Node 类型的所有属性和方法，我们可以像使用普通文档树中的 DOM 元素那样使用文档片段中的 DOM 元素。 创建一个 DOM Fragment 的方式如下： 12345// 方法一：const fragment = document.createDocumentFragment();// 方法二：此 API 比较新，请查阅浏览器兼容性，不建议在生产环境使用const fragment2 = new DocumentFragment(); 创建了 Document Fragment 之后，我们就可以像操纵实时页面的 DOM 结构树那样操作它了。 12345const header = document.createElement('header');const nav = document.createElement('nav');fragment.appendChild(header);fragment.appendChild(nav); 由于文档片段的离线特性，如果我们将实时页面文档中的节点添加到了文档片段中，那么就会从页面文档树中删除这个节点。同样地，添加到文档片断中的节点与页面文档也没什么关系。 通过将文档片段做参数传给 appendChild() 或 insertBefore() 方法，我们可以将文档片段中的所有内容添加到页面文档树中。注意，添加到实时页面上的是整个离线文档片段中的所有子节点，文档片段本身永远也不会成为文档树中的一部分。 1document.appendChild(fragment); 如果需要同时修改许多 DOM 元素，这是最推荐的方法。 操作副本元素第三种解决方案是为需要修改的节点创建一个备份，然后对其副本进行 DOM 操作。一旦 DOM 操作完成，就可以用新的节点替代旧的节点。 123456const old = document.querySelector('div');const clone = oldNode.cloneNode(true);// do somethingold.parentNode.replaceChild(clone, old); 提升 DOM 事件性能委托事件至祖先元素DOM 事件会从其首次被触发的元素开始冒泡，一直到文档结构的最顶端。对于那些由用户操作的多个同类子元素而言，使用事件委托技术可以帮助我们显著提升 DOM 性能。 下面是一个简单的实现事件委托技术的函数，如果要把事件委托给某一元素处理，就将这个函数注册为该元素相应事件的监听器。其中，第二个参数为真正触发事件的元素的标签名，第三个参数为触发事件之后要执行的回调操作函数。 1234567function delegatesEvent(event, aimTagName, callback) &#123; const aimElement = event.target; if (aimElement !== undefined &amp;&amp; aimElement.tagName === aimTagName.toUpperCase()) &#123; callback(); &#125;&#125; 使用事件框架化处理频密发出的事件某些事件可能会在很短的时间内被触发多次，例如，mousemove、touchmove 等事件。如果有很多事件在很短时间内接连不断地被触发，那么采用 addEventListener() 方式一一注册势必会陷入性能泥淖。 对于这种类型的频密发出的事件，我们可以对代码进行调整，是事件处理函数只负责把当前事件相关的值保存至变量中。将计算密集型的代码迁移至单独的处理函数中，然后使用计时器按一定间隔执行该函数。这一原则被称为事件框架化。 1234567891011121314151617181920const body = document.body;const header = document.querySelector('header');let scrollTopPosition = 0;let scrollLeftPosition = 0;document.addEventListener('scroll', onScroll, false);requestAnimationFrame(writeScrollPosition);function onScroll() &#123; scrollTopPosition = body.scrollTop; scrollLeftPosition = body.scrollLeft;&#125;function writeScrollPosition() &#123; header.innerHTML = `$&#123;scrollTopPosition&#125;px, $&#123;scrollLeftPosition&#125;px`; requestAnimationFrame(writeScrollPosition);&#125; 无论如何，都要避免把计算密集型的事件处理函数直接绑定到会在连续状态改下快速频密触发的事件，我们可以使用事件框架化技术作为替代从而提升事件处理的性能。 参考 《高性能JavaSript》，[美]Nicbolas C.Zakas 著，丁琛 译，电子工业出版社 2015 《精通JavaSript开发》，[英]Den Odell 著，邝健威 厉海洋 译，人民邮电出版社 2015]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript性能优化：（二）作用域管理和对象访问]]></title>
      <url>%2F2016%2F12%2F12%2FJavaScript%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%AE%A1%E7%90%86%E5%92%8C%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%2F</url>
      <content type="text"><![CDATA[若说提高 JavaScript 程序性能，我们无法也不可能绕过作用域不谈。作用域对 JavaScript 有许多影响，从确定哪些变量可以被函数访问，到确定 this 的指向。JavaScript 作用域同整个程序的性能关系密切。JavaScript 中对象不同于传统面向对象程序设计语言，除去使用字面量方式声明对象不谈，我们有必要关注访问对象及其成员的性能问题。 作用域管理基于对作用域、作用域链、标识符解析等的理解，我们应该遵循以下性能法则： 应该尽可能地使用字面量，并减少数组项和对象成员的使用，因为访问字面量的速度最快，相反，访问数组元素和对象成员相对较慢 应该尽可能地使用局部变量，由于局部变量总是存在于执行环境作用域链的最顶端，因此访问局部变量比访问跨作用域变量更快。变量在作用域中的位置越深，访问所需时间越长。由于全局变量总处在作用域链的最末端，因此访问速度也是最慢的 在局部作用域中，最好使用局部变量缓存常用的跨作用域变量 避免使用 try-catcht 语句、eval() 和 with 语句，因为它们会产生动态作用域，从而改变执行环境的作用域链 小心使用闭包，它同时关系到内存和执行速度 对象访问通常来说，访问对象成员的速度比访问字面量或变量要慢，所以在访问对象及其成员，为了提高程序性能，我们应该遵循以下性能法则： 嵌套的对象成员会显著地影响性能，应该尽量少用 属性或方法在原型链中的位置越深，访问它的速度也越慢 把常用的对象成员、数组元素、跨作用域变量缓存在局部变量中，以提高 JavaScript 性能，因为局部变量访问速度最快。 参考 《高性能JavaSript》，[美]Nicbolas C.Zakas 著，丁琛 译，电子工业出版社 2015]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript单例模式]]></title>
      <url>%2F2016%2F12%2F10%2FJavaScript%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[单例模式是一种很常用的模式，有些对象我们往往只需要一个。然而，JavaScript 中实现单例模式的途径与传统面向对程序设计语言有很大不同。 全局变量即单例？ 单例模式的定义是：保证一个类有且仅有一个实例，并提供一个访问它的全局访问点。 由定义可知，单例模式的核心是保证只有一个实例，并提供全局访问，从这点来看，JavaScript 中全局作用域下使用对象字面量方式创建的对象应该算得上是符合单例模式了。 然而，JavaScript 没有真正意义上“类”的概念，所以全局作用域下使用对象字面量方式创建的对象无从谈起是属于哪个类的实例了，因为它自身就是一个实例，从这点上来看，也可以说全局变量不是单例模式。 1234var ming = &#123; name: 'ming', age : 17&#125;; 上面代码中，全局作用域中的对象 ming，从学院派角度而言无论其是否符合所谓“单例模式”的定义，我们都可以将其当作单例使用。所以 JavaScript 中全局变量是否严格符合单例模式的定义并不重要，重要的是，开发人员能将其当作单例使用。 值得注意的是，实际编程中，我们应该尽可能地减少全局变量的使用。 简单的单例模式实现要实现一个单例模式并不难，无非是用一个变量来标志当前是否已经为为某个类创建过对象，如果是，则在下一次获取时，直接返回之前创建的对象。代码如下： 1234567891011121314151617181920var Leader = function() &#123; this.instance = null; this.level = 'supreme'; this.toString = function() &#123; console.log('I am a leader.'); &#125;;&#125;;Leader.getSingle = function() &#123; if (!this.instance) &#123; this.instance = new Leader(); &#125; return this.instance;&#125;;var leader = Leader.getSingle();var leader1 = Leader.getSingle();console.log( leader === leader1 ); // true 上面代码比较简单，我们可以通过 Leader.getSingle() 来获取 Leader 类的唯一对象。这种方式虽然简单，方便理解单例模式，但具有如下缺点： 增加了类的“不透明性” 与传统通过 new 方式调用类不同，对用户不友好 符合单例模式的构造器为什么不是“构造函数”呢？我个人一直认为使用“构造器”而不“构造函数”称呼 ES5(包括之前的版本) 中用于创建对象的函数更好，因为 JavaScript 中没有真正意义上“类”的概念，函数是一等公民，所谓的“构造函数”只不过是使用 new 关键字对普通函数的一种调用而已，与传统面向对象程序设计语言中的“构造函数”有着本质区别。 与在全局作用域下使用字面量方式创建对象不同，如果我们使用了构造器来创建对象，那么就必须保证无论 new 构造器多少次，创建出来的始终都是同一个对象，这样才符合单例模式的概念。 下面我们来创建一个符合单例模式的构造器： 123456789101112131415161718192021var single;var Leader = function() &#123; if (!single) &#123; single = new init(); &#125; return single; function initLeader() &#123; this.level = 'supreme'; this.toString = function() &#123; console.log('I am a leader.'); &#125;; &#125;&#125;;var leader = new Leader();var leader1 = new Leader();console.log( leader === leader1 ); // true 通过测试结果，显然易见，上述代码中的构造器 Leader() 是符合单例模式的。但是上述代码有如下不足： 用于存储单例的变量暴露在全局作用域中 构造器不符合单一职责原则 改进方案为了解决这些问题，我们可以使用闭包、代理模式、原型链对上述方案进行优化： 12345678910111213141516171819var Leader = (function() &#123; var single; return function(fn) &#123; return ( single || ( single = new fn() ) ); &#125;;&#125;)();var initLeader = function() &#123; this.level = 'supreme'; this.toString = function() &#123; console.log('I am a Leader.'); &#125;&#125;var leader = new Leader(initLeader);var leader1 = new Leader(initLeader);console.log( leader === leader1 ); // true 惰性单例惰性单例指的是在需要的时候才创建对象实例。 接下来，我们编写一个通用的惰性单例，它接受一个可用作构造器的函数，并返回这个构造器的惰性单例版本。 12345678var getSingle = function(fn) &#123; var single; return function() &#123; var createor = fn.bind(this, arguments); return ( single || ( single = new createor() )); &#125;;&#125;; 单例模式的 ES6 实现ES6 引入了 class 关键字，这使得 JavaScript 看上去和传统面向对象程序设计语言差不多，然而这只是原型链对象关系的语法糖，本质上其还是构造器和原型链继承。 123456789101112131415161718192021class Leader &#123; constructor () &#123; if (!Leader.single) &#123; this.level = 'supreme'; Leader.single = this; &#125; return Leader.single; &#125; toString() &#123; console.log('I am a leader.'); &#125;&#125;Leader.single = null;const leader = new Leader();const leader1 = new Leader();console.log(Object.is(leader, leader1)); // true 如前所述，在 JavaScript 中实现单例模式的核心是使用一个变量来标志某个类是否已经实例化过对象。在 ES6 中，有了 class 语法，我们可以方便地将这个变量绑定到类自身上，作为其静态变量。 ！！！注意： ES6 规范中并未提出类静态变量的标准写法，也就说，我们只能通过类似 myClassName.staticVar = 0 这种方式来给所谓的类静态变量赋值。 参考 《JavaScript设计模式与开发实践》 曾探.著 人民邮电出版社，2015]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对伪元素使用伪类选择器]]></title>
      <url>%2F2016%2F12%2F08%2F%E5%AF%B9%E4%BC%AA%E5%85%83%E7%B4%A0%E4%BD%BF%E7%94%A8%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
      <content type="text"><![CDATA[有时我们想使用一个伪类选择器去选择一个伪元素以使用一些效果，按照操作的逻辑，选择器看起来可能像这样：.test::before:hover，但事实上这是不正确的。 根据 W3C 的标准，一个伪类选择器是简单的选择器。然而，一个伪元素选择器却不是，尽管它与伪类选择器类似。所以我们不可将伪类选择器置于伪元素选择器之后。 其实，就对伪类有影响的用户行为而言，如果我们仅仅需要在用户与伪元素自身互动时应用效果，那么除非使用一些晦涩难懂的布局，否则这几乎是不可能实现的。 另外，就现在来说，标准的 CSS 伪元素并不能具有伪类。所以，我们应该对真实的 DOM 元素应用伪类选择器而不是伪元素。 如果要使用伪类处理一个伪元素，标准写法如下： 1.test:hover::before &#123;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[边框内圆角]]></title>
      <url>%2F2016%2F12%2F08%2F%E8%BE%B9%E6%A1%86%E5%86%85%E5%9C%86%E8%A7%92%2F</url>
      <content type="text"><![CDATA[边框内圆角就是只在盒子模型的内侧有圆角，而边框或者描边的四个角在外部仍然保持直角的形状。这个效果我们也有两种方式实现它。 双层 div 解决方案使用双层 div 实现这个效果比较容易，只需为内层 div 设置圆角效果，然后给外层 div 设置背景色和一定的 padding 即可。 12345678910.inner-round &#123; background: #655; padding: .8em;&#125;.inner-round &gt; div &#123; background: tan; border-radius: .8em; padding: 1em;&#125; 只使用一个元素如果要求只使用一个元素，我们可以写出如下代码： 1234567.inner-round &#123; background: tan; border-radius: .8em; padding: 1em; box-shadow: 0 0 0 .6em #655; outline: .6em solid #655;&#125; 由于 box-shadow 产生的阴影效果会沿着元素的圆角轮廓包裹元素，而 outline 产生的描边效果依然是矩形，所以我们可以通过结合二者做出边框内圆角效果。 这里的关键在于我们应该为阴影指定多大的扩张值以填补元素圆角与描边矩形间的空白。 假设圆角半径为 r，那么圆心到描边矩形内顶点的距离应该为 (&radic;2 - 1)r，也就是说阴影效果的扩张值我们应该大于这个值，以填补圆角与描边之间的空白。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript去除字符串首尾空白]]></title>
      <url>%2F2016%2F12%2F07%2FJavaScript%E5%8E%BB%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A6%96%E5%B0%BE%E7%A9%BA%E7%99%BD%2F</url>
      <content type="text"><![CDATA[去除字符串首尾空白是个简单常见的任务，ES5 已经添加了原生的 trim() 方法，我们之所以还要探究其实现，是因为其作为学习优化正则表达式的例子再好不过了。 使用正则表达式的解决方案最常见解决方案如果使用正则表达式解决这个问题，我们或许立刻会想到以下解决方案： 12345if (!String.prototype.trim) &#123; String.prototype.trim = function() &#123; return this.replace(/^\s+|\s+$/g, ''); &#125;&#125; 这个方法的不足之处在于，若目标为较长字符串，那么正则表达式中的条件分支功能会拖慢速度。 两次替换方案如果不使用具有条件分支的正则表达式，我们可以写出如下实现： 12345if (!String.prototype.trim) &#123; String.prototype.trim = function() &#123; return this.replace(/^\s+/, '').replace(/\s+$/, ''); &#125;&#125; 这种方式通过对目标字符串执行两次替换操作从而避免了条件分支的性能开销，与最常见的解决方案相比，此种方案在处理长字符串时速度会得到显著提升。 称不上优化的优化我们还可以将两次替换方案中所用正则表达式的 \s+ 改为 \s\s* 来达到额外优化的效果，尽管这并没有什么明显的性能提升。 12345if (!String.prototype.trim) &#123; String.prototype.trim = function() &#123; return this.replace(/^\s\s*/, '').replace(/\s\s*$/, ''); &#125;&#125; 不使用正则表达式的解决方案循环遍历字符串确定空白字符如果不使用正则表达式，那么我们就不可避免地需要使用循环遍历字符串来找出空白字符，然后使用相应的字符串原生方法实现需求： 1234567891011121314151617if (!String.prototype.trim) &#123; String.prototype.trim = function() &#123; const ws = '\n\r\t\f\x0b\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\202f\205f\u3000\ufeff'; let start = 0; let end = this.length - 1; while (ws.indexOf(this.charAt(start)) &gt; -1) &#123; ++start; &#125; while (end &gt; start &amp;&amp; ws.indexOf(this.charAt(end) &gt; -1)) &#123; --end; &#125; return this.slice(start, end + 1); &#125;&#125; 上述代码中的 ws 变量包含了 ECMAScript 中定义的所有空白字符。出于性能考虑，在得到修剪后的起始和终止的位置之前避免拷贝字符串的任何部分。 尽管这个版本的解决方案其性能不受字符串的总长度影响，但它在处理前后有大量空白的字符时却显得费力，这是因为通过循环遍历字符串来确定空白字符串到的效率不够高。 混合解决方案可以通过混合使用正则表达式解决方案与 slice() 方法来使性能更高效，具体来说，即使用正则表达式解决方案过滤字符串头部空白，使用非正则表达式解决方案过滤字符串尾部空白。 1234567891011if (!String.prototype.trim) &#123; String.prototype.trim = function() &#123; const ws = /\s/; let str = this.replace(/^\s\s*/, ''); let end = str.length; while (ws.test(str.charAt(--end))) &#123;&#125; return str.slice(0, end + 1); &#125;&#125; 这种混合解决方案尤其在处理更长的字符串时性能显著，超越了之前的解决方案，但在处理短字符串时耗时还会多于使用正则表达式的解决方案。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySQL免安装版配置]]></title>
      <url>%2F2016%2F12%2F06%2FMySQL%E5%85%8D%E5%AE%89%E8%A3%85%E7%89%88%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[与图形化安装界面不同， MySQL 免安装版在运行之前，还需要自己进行配置。本文记录了在 Windows10 平台上配置 MySQL5.7.16 免安装版的过程。 解压安装将下载好的 zip 压缩包解压到自己喜欢的文件夹，为了避免可能出现的错误，建议文件路径中不包含中文名以及空格。下文以 C:\mysql 这一路径为例进行讲解。 配置环境变量将路径 C:\mysql\bin 加入到 PATH 环境变量之后，用户变量或者系统变量即可，毕竟我们的个人电脑一般都是一个用户。 这一部的目的主要是为了在非 C:\mysql\bin 的其他路径下也能使用 mysql 命令。如果不添加环境变量，那么我们每次在命令中执行 mysql 命令还需进入到 C:\mysql\bin 路径下才能执行。 编辑配置文件路径 C:\mysql 下有一份初始的默认配置文件，即 my-default.ini 文件。在此路径下，新建一份自己的配置文件 my.ini (不要使用其他名称)，然后将 my-default.ini 中的内容复制过来并保存。 使用文本编辑器打开 my.ini ，修改以下几项。还有其他很多参数也都可自定义，感兴趣的同学可以继续研究。下面这几个是最重要的也是我们必须要修改的。 12345678# 默认字符集default-character-set = utf8# mysql 安装路径basedir = C:\mysql# mysql 数据文件夹路径，不要怕，我们现在确实还没有创建这个 data 文件夹datadir = C:\mysql\data# mysql 服务器监听的 TCP/IP 端口号prot = 3306 安装 mysql 服务以管理员身份打开命令提示符，进入到 C:\mysql\bin 路径下，执行： 1$ mysqld install ！！！注意： 是 mysqld 而不是 mysql 。 此时，Win+R 运行键入 services.msc 打开服务，我们可以看到服务列表中已经有了 M有SQL 服务，说明安装成功。 初始化 data 文件夹免安装版的 M有SQL 解压安装之后，在其安装根目录下是没有 data 文件夹，需要我们手动初始化生成，这是最重要的一步。 以管理员身份打开命令提示符，进入到 C:\mysql\bin 路径下，执行： 1$ mysqld --initialize --console 执行上述命令，命令提示符会出现一堆提示信息，我们只关注最后一行的提示信息： 1[Note] A temporary password is generated for root@localhost: ****** 注意到冒号之后的字符串，那是 MySQL 为我们生成的初始密码，请记住，接下来会用到。 启动 MySQL 服务打开命令提示符，执行下面命令以启动 MySQL 服务： 1$ net start mysql 修改 MySQL 初始密码在启动了 MySQL 服务之后，键入以下命令登录到 MySQL 数据库： 1$ mysql -u root -p 回车执行上述命令时，会提示我们输入密码，把刚才 MySQL 生成的初始密码键入以登录。 一旦登录进数据之后，直接执行命令： 1SET PASSWORD = PASSWORD(&apos;这里输入你要设置的新密码&apos;); 回车执行即可完成登录密码的修改。 修改完密码之后，退出数据库，重新启动 M有SQL 服务才会生效。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多重边框]]></title>
      <url>%2F2016%2F12%2F06%2F%E5%A4%9A%E9%87%8D%E8%BE%B9%E6%A1%86%2F</url>
      <content type="text"><![CDATA[多重边框是网页设计中常见的效果，通常我们有两种方式实现它。这两种使用纯 CSS 实现的多重边框各有优缺点，需要我们根据实际自行决定选用哪一种。 box-shadowCSS3 新引入了 box-shadow 属性，用于设置元素的阴影效果。其用法如下： 1box-shadow: inset x y blur spread color; 其中： inset 为关键字值，用于设置元素的阴影类型为内阴影，可选，如果没有使用该关键字声明，则阴影类型为外阴影 x 为阴影的水平偏移值，向右为正偏移，可为负值，必需 y 为阴影的竖直偏移值，向下为正偏移，可为负值，必需 blur 为阴影的模糊程度，不可为负值，可选，单位同 CSS 长度单位 spread 为阴影向外延伸的长度，可为负值，可选，单位同 CSS 长度单位 color 为阴影颜色，必需 另外，box-shadow 支持多重阴影，只需使用逗号分隔每一重阴影即可。 如果将阴影的偏移量和模糊程度均设为 0，而给其一定的外延长度，那么我们就可以通过环绕元素的阴影来模拟多重边框，示例代码如下： 1234.multiple-border1 &#123; box-shadow: 0 0 0 10px #655, 0 0 0 15px deeppink;&#125; 需要注意的地方是，box-shadow 产生的阴影效果是层层叠加的，除了第一层阴影，后续阴影的外延均是在之前阴影的基础上扩展的。例如上述代码中的第二层阴影，虽然其外延值是 15px，但实际阴影宽度应该为 15px-10px = 5px。 这种方式在大多数时候多可以很好的工作，但有以下缺点： 阴影的行为跟真的边框不完全一致，它不会影响布局，而且也不受 box-sizing 影响。解决方法是通过内外边距来模拟出表现为边框的阴影所需要占据的空间。 阴影虽然在元素外围，但它们不会影响到鼠标事件。解决方法是使用 inset 关键字绘制为内阴影，并设置合适内边距容纳它。 outline 和 border第二种方法是使用 outline 产生描边来模拟边框，结合本来的 border 就可构成双层边框的效果。 1234.multiple-border2 &#123; border: 10px solid #655; outline: 5px solid deeppink;&#125; 这种方式虽然避免了第一种方式中阴影不占据元素盒模型宽高以及不影响实际布局的缺点，但其还是有以下不如人意的地方： 只适用于双层边框的场景 边框不一定贴合 border-radius 属性产生的圆角 是具体生产环境而定，描边有可能不是矩形 参考 《CSS揭秘》LEA VEROU 著，CSS魔法 译，人民邮电出版社]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript性能优化：（一）优化脚本加载]]></title>
      <url>%2F2016%2F12%2F04%2FJavaScript%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%EF%BC%88%E4%B8%80%EF%BC%89%E4%BC%98%E5%8C%96%E8%84%9A%E6%9C%AC%E5%8A%A0%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[JavaScript 在浏览器中的性能对于改善用户体验来说，至关重要，而这其中，首当其中的就是页面中 JavaScript 代码的加载时间。本文记述了常用的方法技巧，可以应用到实践中帮助提升 JavaScript 的加载时间。 JavaScript 代码位置大多数情况下，浏览器遇到 &lt;script&gt; 标签时，会停止渲染页面，直到完成对该脚本的读取和解析。所以，我们应该尽可能地把 &lt;script&gt; 标签置于 &lt;/body&gt; 之前。 另外，脚本位置与 &lt;link&gt; 标签位置的关系也值得我们注意： 把一段内嵌脚本放在引用外链样式表的 &lt;link&gt; 标签之后会导致页面阻塞去等待样式表的下载。这样做是为了确保内嵌脚本在执行时能获得最精确的样式信息。因此,建议永远不要把内嵌脚本紧跟在 &lt;link&gt; 标签后面。——《高性能 JavaScript》 合并 JavaScipt 文件每个 &lt;script&gt; 标签初始下载时都会阻塞页面渲染，所以一般来说，我们应该进可能地减少页面中 &lt;script&gt; 标签的数量。 对于处理以 src 属性外链 JavaScript 文件的 &lt;script&gt; 标签而言，考虑到 HTTP 请求会带来额外的性能开销，因此单独下载单个 100KB 的文件将比下载 4 个 25KB 的文件更快。也就是说，我们应该尽可能地合并多个 JavaScipt 文件，以减少页面渲染所需的 HTTP 请求数，从而提高脚本加载性能。 ！！！注意： HTTP2 标准的发布，将使得这一现状发生改变，对于使用了 HTTP2 的客户端和服务器端而言，同时下载多个文件将比单独下载一个合成文件性能开销更小。 压缩 JavaScript 文件压缩 JavaScript 源文件JavaScript 源文件越小，浏览器所用的下载时间就越少。因此，我们要想方设法地让包含源代码的 JavaScript 文件的体积尽可能地小。有三种方法可以帮助我们减小 JavaScript 源文件的体积： 缩编：将 JavaScript 源文件中所有的空格和换行符移除 混淆：使用短小精悍的名称对局部变量和局部函数进行重命名 编译：对代码进行全面分析，并对代码中的语句进行简化、缩减、整合，生成有着相同处理行为的另一语句 好在我们无需手动去做这种重复性高效率低下的工作，有许多工具可以帮助我们很好地完成以上这些工作，下面推荐几款比较流行的： JSMin UglifyJS YUI Compressor Google Closure Compiler（大多数情况下，这个工具的压缩结果最理想） 根据这些工具压缩 JavaSript 源文件的原理，我们知道，代码中使用的全局变量或函数越小，压缩后代码的体积就越小，因此在实际开发中，我们应该尽可能地减少全局变量。 JavaScript 文件的 HTTP 压缩当浏览器请求一个资源时，它通常会发送一个 Accept-Encoding HTTP 头（始于 HTTP/1.1）来告诉服务器它支持哪种编码转换类型。这个信息主要用于压缩文档以获得更快地下载，从而改善用户体验。 Accept-Encoding 可用的值包括： gzip compress deflate identity 如果 Web 服务器在 HTTP 请求中看到这些头信息，它就会选择最合适的编码方案，并通过 Content-Encoding HTTP 响应头通知浏览器它的决定。 Gzip 是目前最流行的编码方式，它通常能减少 70% 的下载量。目前几乎所有的服务器都支持启用这项设置，例如 Apache、Microsoft IIS、Node.js Express 等。 ！！！注意： 在每个请求发生时进行即时的 Gzip 编码处理会额外消耗服务器上的资源和 CPU 处理时间。另外，Gzip 压缩主要适用于文本文件，包括 JavaScript 源文件。而二进制文件，诸如图片或 PDF 文件，则不应该使用 Gzip 压缩，因为它们本身已经被压缩过了，试图重复压缩只会浪费服务器资源。 缓存 JavaScript 文件缓存 HTTP 组件能极大提高用户体验。缓存适用于大多数静态文件，Web 服务器通过 “Express HTTP 响应头” 来告诉客户端一个资源应该缓存多长时间。它的值是一个遵循 RFC1123 标注的绝对时间戳。例如：Express: Thu, 01 Dec 1994 16:00:00 GMT。 某些浏览器，特别是移动设备上的浏览器，可能会有缓存限制。这种情况下，应该权衡 HTTP 组件数量和它们的可缓存性，考虑将它们分解成更小的块。 还有一种技术是使用 HTML5 离线应用缓存，这种不展开论述了。 静态资源更新了？适当的缓存能切实提升用户体验，但它有一个缺点：当应用升级时，浏览器可能还是会从缓存中加载静态资源而不是重新向 Web 服务器请求更新之后的静态资源。 对于这个问题，我们可以通过给静态资源文件名附加时间戳来解决。 使用 CDN内容分发网络（CDN）是在互联网上按地理位置分布计算机网络，它负责传递内容给终端用户。使用 CDN 的主要原因是增强 Web 应用的可靠性、可扩展性，更重要的是提升性能。事实上，通过向地理位置最近的用户传输内容，CDN 能够极大地减少网络延时。 一般说来，大型互联网公司和一些第三方 Web 服务商都可能会提供部分的免费 CDN 服务，对于 Web 世界普遍使用的一些库和框架，我们应该尽可能地使用这些免费的 CDN 服务，以提高用户的访问速度。 无阻塞加载使用 defer 或 async 属性HTML4 为 &lt;script&gt; 标签引入了 defer 属性，而 HTML5 又为 &lt;script&gt; 标签引入了 async 属性；我们可以通过使用这两个属性来实现异步加载脚本。 12&lt;script src="" defer&gt;&lt;/script&gt; &lt;!-- 延迟加载 --&gt;&lt;script src="" async&gt;&lt;/script&gt; &lt;!-- 异步加载 --&gt; ！！！注意： 按照 HTML5 规范，defer 和 async 属性只适用于外部脚本文件。 使用了 async 和 defer 属性的 &lt;script&gt; 的脚本均是在页面下载解析过程中异步下载，不同的是： 使用了 async 属性的脚本在下载完毕后就会立刻开始执行脚本，会中断 HTML 的解析过程 使用了 defer 属性的脚本会延迟到 HTML 解析完毕之后再执行 动态添加 JavaScript我们可以动态地创建 &lt;script&gt; 标签并添加到 DOM 树中从而实现无阻塞地加载外部脚本文件，其优点是：脚本文件的下载和执行过程不会阻塞页面其他进程。 通常来将，把新创建的 &lt;script&gt; 标签添加到 &lt;head&gt; 标签里比添加到 &lt;body&gt; 标签里更保险，尤其是在页面加载过程中执行代码更是如此。当 &lt;body&gt; 标签中的内容没有全部加载完成时，IE可能会抛出一个“操作已中止”的错误消息。——《高性能 JavaScript》 下面是一个通用的动态添加脚本的函数： 123456function loadScript(url, handler) &#123; const script = document.createElement('script'); script.addEventListener('load', handler, false); script.src = url; document.head.appendChild(script);&#125; XMLHttpRequest注入通过使用 XMLHttpRequest 对象，我们也可以实现无阻塞加载外部脚本文件。 123456789101112131415161718function xhrLoadScript(url, handler) &#123; const xhr = new XMLHttpRequest(); xhr.open('get', url, true); xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; const script = document.createElement('script'); script.addEventListener('load', handler, false); script.text = xhr.responseText; document.body.appendChild(script); &#125; &#125; &#125;&#125; 传入合适的 URL 和回调函数，调用上面这段函数，结果就是创建一个带有内联脚本的 &lt;script&gt; 标签。 这种方法优点如下： 可以下载 JavaScript 代码但不立即执行 浏览器兼容性好 但有以下缺点： 请求的 JavaScript 文件必须与当前页面出于相同的源 推荐的无阻塞加载模式如果需要向页面中添加大量 JavaScript，推荐按如下方式加载： 先加载页面必需的最少代码和用于动态添加脚本的 loadScript() 函数 初始化页面之后使用 loadScript() 函数动态地加载剩余的 JavaScript 文件 参考 《高性能JavaSript》，[美]Nicbolas C.Zakas 著，丁琛 译，电子工业出版社 2015 《精通JavaSript开发》，[英]Den Odell 著，邝健威 厉海洋 译，人民邮电出版社 2015]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[同源策略]]></title>
      <url>%2F2016%2F12%2F03%2F%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%2F</url>
      <content type="text"><![CDATA[“源”的概念很早之前就有了，但其标准定义一直不够精确。 RFC 6454 定义并描述了同源策略的原则，更重要的是，推出了“源”首标。 “源”由协议、主机、端口三部分组成。在序列化形式中，“源”看起来类似 URL：协议和主机由 :// 分隔，端口前面是一个 :。对于端口与协议默认端口相同的源，端口可以省略。 由于大部分序列化源使用 80 端口，与默认的 HTTP 端口相同，所以源中通常省略端口。 下面是一个“源”的例子： 1http://example.com:8000 按照“源”的定义可分解如下： http ：协议 example.com ：主机 8080 ：端口 同源策略的原则是：如果两个源的任何一部分不同，浏览器就将它们看作完全不同的源。 ”源“标准的出现替代了之前标准化程度低、更为复杂的旧规则——”同域策略“。源模型清除了所有用于 Web 应用程序的跨域规则。 HTML5 跨文档消息传递通过允许消息在不同源之间交换，克服了同源策略的限制。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WebSocket协议]]></title>
      <url>%2F2016%2F11%2F30%2FWebSocket%E5%8D%8F%E8%AE%AE%2F</url>
      <content type="text"><![CDATA[WebSocket 是定义服务器和客户端如何通过 Web 通信的一种网络协议。组成互联网的协议组通常由 IETF（互联网工程任务组）发布。2011 年 12 月，IETF 发布 RFC，对 WebSocket 协议（RFC 6455）做出了精确地规定，其中，包含了实现 WebSocket 客户端和服务器端时必须遵循的原则。 简介WebSocket 为 Web 应用程序保留了我们所喜欢的 HTTP 特性（URL、HTTP 安全性、更简单的基于数据模型的消息和内置的文本支持），同时提供了其他网络架构和通信模式。和 TCP 一样，WebSocket 是异步的，可以用作高级协议的传输层。 WebSocket 为 Web 应用程序提供了 TCP 风格的网络能力。寻址仍然是单向的，服务器可以异步向客户端发送数据，但是只在 WebSocket 连接打开时才能做到。WebSocket 服务器也可作为 WebSocket 客户端。WebSocket 客户端不能接受不是由它建立的连接。 WebSocket 的层次在 TCP/IP 之上，更在 HTTP 之上。 下表比较了 TCP、HTTP、WebSocket 三者的主要特性： 特性 TCP HTTP WebSocket 寻址 IP地址和端口 URL URL 并发传输 全双工 半双工 全双工 内容 字节流 MIME 消息 文本和二进制消息 消息定界 否 是 是 连接定向 是 否 否 WebSocket 连接握手每个 WebSocket 连接都起始于一个 HTTP 请求。该请求类似普通的 HTTP 请求，但是其请求报文包含了一个特殊的头部字段名 Upgrade。这个字段名表示表示客户端将要把连接升级到一个不同的协议，这个协议就是 WebSocket 协议。 下面我们看一下具体的 HTTP 报文，使用 Chrome 或者 Firefox 打开 https://www.websocket.org/，在 Developer Tools 控制台输入以下代码： 1const ws = new WebSocket('wss://echo.websocket.org/echo'); 以下是上面代码发起 WebSocket 连接所产生的 HTTP 请求报文：（摘自 Firefox Developer Tools，只列出部分数据） 1234567GET /echo HTTP/1.1Host: echo.websocket.orgOrigin: https://www.websocket.orgSec-WebSocket-Version: 13Sec-WebSocket-Key: N7ZEbE8f34TK6i59o+DEGA==Connection: keep-alive, UpgradeUpgrade: websocket 下面是服务器的响应报文： 123456101 Web Socket Protocol HandshakeConnection: UpgradeDate: Sat, 03 Dec 2016 03:30:38 GMTSec-WebSocket-Appect: WfkfBi2Tlw5EBRPcaQ4ReZQdtsE=Server: Kaazing GatewayUpgrade: websocket 像这种要求升级为 WebSocket 连接的 HTTP 请求，一般称之为 WebSocket 初始握手。 与普通 HTTP 连接相比，对于 WebSocket 初始握手而言，HTTP 请求报文中还必需以下首部字段名： Sec-WebSocket-Version Sec-WebSocket-Key Upgrade ： 响应报文中必需以下首部字段名： 101 Web Socket Protocol Handshake（服务器正常成功响应的情况下） Sec-WebSocket-Appect Upgrade 在成功升级协议之后，连接的语法切换为用于 WebSocket 消息的数据帧格式。 ！！！注意 只有服务器响应 101 Web Socket Protocol Handshake、Upgarde: websocket 和 Sec-WebSocket-Accept，WebSocket 初始握手才能成功，才能建立起 WebSocket 连接。 计算响应键值为了成功地完成 WebSocket 握手，WebSocket 服务器必须响应一个由客户端计算的键值。这个响应说明服务器理解 WebSocket 协议。没有精确响应，就可能诱导 HTTP 服务器意外地升级一个连接。 Sec-WebSocket-Accept 响应头部字段名的值从客户端 Sec-WebSocket-Key 请求头部字段名继承而来，包含一个特殊的响应键值，必须与客户端的预期精确匹配。 在服务器端，响应函数会从客户端发送的 Sec-WebSocket-Key 中取得键值，并在 Sec-WebSocket-Accept 中返回根据客户端预期计算出的匹配键值。 WebSocket Sec- 首部字段名在 WebSocket 初始握手和响应键值的计算中，WebSocket 协议依靠 RFC-6455 中定义的 Sec- 首部字段名标志。下面列出了 RFC 6455 标准定义的 WebSocket Sec- 首部字段名，它们均是用于从客户端到服务器的 WebSocket 初始握手。其中有些是 HTTP 请求响应必需的，而有些是可选的。 Sec-WebSocket-Version ：表示版本兼容性。RFC 6455 的版本总是 13。(必需) Sec-WebSocket-Key ：避免跨协议攻击。在 HTTP 请求中只能出现一次。(必需) Sec-WebSocket-Accept ：确认服务器理解 WebScoket 协议。在 HTTP 响应中只能出现一次。(必需) Sec-WebSocket-Extensions ：用于初始握手过程中从服务器到客户端的响应，帮助客户端和服务器商定一组连接期间使用的协议集扩展。可能在 HTTP 请求中出现多次，但是在 HTTP 响应中只出现一次。(可选) Sec-WebSocket-Protocol ：用于初始握手过程从服务器到客户端的响应。这个首部字段名告诉客户端应用程序可以使用的协议。(可选) 消息格式Web Socket 连接所发送的消息，在网络上用二进制语法表示。这些二进制语法标记了消息的边界并包含了简介的类型信息。更准确地说，这些二进制标志字段标记了另一个单位——帧 之间的边界。帧是可以组成消息的部分数据。一个消息可以由多个帧构成，但通常来说，很少有一个消息使用超过一个帧。 下图是 WebSocket 帧的特征示意图： WebSocket 帧头的二进制代码主要负责： 操作码 长度 解码文本 掩码 多帧消息 操作码每条 WebSocket 消息都有一个指定消息载荷类型的操作码。操作码由帧头的第一个字节中最后 4bit 组成，值位数字类型。4bit 操作码共有 16 可能取值，WebSocket 协议只定义了 5 种。 操作码 消息载荷类型 描述 1 文本 消息数据类型为字符串 2 二进制 消息数据类型为二进制的 8 关闭 客户端或服务端向对方发送了关闭握手 9 ping 客户端或服务端向对方发送 ping 10(十六进制 0xA) pong 客户端或服务端向对方发送 pong 长度WebSocket 协议使用可变位数来编码帧长度。 &lt; 126 字节的消息，长度用帧头前两个字节之一表示 126 ~ 216 字节的消息，使用额外的两个字节表示 > 216 字节的消息，长度为 8 字节 长度编码保存于帧头第二个字节的最后 7bit。该字段中 126 和 127 两个值被当作特殊的信号，表示需要后面的字节才能完成长度解码。 解码文本WebSocket 文本消息使用 UTF-8 编码，这是 WebSocket 文本消息允许的唯一编码。 掩码从浏览器向服务器发送的 WebSocket 帧在实际内容之前还有一个 4字节的掩码，这是为了不常见的安全原因，以及改进与现有 HTTP 代理的兼容性。 WebSocket 协议要求客户端所发送的帧必需掩码，帧头在第二个字节的第一位表示该帧是否使用了掩码。 WebSocket 服务器接收的每个载荷在处理之前首先需要处理掩码，解除掩码之后，服务器将得到原始消息内容。二进制消息可以直接交付，文本消息将进行 UTF-8 解码并输出到字符串中。 多帧消息帧格式中的 fin 标志位考虑了多帧消息或者部分可用消息的流化，这些消息可能不连续或者不完整。fin 标志位值为 0 表示当前帧不是消息的最后一帧，fin 标志位值为 1 表示当前帧是消息的最后一帧。 WebSocket 关闭握手Web Socket 连接自身是可以在任何被关闭的，比如下层的 TCP 套接字突然关闭也会导致上层的 WebSocket 连接关闭。只有连接是由建立通信的双方在 WebSocket 层次上正常发起关闭的，那么才会以 WebSocket 关闭握手结束。 当进行 WebSocket 关闭握手时，终止连接的一端可以发送一个数字状态代码，以及一个表示关闭套接字原因的字符串。状态代码和原因编码为具有关闭操作码（8bit）的一个帧的载荷。数字代码用一个 16 位无符号整数表示，原因编码则是一个 UTF-8 编码的短字符串。RFC 6455 定义了多种特殊的关闭代码。代码 1000~1015 规定用于 WebSocket 连接层。这些代码表示网络中或协议中的某些故障。 下面列出了部分常用的 WebSocket 关闭握手代码： 代码 描述 使用场景 1000 正常关闭 会话成功完成时 1001 离开 应用程序离开且不期望后续连接尝试而关闭连接 1002 协议错误 协议错误而关闭连接 1003 不可接受的数据类型 应用程序接收到无法处理的意外类型消息 1007 无效数据 接收一个格式与消息类型不匹配的消息 1009 消息过大 接收消息太大，应用程序无法处理 1010 需要扩展 应用程序需要一个或多个服务器无法协商的特殊扩展时(客户端负责发送) 1011 意外情况 应用程序由于不可预见的原因，无法继续处理连接 1015 TLS失败(保留) 不要发送这个代码。它用于表示 TLS 在 WebSocket 握手之前失败 对其他协议的支持WebSocket 协议支持更高级的协议和协议商。在 WebSocket 客户端编程中，协议协商表现为 WebSocket 构造函数的第二个参数值。而在 HTTP 请求中，协议协商表示为可选 HTTP 首部字端 Sec-WebSocket-Protocol 的值。 服务器会根据客户端的 HTTP 请求中 Sec-WebSocket-Protocol 提供的协议来进行协议协商，然后将其选定的协议名作为 Sec-WebSocket-Protocol 的值在 HTTP 响应头中发给客户端。 扩展 不能同时协商多个协议，但是可以同时协商多个扩展。 HTTP 请求中可选的首部字段名 Sec-WebSocket-Extensions 用于扩展 WebSocket 协议，其值为所支持的扩展名称。 扩展可以为帧添加新的操作码和数据字段。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WebSocket客户端编程]]></title>
      <url>%2F2016%2F11%2F29%2FWebSocket%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%96%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[通常，浏览器访问网页时，会向页面所在的服务器发送一个 HTTP 请求。Web 服务器确认请求并向浏览器发回响应。然而大多数情况下，当浏览器显示页面时实时信息已经过时了。幸运的是，随着 WebSocket 协议标准化，我们将向这一昔日窘况挥手告别。 新建连接：实例化一个 WebSocket 对象本文主要讲述客户端编程中 WebSocket 的使用，所以不涉及服务器端配置及编码，我们就假设服务器端一切都配置好了。 为了建立一个到服务器端的连接，我们首先需要使用 WebSocket 构造函数实例化一个 WebSocket 对象： 1const ws = new WebSocket('ws://www.websocket.org'); WebSocket 构造函数第一个参数WebSocket 构造函数可接受两个参数，其中，第一个参数必须是以 ws:// 或 wss:// 开头的完全限定的 URL，如果 URL 有语法错误，调用构造函数时将会抛出异常。该参数是必须的，不可省略。 这两种 URL 方案实际上是由 WebSocket 协议标准规定的，两者区别如下： ws：传输流量未经加密 wss：在 ws 基础上使用传输层安全性 TLS（SSL）加密要传输的流量 两种 URL 方案的主要区别类似 HTTP 和 HTTPS，其中 wss 安全性更高，推荐使用，不过需要服务器端和客户端双方均支持。 WebSocket 构造函数第二个参数WebSocket 构造函数接受的第二个参数，并非必须的，其主要用于客户端和服务器端间的协议协商。 协议协商对于确定 WebSocket 服务器支持的协议及版本很有用。当应用程序支持多个协议时，我们可以通过为 WebSocket 构造函数传入第二个参数，以使用协议协商选择与特定服务器通信的协议。 该参数类型有两种可能的类型： String 类型，值为客户端和服务器端均能理解的协议 Arrary 类型，包含一组客户端支持的协议（String 类型） 1const ws = new WebSocket('ws://echo.websocket.org', ['myProtocol1', 'myProtocol2']); WebSocket 事件处理WebSocket 协议与 WebSocket API 均是事件驱动的，WebSocket 编程也遵循异步编程模式。只要 WebSocket 连接打开，应用程序就简单地监听事件。 要开始监听事件，只要为 WebSocket 事件添加回调函数即可。可以使用 addEventListener() 方法，也可以采用直接为 WebSocket 对象绑定事件处理函数的方式。 WebSocket 对象具有以下 4 个事件： open 事件一旦服务器响应了 WebSocket 连接请求，open 事件触并建立一个连接，open 事件对应的回调函数是 onopen()。 12345678ws.open = (event) =&gt; &#123; console.log('Connection open...');&#125;// 或者ws.addEventListener('open', (event) =&gt; &#123; console.log('Connection open...');&#125;, false); 到 open 事件触发时，服务器端与客户端之间的 WebSocket 协议握手已经完成，此时 WebSocket 已经准备好发送和接收数据。 message 事件message 事件在接收到消息时触发，消息内容储存于事件对象 event 的 data 属性中，该事件回调函数是 onmessage()。 1234567ws.onmessage = (event) =&gt; &#123; if (typeof event.data === 'string') &#123; console.log(`String message received: $&#123;event.data&#125;`); &#125; else &#123; console.log(`Other message received: $&#123;event.data&#125;`); &#125;&#125; 除了普通文本，WebSocket 消息内容还可以是二进制数据，这种数据作为 Blob 消息或者 ArraryBuffer 消息处理。由于设置 WebSocket 消息二进制数据类型的应用程序会影响二进制消息，所以必须在读取数据之前决定用于客户端二进制数据的类型。 12345678ws.binaryType = 'blob';ws.onmessage = (event) =&gt; &#123; if (event.data instanceof Blob) &#123; console.log(`Blob message received: $&#123;event.data&#125;`); const blob = new Blob(event.data); &#125;&#125; 上面是 Blob 消息 message 事件处理程序示例代码，下面展示一下 ArraryBuffer 消息类型的处理过程： 12345678ws.binaryType = 'arrarybuffer';ws.onmessage = (event) =&gt; &#123; if (event.data instanceof ArraryBuffer) &#123; console.log(`ArraryBuffer message received: $&#123;event.data&#125;`); const a = new Uint8Array(event.data); &#125;&#125; error 事件error 事件在响应意外故障时触发，与该事件对应的回调函数是 onerror()。错误会导致 WebSocket 连接关闭。 close 事件close 事件在 WebSocket 连接关闭时触发，对应的回调函数是 onclose()。一旦连接关闭，客户端和服务器端之间不能再继续收发消息。 close 事件对象有 3 个有用的属性： wasClean：布尔值，表示连接是否顺利关闭。如果关闭连接是对来自服务器的一个 close 帧的响应，则该属性值为 true；如果是因为其他原因关闭连接，则该属性值为 false code：服务器发送的关闭连接握手状态码 reason：服务器发送的关闭连接握手状态 WebSocket 方法WebSocket API 为 WebSocket 对象提供了两个方法供我们调用。 send()使用 send() 方法可以从客户端向服务器端发送消息。当 WebSocket 在客户端与服务器端之间建立了全双工双向连接之后，才可以在连接打开时调用 send()方法。具体来说，我们应该在 open 事件触发之后，且在 close 事件触发之前调用 send() 发送消息。 123ws.open = (event) =&gt; &#123; ws.send('Initial dat...');&#125; 除了普通文本消息，WebSocket API 还允许使用该方法发送二进制数据。 1234567const binaryBlob = new Blob('blob contents');const bianaryBuffer = new Uint8Array([8, 7, 6, 5, 4]);ws.open = (event) =&gt; &#123; ws.send(binaryBlob); ws.send(bianaryBuffer);&#125; close()通过使用 close() 方法，我们可以人为地手动关闭 WebSocket 连接或者终止连接尝试。如果连接已经关闭，那么该方法就什么都不做。 可以向 close() 方法传递两个可选参数： code：Number 类型，状态代码 reason：String 类型，文本字符串，传递一些关于关闭连接的信息 ！！！注意： 这两个可选参数与 close 事件对象的属性值一致。 123ws.onmessage = (event) =&gt; &#123; ws.clsoe(1000, 'message received');&#125; WebSocket 对象属性WebSocket API 提供了多个开发者可以访问的 WebSocket 对象的属性，这些属性都从某一方面反映了 WebSocket 连接的信息。s readyStateWebSocket 对象的 readyState 属性表示当前 WebSocket 连接状态，属性值与连接状态的对应关系如下表所示。 该属性是编程时最常使用的 WebSocket 对象属性，我们应该牢记其值所代表的 WebSocket 连接状态。 特性常量 取值 状态 WebSocket.CONNECTING 0 连接正在进行中，但还未建立 WebSocket.OPEN 1 连接已经建立 WebSocket.CLOSEING 2 连接正在进行关闭握手 WebSocket.CLOSED 3 连接已经关闭 bufferedAmountWebSocket 对象的 bufferedAmount 属性可以用检查已经进入发送队列，但是还未发送到服务器的字节数。 值得注意的是，这个属性报告的值不包括协议组帧开销或者操作系统、网络硬件所进行的缓冲。 protocolWebSocket 对象的 protocol 属性值为 WebSocket 打开连接握手期间，服务器端所选择的协议名。 protocol 属性在最初的握手完成之前为空，如果服务器没有选择客户端提供的某个协议，则该属性保持空值。 开发工具推荐 Chrome Developer Tools：监控网络流量，分析 HTTP 请求及响应头部 Firefox Developer Tools：监控网络流量，分析 HTTP 请求及响应头部 WireShark：抓取网络流量，详细分析网络协议帧、传送数据等 websocket-monitor：强烈推荐！！！Firefox 大法好。这是一个 Firefox Developer Tools 扩展，可以方便地监控 WebSocket 流量。也可以直接在 Firefox Add-ons 下载：https://addons.mozilla.org/en-US/firefox/addon/websocket-monitor/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo教程：（四）将本地Hexo站点部署到GitHubPages]]></title>
      <url>%2F2016%2F11%2F16%2FHexo%E6%95%99%E7%A8%8B%EF%BC%9A%EF%BC%88%E5%9B%9B%EF%BC%89%E5%B0%86%E6%9C%AC%E5%9C%B0Hexo%E7%AB%99%E7%82%B9%E9%83%A8%E7%BD%B2%E5%88%B0GitHubPages%2F</url>
      <content type="text"><![CDATA[Hexo 支持一键部署到 GitHub 仓库，所以我们可以使用 Hexo 结合 GitHub Pages 来搭建在线个人博客。 本地 Git 客户端本地 Git 客户端配置，主要是为了能够在命令行模式下与远程的 GitHub 通信。 Git配置打开命令行，键入以下命令： 12$ git config --global user.name "你的用户名"$ git config --global user.email "你的email" 其中，字符串中的内容替换为你自己的信息，这里为了清晰一致，建议使用 GitHub 账户相同的配置信息。 创建 SSH Key打开安装好的 Git Bash，键入： 1$ git gui 回车之后，会启动 Git GUI 软件。在 Git GUI 软件界面，依次点击 Help =&gt; Show SSH Key 在出现的 OpenSSH 界面，点击右上角的 Generate Key 以创建 SSH Key。注意，期间会让你输入密码两次，这个密码是本地 Git 与远程 Git 通信时要用到的，要牢牢记住。 OpenSSH 创建好的 SSH Key，会被存储到为一个私钥文件和一个公钥文件；如果是 Windows 操作系统的话，则他们位于 ./c/Users/pcusername/.ssh 路径下，名称分别是 id_rsa 和 id_rsa.pub。 远程 GitHub创建github.io仓库登入你自己的 GitHub 账户，创建一个新的仓库，仓库名为 username.github.io，其中 username 替换为你自己的 GitHub 用户名，就是你个人 GitHub 主页 URL 中的最后一部分。 创建好仓库后，做一次初始提交，以便初始化这个仓库。 配置 SSH Pub Key打开你的 GitHub 个人主页，点击右上角个人头像，选择 Settings，进入设置页面。 在左侧选择 SSH and GPG keys，然后在右侧点击 New SSH key，将刚刚创建的 SSH Key 的公钥文件 id_rsa.pub 中的内容复制到 Key 文本框中。 本地 Git 与远程 GitHub 通信上面配置都搞定以后，我们来测试一下 Git 是否可以和我们远程的 Git 仓库通信。 命令行键入以下命令： 12$ ssh -T git@github.comEnter passphrase for key '/c/Users/pcusername/.ssh/id_rsa': 当键入以上命令回车后，会出现让我们输入密码的提示，这个密码就是刚刚我们使用 Open SSH 创建 SSH Key 时所输入的密码。 注意！！！ 输入密码时冒号之后什么也不会显示，所以你只管输入就行，正确无误后按下回车键即可。 如果成功连接，会出现提示信息： Hi your-github-username! You’ve successfully authenticated, but GitHub does not provide shell access. Hexo依赖为了正常部署到远程 Git 仓库，我们还需要先安装一个 Hexo 插件 hexo-deployer-git。 在站点文件夹根目录下打开命令行，键入以下命令： 1$ npm install hexo-deployer-git --save 配置由于是部署到远程的 Git 仓库，所以我们需要修改一些配置参数以使其符合针对 Git 的部署配置。 使用文本编辑器打开站点文件夹根目录下的 _config.yml 文件，修改其 deploy 字段之后的内容： 12345deploy: type: git repo: git@github.com:你的GitHub用户名/你的GitHub用户名.github.io.git brandh: master messge: 其中，各个参数意义如下： repo ：要部署的远程 Git 仓库地址 branch ：仓库分支名称，程序会自动检测，如果你创建的仓库没有做过修改，那么该值应该就是master message ：自定义 Git 的本次 commit 信息（Hexo会按照一定默认生成） 部署如果我们已经生成好了本地静态站点，那么只需下面的命令，即可将其一键部署到服务器上。使用安装好的 Git Bash 终端，在站点根目录下键入： 1$ hexo deploy !!!注意： 以上命令一定要在 Git Bash 终端中键入，因为我们使用的 SSH 协议推送本地仓库到远程分支，必需使用到 Git Bash 内置的 Open SSH 客户端。在此期间，会跳出 Open SSH 的界面，让我们输入密码，就是之前我们用来加密 SSH Key 的在命令行输入的那个密码。 现在，打开 GitHub Pages 看一下效果吧。 完成后部署我们可以让 Hexo 在生成完毕后自动部署网站到服务器，只需使用以下两个命令之一即可： 12$ hexo generate --deploy$ hexo deploy --generate 上面这两个命令是等价的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo教程：（三）使用Hexo写博客]]></title>
      <url>%2F2016%2F11%2F16%2FHexo%E6%95%99%E7%A8%8B%EF%BC%9A%EF%BC%88%E4%B8%89%EF%BC%89%E4%BD%BF%E7%94%A8Hexo%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[尽管 Hexo 支持 MarkDown，但是我们却不能像写单独的 MarkDown 文档时那样肆无忌惮。由于我们所写的文档是需要被解析为静态网页文件的，所以我们必须严格遵从 Hexo 的规范，这样才能解析出条理清晰的静态网页文件。 新建文档假设我们的文章名为 “hello hexo markdwon”，在命令行键入以下命令即可： 1$ hexo new "hello hexo markdown" 上述命令的结果是在 ./hexo/source/_posts 路径下新建了一个 hello-hexo-markdown.md 文件。 然后，我们就可以打开编辑器尽情地写作了。 文档格式我们使用文本编辑器打开刚刚新建的 hello-hexo-markdown.md 文件，会发现其中已经存在内容： 12345---title: hello hexo markdowndate: 2016-11-16 18:11:25tags:--- 这些内容是干嘛的呢？事实上，他们就是用于设置 MarkDown 文档在被解析为静态网页文件时的相关配置，这些配置参数一般位于文件中最上方以 --- 分隔的区域。 其中，title 的值是当前文档名，也是将来在网页中显示的文章标题。 date 值是我们新建文档时的当地时区时间。 tags 值是文档的标签，我们可以随意赋值为文档贴标签。其用法如下： 12345678---title: hello hexo markdowndate: 2016-11-16 18:11:25tags:- hello- hexo- markdown--- 上面的配置参数为这篇文档贴上了 hello、hexo、mardown 标签，如果站点使用的主题支持标签功能，MarkDown 文档被解析为静态网页文件后就可以看到效果。 除了以上这些，还有很多预先定义的参数 Front-mtter，我们这里选取一个常用且较为典型的配置参数 categories 讲解一下。 文章分类categories 是用来给文章分类的，它跟 tags 不同的是其具有顺序性和层次性。 例如，我们写一篇关于 CSS3 动画的文章，我们可能会为其打标签 ”CSS3“、”动画“等，但是我们却会将其分在 CSS/CSS3 类别下，这个是有一定的相关性、顺序性和层次性。简单来说，categories 有点儿像新建文件夹对文档进行分门别类的归置。 categories 的用法同 tags 一样，只不过斗个 categories 值是分先后顺序的。 引用资源写个博客，有时候我们会想添加个图片啦 O.O，或者其他形式的资源，等等。 这时，有两种解决办法： 使用绝对路径引用资源，在 Web 世界中就是资源的 URL 使用相对路径引用资源 文章资源文件夹如果是使用相对路径引用资源，那么我们可以使用 Hexo 提供的资源文件夹功能。 使用文本编辑器打开站点根目录下的 _ config.yml 文件，将 post_asset_folder 值设置为 true。 1post_asset_folder: true 上面的操作会开启 Hexo 的文章资源文件管理功能。Hexo 将会在我们每一次通过 hexo new &lt;title&gt; 命令创建新文章时自动创建一个同名文件夹，于是我们便可以将文章所引用的相关资源放到这个同名文件夹下，然后通过相对路径引用。 相对路径引用的标签插件通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。我们可以通过使用 Hexo 提供的标签插件来解决这个问题： 123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](/example.jpg) ，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作） ！！！注意： 如果已经开启了文章的资源文件夹功能，当使用 MarkDown 语法引用相对路径下的资源时，只需 ./资源名称，不用在引用路径中添加同名文件夹目录层级。 正确的引用图片方式是使用下列的标签插件而不是 markdown ： 1&#123;% asset_img example.jpg This is an example image %&#125; 通过这种方式，图片将会同时出现在文章和主页以及归档页中。 文章摘要有的时候，主题模板配置的不够好的话，Hexo 最终生成的静态站点是不会自动生成文章摘要的。 所以，为了保险起见，我们也自己手动设置文章摘要，这样也方便避免自动生成的摘要不优雅的情况。 设置文章摘要，我们只需在想显示为摘要的内容之后添 &lt;!-- more --&gt; 即可。像下面这样： 1234567891011121314---title: hello hexo markdowndate: 2016-11-16 18:11:25tags:- hello- hexo- markdown---我是短小精悍的文章摘要(๑•̀ㅂ•́)و✧&lt;!-- more --&gt;紧接着文章摘要的正文内容 这样，&lt;!-- more --&gt; 之前、文档配置参数之后中的内容便会被渲染为站点中的文章摘要。 注意！文章摘要在文章详情页是正文中最前面的内容。 生成文件清除缓存文件为了避免不必要的错误，在生成静态文件前，强烈建议先运行以下命令： 1$ hexo clean 上述命令会清除本地站点文件夹下的缓存文件（db.json）和已有的静态文件（public）。 生成静态文件写好 MarkDown 文档之后，我们就可使用以下命令生成静态文件： 1$ hexo generate 然后我们就可以启动 Hexo 服务器，使用浏览器打开 http://localhost:4000 查看效果了。 示范下图是一篇经过配置的简单文档，生成静态文件后在网站首页显示的结果。我们可以看到手动设置的摘要，以及打的标签生效了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo教程：（二）Hexo站点配置]]></title>
      <url>%2F2016%2F11%2F16%2FHexo%E6%95%99%E7%A8%8B%EF%BC%9A%EF%BC%88%E4%BA%8C%EF%BC%89Hexo%E7%AB%99%E7%82%B9%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[Hexo 所初始化的站点文件夹根目录下的 ._config.yml 文件声明了网站的配置信息，我们可以通过修改此文件的配置参数以个性化网站。 配置文件_config.ymlHexo 生成的网站的配置信息均保存在 ._config.yml 文件中，该文件位于站点文件夹下的根目录下。 我们可以通过修改 ._config.yml 文件中的参数配置来自定义 Hexo 生成的静态站点。 使用文本编辑器打开该文件，我们会发现其中有详尽的参数，这里只选取一部分具有代表性的参数配置进行介绍。详情戳这里 ⇨ 配置。 网站相关 title ：网站标题 subtitle ：网站副标题 description ：网站描述 author ：作者名字 网址相关 url ：网址 root ：网站根目录 文章相关 auto_spacing ：在中文和英文之间加入空格，默认值为 false external_link ：在新标签中打开链接，默认值为 true render_drafts ：显示草稿，默认值为 false post_asset_folder ：开启文章地资源管理文件夹，默认值为 false highlight ：代码块的设置，包括有 enable、line_number、auto_detect 和 tab_replace 属性可设置。不过一般不用修改，大多数主题都默认是支持代码语法高亮等设置的。 分页相关 per_page ：每页显示的文章数，默认值为 10，值为 0 时会关闭分页功能 新建菜单页Hexo 生成的站点默认菜单也有限，如果我们想自定义添加菜单页该怎么操作呢？比如说，我们想新建一个名为 Abou 的菜单页。 站点根目录下，命令行中输入： 1$ hexo new page "about" 上面的命令生效以后，根目录下的 source 文件夹中会新增一个名为 about 的文件夹，里面有个 index.md 文档。我们将想要在 About 菜单页中显示的内容，按照博文格式写在这个文档里即可。 然后，修改 ./themes/your-theme-name/_config.yml 文件中的 menu 项，在下面添加一行 About: /about 即可。 示范下图是我修改了网站相关配置参数值之后的网站首页，可以很明显地看出与网站标题与副标题发生了变化。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo教程：（一）安装及使用初体验]]></title>
      <url>%2F2016%2F11%2F16%2FHexo%E6%95%99%E7%A8%8B%EF%BC%9A%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
      <content type="text"><![CDATA[Hexo 是一个由 Node.js 驱动的快速、简洁、高效的博客框架。Hexo 具有许多优点，使用它我们可以快速地搭建自己的本地博客站点，并能将其推送到 GitHub 仓库。这篇文章简单介绍了 Hexo 地安装及初次使用。 安装前提 Git Node.js 此处不再赘述以上二者的安装过程，点击链接去官网下载与自己操作系统对应的版本，按照默认配置一步步安装即可。 安装完之后，命令提示符输入以下命令检测是否成功安装： 12$ git --version$ node --version 出现上图所示的提示信息，即成功安装 Git 和 Node.js，如此，方可进行后续操作。 安装 Hexo在命令行输入以下命令，以将 Hexo 安装到全局环境： 1$ npm install hexo-cli -g 成功安装后，会出现诸如 -- hexo-cli@1.0.2 的提示信息。 注意！提示信息末尾可能会出现 npm WARN 警告信息，不过不要怕，那不会影响使用的，只要不是 npm ERROR 错误消息就好 (^_^)！ 初始化站点文件夹接下来，我们将运行命令初始化一个新的文件夹，作为我们的本地站点： 1$ hexo init hexo 以上命令将先在当前路径下新建一个名为 hexo 的文件夹，然后 Hexo 会对其初始化，即从远程 git 仓库 clone 站点所需的文件。 接着，进入新建的站点文件夹 hexo，继续安装站点文件所需的 npm 包依赖： 12$ cd hexo$ npm install 现在，我们文件夹的目录结构看起来应该像下面这个样子： 123456789101112.|—— node_modules|—— scaffolds|—— source| |—— _posts|—— themes| |—— landscape|—— .gitignore|—— .npmignore|—— _config.yml|—— db.json|—— package.json 安装服务器Hexo 3.0 把服务器独立成了个别模块，我们必须得在站点文件夹根目录下安装之后才能使用。 在命令行中打开我们的 hexo 文件夹，键入以下命令，以将 hexo-server 安装到我们的 hexo 文件夹： 1$ npm install hexo-server --save Hexo站点初体验接下来，我们演示一下 Hexo 生成的静态站点。 别担心，尽管到现在为止我们一篇文章也没写，而且站点主题也没经过任何配置，但还是会看到效果的。因为 Hexo 初始化的全新站点文件夹有一个内置的默认主题样式，同时也有一篇 Hello World 文章。 清除缓存文件1$ hexo clean 此命令用于清除缓存文件（db.json）和已生成的静态文件(public)。 生成静态文件1$ hexo generate 此命令用于生成静态文件，就是按照主题的模板文件配置将 markdown 文件生成为静态 html 文件。 此命令可简写为 hexo g。 当运行上述命令后，我们站点文件夹的目录结构下会多出一个 public 文件夹，这个文件夹中的文件就是 Hexo 帮我们生成的站点静态文件。 启动服务器1$ hexo server 此命令会启动 Hexo 服务器，可简写为 hexo s。 默认状态下，我们的网站是运行在 http://localhost:4000 ，使用浏览器打开这个地址就可看到效果。 看！⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣⇣ 这就是 Hexo 在本地生成的站点效果 (●’◡’●)]]></content>
    </entry>

    
  
  
</search>
